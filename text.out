# 1 "baan.c"
# 1 "/var/www/html/baan/newest_version//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "baan.c"


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 1 3 4
# 385 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 386 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 1 3 4
# 10 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h" 1 3 4
# 11 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 3 4
typedef unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/bits/types.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 121 "/usr/include/arm-linux-gnueabihf/bits/types.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/typesizes.h" 1 3 4
# 122 "/usr/include/arm-linux-gnueabihf/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;


__extension__ typedef int __fsword_t;

__extension__ typedef int __ssize_t;


__extension__ typedef long int __syscall_slong_t;

__extension__ typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 390 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));














extern FILE *tmpfile (void) ;
# 209 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 232 "/usr/include/stdio.h" 3 4





extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "/usr/include/stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4

# 329 "/usr/include/stdio.h" 3 4



extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 420 "/usr/include/stdio.h" 3 4





extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 684 "/usr/include/stdio.h" 3 4





extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4

# 824 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4
# 863 "/usr/include/stdio.h" 3 4
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);
# 913 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "/usr/include/stdio.h" 3 4

# 4 "baan.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 324 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4


# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 314 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 98 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __pid_t pid_t;
# 109 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
# 132 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4
# 146 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 147 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 1 3 4
# 34 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap-16.h" 1 3 4
# 35 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 2 3 4
# 43 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 74 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 217 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/sys/select.h" 1 3 4
# 30 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/select.h" 1 3 4
# 31 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
# 22 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
# 30 "/usr/include/arm-linux-gnueabihf/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4

# 106 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 131 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4

# 220 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 3 4

# 223 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4
# 235 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 273 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4

# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));

# 464 "/usr/include/stdlib.h" 3 4


extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;
# 513 "/usr/include/stdlib.h" 3 4


extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 530 "/usr/include/stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));













extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 584 "/usr/include/stdlib.h" 3 4
extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 712 "/usr/include/stdlib.h" 3 4





extern int system (const char *__command) ;

# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 752 "/usr/include/stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 775 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 830 "/usr/include/stdlib.h" 3 4
extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));

# 951 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/arm-linux-gnueabihf/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4

# 5 "baan.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h" 1 3 4
# 98 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 6 "baan.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 353 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 417 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 497 "/usr/include/unistd.h" 3 4
extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;
# 525 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));
# 543 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 563 "/usr/include/unistd.h" 3 4
extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 598 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/arm-linux-gnueabihf/bits/confname.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));
# 628 "/usr/include/unistd.h" 3 4
extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));
# 646 "/usr/include/unistd.h" 3 4
extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));







extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 700 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;
# 756 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));





extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;
# 803 "/usr/include/unistd.h" 3 4
extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;
# 826 "/usr/include/unistd.h" 3 4
extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 835 "/usr/include/unistd.h" 3 4
extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);
# 862 "/usr/include/unistd.h" 3 4
extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 879 "/usr/include/unistd.h" 3 4
extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);
# 969 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1151 "/usr/include/unistd.h" 3 4

# 7 "baan.c" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };
# 54 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 1 3 4
# 341 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4

# 415 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4

# 54 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 146 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 156 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 202 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 292 "/usr/include/fcntl.h" 3 4

# 8 "baan.c" 2
# 1 "/usr/include/termios.h" 1 3 4
# 35 "/usr/include/termios.h" 3 4




# 1 "/usr/include/arm-linux-gnueabihf/bits/termios.h" 1 3 4
# 23 "/usr/include/arm-linux-gnueabihf/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;


struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
# 40 "/usr/include/termios.h" 2 3 4
# 48 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern speed_t cfgetispeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));




extern int tcgetattr (int __fd, struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsetattr (int __fd, int __optional_actions,
        const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));




extern void cfmakeraw (struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsendbreak (int __fd, int __duration) __attribute__ ((__nothrow__ , __leaf__));





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) __attribute__ ((__nothrow__ , __leaf__));



extern int tcflow (int __fd, int __action) __attribute__ ((__nothrow__ , __leaf__));
# 104 "/usr/include/termios.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/ttydefaults.h" 1 3 4
# 105 "/usr/include/termios.h" 2 3 4



# 9 "baan.c" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
# 42 "/usr/include/time.h" 2 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};



# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));

# 236 "/usr/include/time.h" 3 4



extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 430 "/usr/include/time.h" 3 4

# 10 "baan.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/time.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/sys/time.h" 2 3 4
# 37 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4

# 55 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 189 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4

# 11 "baan.c" 2
# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4




# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_val.h" 1 3 4
# 33 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_valf.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_vall.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/inf.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/nan.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/mathdef.h" 1 3 4
# 26 "/usr/include/arm-linux-gnueabihf/bits/mathdef.h" 3 4
typedef float float_t;

typedef double double_t;
# 46 "/usr/include/math.h" 2 3 4
# 69 "/usr/include/math.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));

# 86 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));







extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 126 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));






extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));






extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));




# 371 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4
extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 70 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

# 86 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));







extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 126 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));






extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));




# 371 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4
extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 89 "/usr/include/math.h" 2 3 4
# 132 "/usr/include/math.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

# 86 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));







extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 126 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));




# 371 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4
extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 133 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
extern int signgam;
# 189 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 301 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 488 "/usr/include/math.h" 3 4

# 12 "baan.c" 2
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4
# 41 "/usr/include/sched.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 1 3 4
# 72 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };


# 95 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4








struct __sched_param
  {
    int __sched_priority;
  };
# 118 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 201 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 42 "/usr/include/sched.h" 2 3 4







extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));
# 124 "/usr/include/sched.h" 3 4

# 24 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 1 3 4
# 37 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/setjmp.h" 1 3 4
# 34 "/usr/include/arm-linux-gnueabihf/bits/setjmp.h" 3 4
typedef int __jmp_buf[64] __attribute__((__aligned__ (8)));
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP
# 59 "/usr/include/pthread.h" 3 4
};
# 166 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 201 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 239 "/usr/include/pthread.h" 3 4





extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);
# 282 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 440 "/usr/include/pthread.h" 3 4
extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));
# 505 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 517 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 551 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 691 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;
# 703 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;
# 744 "/usr/include/pthread.h" 3 4
extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 784 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 849 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 979 "/usr/include/pthread.h" 3 4
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1011 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1122 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));
# 1170 "/usr/include/pthread.h" 3 4

# 13 "baan.c" 2
# 1 "/usr/include/wiringPi.h" 1 3 4
# 113 "/usr/include/wiringPi.h" 3 4
extern const char *piModelNames [16] ;
extern const char *piRevisionNames [16] ;
extern const char *piMakerNames [16] ;
extern const int piMemorySize [ 8] ;
# 139 "/usr/include/wiringPi.h" 3 4
struct wiringPiNodeStruct
{
  int pinBase ;
  int pinMax ;

  int fd ;
  unsigned int data0 ;
  unsigned int data1 ;
  unsigned int data2 ;
  unsigned int data3 ;

           void (*pinMode) (struct wiringPiNodeStruct *node, int pin, int mode) ;
           void (*pullUpDnControl) (struct wiringPiNodeStruct *node, int pin, int mode) ;
           int (*digitalRead) (struct wiringPiNodeStruct *node, int pin) ;

           void (*digitalWrite) (struct wiringPiNodeStruct *node, int pin, int value) ;

           void (*pwmWrite) (struct wiringPiNodeStruct *node, int pin, int value) ;
           int (*analogRead) (struct wiringPiNodeStruct *node, int pin) ;
           void (*analogWrite) (struct wiringPiNodeStruct *node, int pin, int value) ;

  struct wiringPiNodeStruct *next ;
} ;

extern struct wiringPiNodeStruct *wiringPiNodes ;
# 178 "/usr/include/wiringPi.h" 3 4
extern int wiringPiFailure (int fatal, const char *message, ...) ;



extern struct wiringPiNodeStruct *wiringPiFindNode (int pin) ;
extern struct wiringPiNodeStruct *wiringPiNewNode (int pinBase, int numPins) ;

extern void wiringPiVersion (int *major, int *minor) ;
extern int wiringPiSetup (void) ;
extern int wiringPiSetupSys (void) ;
extern int wiringPiSetupGpio (void) ;
extern int wiringPiSetupPhys (void) ;

extern void pinModeAlt (int pin, int mode) ;
extern void pinMode (int pin, int mode) ;
extern void pullUpDnControl (int pin, int pud) ;
extern int digitalRead (int pin) ;
extern void digitalWrite (int pin, int value) ;
extern unsigned int digitalRead8 (int pin) ;
extern void digitalWrite8 (int pin, int value) ;
extern void pwmWrite (int pin, int value) ;
extern int analogRead (int pin) ;
extern void analogWrite (int pin, int value) ;




extern int wiringPiSetupPiFace (void) ;
extern int wiringPiSetupPiFaceForGpioProg (void) ;



extern int piGpioLayout (void) ;
extern int piBoardRev (void) ;
extern void piBoardId (int *model, int *rev, int *mem, int *maker, int *overVolted) ;
extern int wpiPinToGpio (int wpiPin) ;
extern int physPinToGpio (int physPin) ;
extern void setPadDrive (int group, int value) ;
extern int getAlt (int pin) ;
extern void pwmToneWrite (int pin, int freq) ;
extern void pwmSetMode (int mode) ;
extern void pwmSetRange (unsigned int range) ;
extern void pwmSetClock (int divisor) ;
extern void gpioClockSet (int pin, int freq) ;
extern unsigned int digitalReadByte (void) ;
extern unsigned int digitalReadByte2 (void) ;
extern void digitalWriteByte (int value) ;
extern void digitalWriteByte2 (int value) ;




extern int waitForInterrupt (int pin, int mS) ;
extern int wiringPiISR (int pin, int mode, void (*function)(void)) ;



extern int piThreadCreate (void *(*fn)(void *)) ;
extern void piLock (int key) ;
extern void piUnlock (int key) ;



extern int piHiPri (const int pri) ;



extern void delay (unsigned int howLong) ;
extern void delayMicroseconds (unsigned int howLong) ;
extern unsigned int millis (void) ;
extern unsigned int micros (void) ;
# 14 "baan.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4


# 1 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 1 3 4
# 25 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 1 3 4
# 43 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 29 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 2 3 4
# 39 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;
# 50 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;
# 65 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 77 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 120 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4

# 27 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 29 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4
# 38 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4
# 38 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/socket_type.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4
# 146 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 147 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 162 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,






    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 272 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));
# 299 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
enum
  {
    SCM_RIGHTS = 0x01





  };
# 345 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/arm-linux-gnueabihf/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/socket.h" 2 3 4
# 346 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4
# 379 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 39 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 113 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, const struct sockaddr * __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 137 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int connect (int __fd, const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, const struct sockaddr * __addr,
         socklen_t __addr_len);
# 174 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);
# 202 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);
# 219 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 243 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);
# 261 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));
# 274 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));
# 283 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4

# 15 "baan.c" 2
# 1 "/usr/include/netinet/in.h" 1 3 4
# 22 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wchar.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 128 "/usr/include/stdint.h" 3 4
typedef unsigned int uintptr_t;
# 137 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 10 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h" 2 3 4
# 23 "/usr/include/netinet/in.h" 2 3 4







typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/arm-linux-gnueabihf/bits/in.h" 1 3 4
# 112 "/usr/include/arm-linux-gnueabihf/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 209 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 237 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 374 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 1 3 4
# 386 "/usr/include/netinet/in.h" 2 3 4
# 501 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 628 "/usr/include/netinet/in.h" 3 4

# 16 "baan.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 127 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 176 "/usr/include/string.h" 3 4
extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "/usr/include/string.h" 3 4

# 236 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 282 "/usr/include/string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 397 "/usr/include/string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

# 411 "/usr/include/string.h" 3 4


extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 451 "/usr/include/string.h" 3 4
extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 534 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 557 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 644 "/usr/include/string.h" 3 4

# 17 "baan.c" 2
# 1 "/usr/include/openssl/sha.h" 1 3 4
# 62 "/usr/include/openssl/sha.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 63 "/usr/include/openssl/sha.h" 2 3 4
# 1 "/usr/include/openssl/e_os2.h" 1 3 4
# 56 "/usr/include/openssl/e_os2.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/openssl/opensslconf.h" 1 3 4
# 57 "/usr/include/openssl/e_os2.h" 2 3 4
# 64 "/usr/include/openssl/sha.h" 2 3 4
# 100 "/usr/include/openssl/sha.h" 3 4
typedef struct SHAstate_st {
    unsigned int h0, h1, h2, h3, h4;
    unsigned int Nl, Nh;
    unsigned int data[16];
    unsigned int num;
} SHA_CTX;





int SHA_Init(SHA_CTX *c);
int SHA_Update(SHA_CTX *c, const void *data, size_t len);
int SHA_Final(unsigned char *md, SHA_CTX *c);
unsigned char *SHA(const unsigned char *d, size_t n, unsigned char *md);
void SHA_Transform(SHA_CTX *c, const unsigned char *data);





int SHA1_Init(SHA_CTX *c);
int SHA1_Update(SHA_CTX *c, const void *data, size_t len);
int SHA1_Final(unsigned char *md, SHA_CTX *c);
unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md);
void SHA1_Transform(SHA_CTX *c, const unsigned char *data);
# 134 "/usr/include/openssl/sha.h" 3 4
typedef struct SHA256state_st {
    unsigned int h[8];
    unsigned int Nl, Nh;
    unsigned int data[16];
    unsigned int num, md_len;
} SHA256_CTX;






int SHA224_Init(SHA256_CTX *c);
int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);
int SHA224_Final(unsigned char *md, SHA256_CTX *c);
unsigned char *SHA224(const unsigned char *d, size_t n, unsigned char *md);
int SHA256_Init(SHA256_CTX *c);
int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);
int SHA256_Final(unsigned char *md, SHA256_CTX *c);
unsigned char *SHA256(const unsigned char *d, size_t n, unsigned char *md);
void SHA256_Transform(SHA256_CTX *c, const unsigned char *data);
# 183 "/usr/include/openssl/sha.h" 3 4
typedef struct SHA512state_st {
    unsigned long long h[8];
    unsigned long long Nl, Nh;
    union {
        unsigned long long d[16];
        unsigned char p[(16*8)];
    } u;
    unsigned int num, md_len;
} SHA512_CTX;







int SHA384_Init(SHA512_CTX *c);
int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);
int SHA384_Final(unsigned char *md, SHA512_CTX *c);
unsigned char *SHA384(const unsigned char *d, size_t n, unsigned char *md);
int SHA512_Init(SHA512_CTX *c);
int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);
int SHA512_Final(unsigned char *md, SHA512_CTX *c);
unsigned char *SHA512(const unsigned char *d, size_t n, unsigned char *md);
void SHA512_Transform(SHA512_CTX *c, const unsigned char *data);
# 18 "baan.c" 2
# 1 "./src/b64.c" 1



const char *BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";







void _base64_encode_triple(unsigned char triple[3], char result[4])
 {
    int tripleValue, i;

    tripleValue = triple[0];
    tripleValue *= 256;
    tripleValue += triple[1];
    tripleValue *= 256;
    tripleValue += triple[2];

    for (i=0; i<4; i++)
    {
 result[3-i] = BASE64_CHARS[tripleValue%64];
 tripleValue /= 64;
    }
}
# 38 "./src/b64.c"
int base64_encode(unsigned char *source, size_t sourcelen, char *target, size_t targetlen)
 {

    if ((sourcelen+2)/3*4 > targetlen-1)
 return 0;


    while (sourcelen >= 3)
    {
 _base64_encode_triple(source, target);
 sourcelen -= 3;
 source += 3;
 target += 4;
    }


    if (sourcelen > 0)
    {
 unsigned char temp[3];
 memset(temp, 0, sizeof(temp));
 memcpy(temp, source, sourcelen);
 _base64_encode_triple(temp, target);
 target[3] = '=';
 if (sourcelen == 1)
     target[2] = '=';

 target += 4;
    }


    target[0] = 0;

    return 1;
}







int _base64_char_value(char base64char)
 {
    if (base64char >= 'A' && base64char <= 'Z')
 return base64char-'A';
    if (base64char >= 'a' && base64char <= 'z')
 return base64char-'a'+26;
    if (base64char >= '0' && base64char <= '9')
 return base64char-'0'+2*26;
    if (base64char == '+')
 return 2*26+10;
    if (base64char == '/')
 return 2*26+11;
    return -1;
}
# 101 "./src/b64.c"
int _base64_decode_triple(char quadruple[4], unsigned char *result)
 {
    int i, triple_value, bytes_to_decode = 3, only_equals_yet = 1;
    int char_value[4];

    for (i=0; i<4; i++)
 char_value[i] = _base64_char_value(quadruple[i]);


    for (i=3; i>=0; i--)
    {
 if (char_value[i]<0)
 {
     if (only_equals_yet && quadruple[i]=='=')
     {


  char_value[i]=0;
  bytes_to_decode--;
  continue;
     }
     return 0;
 }

 only_equals_yet = 0;
    }


    if (bytes_to_decode < 0)
 bytes_to_decode = 0;


    triple_value = char_value[0];
    triple_value *= 64;
    triple_value += char_value[1];
    triple_value *= 64;
    triple_value += char_value[2];
    triple_value *= 64;
    triple_value += char_value[3];


    for (i=bytes_to_decode; i<3; i++)
 triple_value /= 256;
    for (i=bytes_to_decode-1; i>=0; i--)
    {
 result[i] = triple_value%256;
 triple_value /= 256;
    }

    return bytes_to_decode;
}
# 161 "./src/b64.c"
size_t base64_decode(char *source, unsigned char *target, size_t targetlen)
 {
    char *src, *tmpptr;
    char quadruple[4], tmpresult[3];
    int i, tmplen = 3;
    size_t converted = 0;


    src = (char *)malloc(strlen(source)+5);
    if (src == ((void *)0))
 return -1;
    strcpy(src, source);
    strcat(src, "====");
    tmpptr = src;


    while (tmplen == 3)
    {

 for (i=0; i<4; i++)
 {

     while (*tmpptr != '=' && _base64_char_value(*tmpptr)<0)
  tmpptr++;

     quadruple[i] = *(tmpptr++);
 }


 tmplen = _base64_decode_triple(quadruple, tmpresult);


 if (targetlen < tmplen)
 {
     free(src);
     return -1;
 }


 memcpy(target, tmpresult, tmplen);
 target += tmplen;
 targetlen -= tmplen;
 converted += tmplen;
    }

    free(src);
    return converted;
}
# 19 "baan.c" 2

# 1 "settings.h" 1
# 21 "baan.c" 2
# 37 "baan.c"
int stop = 0;
int startup = 0;

# 1 "./src/signals.h" 1
struct signal{
  int id;
  int MAdr;
  int UAdr;
  int state;
  int type;
};

struct signal *signals[16*16*8] = {};
# 41 "baan.c" 2

int delayA = 5000000;
int delayB = 5000000;
int initialise = 1;
char setup_data[100];
char setup_data_l = 0;
int status_st[20] = {0};

_Bool digital_track = 0;

pthread_mutex_t mutex_lockA;
pthread_mutex_t mutex_lockB;
pthread_t timer_thread[5];
int timers[5] = {0};

struct adr{
 int M;
 int B;
 int S;
 int type;
};

struct Seg{
 struct adr Adr;
 struct adr NAdr;
 struct adr PAdr;
 char max_speed;
 char state;
 char dir;
 char length;
 char train;
 _Bool blocked;
 _Bool change;
 _Bool oneWay;






 struct signal * NSi;
 struct signal * PSi;

};

struct Station{
 struct adr Adr;
 struct Seg * Blocks[8];
 char type;
};

struct link{
 struct adr Adr1;
 struct adr Adr2;
 struct adr Adr3;
 struct adr Adr4;
};


# 1 "./src/Web.h" 1




struct web_client_t{
  int fd_client;
  int client_type;
# 18 "./src/Web.h"
  int state;
};

int websocket_connect(struct web_client_t * C);

int recv_packet(int fd_client, char outbuf[]);

int send_packet(int fd_client, char data[],int length,int flag);

int send_all(char data[],int length,int flag);

int recv_packet_procces(char data[]);

void * websocket_client(void * thread_data);

void *clear_clients();

void * web_server();
# 101 "baan.c" 2

struct train;

struct adr Adresses[16*16*8] = {};

struct adr Block_list[16*16*8] = {};
struct adr Station_list[16*16] = {};
struct adr Switch_list[16*16*8] = {};
struct adr MS_Switch_list[16*16*8] = {};
char List_of_Modules[16] = {0};

int B_list_i = 0, St_list_i = 0, S_list_i = 0, M_list_i = 0, Si_list_i = 0;

struct adr StartAdr;
struct Seg * blocks[16][16][8] = {};
struct Station * stations[16*16] = {};

struct adr C_Adr(char M,char B,char S){
 struct adr Z;

 Z.M = M;
 Z.B = B;
 Z.S = S;
 Z.type = 'R';

 return Z;
}

struct adr * c_Adr(char M,char B,char S){
 struct adr *Z = (struct adr*)malloc(sizeof(struct adr));

 Z->M = M;
 Z->B = B;
 Z->S = S;
 Z->type = 'R';

 return Z;
}

struct adr C_AdrT(char M,char B,char S,char T){
 struct adr Z;

 Z.M = M;
 Z.B = B;
 Z.S = S;
 Z.type = T;

 return Z;
}

struct adr * c_AdrT(char M,char B,char S,char T){
 struct adr *Z = (struct adr*)malloc(sizeof(struct adr));

 Z->M = M;
 Z->B = B;
 Z->S = S;
 Z->type = T;

 return Z;
}



struct Seg * C_Seg(int Unit_Adr, struct adr Adr, char state);

void Create_Segment(int Unit_Adr, struct adr Adr,struct adr NAdr,struct adr PAdr,char max_speed,char state,char dir,char len);

int Create_Station(struct adr Adr);

int Adr_Comp(struct adr A,struct adr B);

struct Unit{
 int B_L;
 int S_L;
 int Si_L;

 struct Seg * B[16*8];
 struct Swi * S[16*8];
 struct Mod * M[16*8];
 struct signal * Signals[16*8];
};

struct Unit *Units[16];

# 1 "./src/switch.h" 1
struct L_Swi_t{
 struct adr Adr;
 int states[5];
};

struct P_Swi_t{
 char type;
 char state;
};

struct Swi{
 struct adr Adr;

 struct adr Div;
 struct adr Str;
 struct adr App;
 char state;
 char len;
 char UAdr;

 struct L_Swi_t * L_Swi[5];

 struct P_Swi_t * pref[5];
};

struct Mod{
 struct adr Adr;

 struct adr mAdr[10];
 struct adr MAdr[10];
 char length;
 char s_length;
 char state;
};

struct Swi *Switch[16][16][8] = {};
struct Mod *Moduls[16][16][8/4] = {};

int throw_switch(struct Swi * S);

int throw_ms_switch(struct Mod * M, char c);

void Create_Switch(int Unit_Adr, struct adr Adr,struct adr App,struct adr Div,struct adr Str,char state);

void Create_Moduls(int Unit_Adr, struct adr Adr,struct adr mAdr[10],struct adr MAdr[10],char length);
# 186 "baan.c" 2

# 1 "./src/COM.h" 1
struct COM_t{
 char Adr;
 char Length;
 char Opcode;
 char Data[32];
};

void * UART();

char * COM_Send(struct COM_t DATA);

int COM_Recv(char * OUT_Data);

char * COM_SaR(char * buf[60]);

void COM_change_A_signal(int M);

void COM_change_A_switch(int M);

void COM_change_signal(struct signal * Si);

void COM_change_switch(struct Swi * S);

void COM_set_train_speed(struct train * T,char speed);
# 188 "baan.c" 2
# 1 "./src/switch.c" 1
int throw_switch(struct Swi * S){
 int linked = 0;
  for(int i = 0;i<5;i++){
    if(S->L_Swi[i] != ((void *)0)){
   linked = 1;
      struct adr A = S->L_Swi[i]->Adr;

      if((blocks[A.M][A.B][0] != ((void *)0) && blocks[A.M][A.B][0]->state != 5) ||
            (blocks[A.M][A.B][1] != ((void *)0) && blocks[A.M][A.B][1]->state != 5)){
      }else{
        return 0;
      }
    }
  }
  if((blocks[S->Adr.M][S->Adr.B][0] != ((void *)0) && blocks[S->Adr.M][S->Adr.B][0]->state != 5) ||
        (blocks[S->Adr.M][S->Adr.B][1] != ((void *)0) && blocks[S->Adr.M][S->Adr.B][1]->state != 5)){
    S->state = !S->state;

    char buf[40];
    buf[0] = 4;
  int index = 1;

  buf[index++] = S->Adr.M;
  buf[index++] = S->Adr.B;
  buf[index++] = S->Adr.S;
  buf[index++] = Switch[S->Adr.M][S->Adr.B][S->Adr.S]->state;

    for(int i = 0;i<5;i++){
      if(S->L_Swi[i] != ((void *)0)){
        struct adr A = S->L_Swi[i]->Adr;
        printf("Linked switching (%i:%i:%i",A.M,A.B,A.S);

        Switch[A.M][A.B][A.S]->state = S->L_Swi[i]->states[S->state];
        printf(" => %i)\n",Switch[A.M][A.B][A.S]->state);

    buf[index++] = A.M;
    buf[index++] = A.B;
    buf[index++] = A.S;
    buf[index++] = Switch[A.M][A.B][A.S]->state;
      }
    }
    printf("Throw Switch %s\n\n",buf);
  if(linked == 0){
   COM_change_switch(S);
  }else{
   COM_change_A_switch(S->Adr.M);
  }
    send_all(buf,index,2);
    return 1;
  }else{
    return 0;
  }
}

int throw_ms_switch(struct Mod * M, char c){
  if((blocks[M->Adr.M][M->Adr.B][0] != ((void *)0) && blocks[M->Adr.M][M->Adr.B][0]->state != 5) ||
        (blocks[M->Adr.M][M->Adr.B][1] != ((void *)0) && blocks[M->Adr.M][M->Adr.B][1]->state != 5)){
    M->state = c;
    char buf[30];
    sprintf(buf,"{\"Mod\" : [[%i,%i,%i,%i,%i]]}",M->Adr.M,M->Adr.B,M->Adr.S,M->state,M->length);
    printf("Throw ms Switch %s\n\n",buf);
    send_all(buf,strlen(buf),2);
    return 1;
  }else{
    return 0;
  }
}

void Create_Switch(int Unit_Adr, struct adr Adr,struct adr App,struct adr Div,struct adr Str,char state){
 struct Swi *Z = (struct Swi*)malloc(sizeof(struct Swi));

 Adr.type = 'S';

 Z->Adr = Adr;
 Z->Str = Str;
 Z->Div = Div;
 Z->App = App;
 Z->state = state;
 Z->len = 1;

 if(Adr.S > 1){
  Z->len = Adr.S;
  for(int i = 1;i<Adr.S;i++){
   if(Switch[Adr.M][Adr.B][i] != ((void *)0)){
    Switch[Adr.M][Adr.B][i]->len = Adr.S;
   }else if(Moduls[Adr.M][Adr.B][i] != ((void *)0)){
    Moduls[Adr.M][Adr.B][i]->s_length = Adr.S;
   }
  }
 }

 for(int i = 0;i<5;i++){
  Z->L_Swi[i] = ((void *)0);
 }

 for(int i = 0;i<5;i++){
  Z->pref[i] = ((void *)0);
 }

 if(blocks[Adr.M][Adr.B][1] == ((void *)0) && blocks[Adr.M][Adr.B][0] == ((void *)0)){
  printf("Switch %i:%i:%i needs a 0 block\n",Adr.M,Adr.B,Adr.S);

 }

 Switch[Adr.M][Adr.B][Adr.S] = Z;

  if(Units[Adr.M]->S[Unit_Adr] == ((void *)0)){
    Units[Adr.M]->S[Unit_Adr] = Z;
  Z->UAdr = Unit_Adr;
    if(Unit_Adr > Units[Adr.M]->S_L){
      Units[Adr.M]->S_L = Unit_Adr;
    };
  }else{
    printf("Double signal adress %i in Module %i\n",Unit_Adr,Adr.M);
  }

 Switch_list[S_list_i] = Adr;
 S_list_i++;
}

void Create_Moduls(int Unit_Adr, struct adr Adr,struct adr mAdr[10],struct adr MAdr[10],char length){
 struct Mod *Z = (struct Mod*)malloc(sizeof(struct Mod));

 Adr.type = 'M';

 Z->Adr = Adr;
 for(int i = 0;i<length;i++){
  printf("i:%i\n",i);
  Z->mAdr[i] = mAdr[i];
  Z->MAdr[i] = MAdr[i];
 }
 Z->length = length;
 Z->state = 0;
 Z->s_length = 1;

 if(Adr.S > 1){
  Z->s_length = Adr.S;
  for(int i = 1;i<Adr.S;i++){
   if(Switch[Adr.M][Adr.B][i] != ((void *)0)){
    Switch[Adr.M][Adr.B][i]->len = Adr.S;
   }else if(Moduls[Adr.M][Adr.B][i] != ((void *)0)){
    Moduls[Adr.M][Adr.B][i]->s_length = Adr.S;
   }
  }
 }


 if(blocks[Adr.M][Adr.B][1] == ((void *)0) && blocks[Adr.M][Adr.B][0] == ((void *)0)){
  printf("Needs 0 block\n");

 }

 Moduls[Adr.M][Adr.B][Adr.S] = Z;



 if(Units[Adr.M]->M[Unit_Adr] == ((void *)0)){
  Units[Adr.M]->M[Unit_Adr] = Z;
 }else{
  printf("Double Switch adress %i in Module %i\n",Unit_Adr,Adr.M);
 }

 MS_Switch_list[M_list_i] = Adr;
 M_list_i++;
}
# 189 "baan.c" 2
# 1 "./src/signals.c" 1
void create_signal(int Unit_Adr,struct Seg * B,int type, int side){
  struct signal *Z = (struct signal*)malloc(sizeof(struct signal));

  Z->state = 0;
  Z->id = Unit_Adr;
  Z->MAdr = B->Adr.M;
  Z->type = type;

  printf("Signal #%i\n",Si_list_i);

  signals[Si_list_i] = Z;

  if(side == 0){
    B->NSi = Z;
  }else if(side == 1){
    B->PSi = Z;
  }

  if(Units[B->Adr.M]->Signals[Unit_Adr] == ((void *)0)){
    Units[B->Adr.M]->Signals[Unit_Adr] = Z;
    Z->UAdr = Unit_Adr;
    if(Unit_Adr > Units[B->Adr.M]->Si_L){
      Units[B->Adr.M]->Si_L = Unit_Adr;
    };
  }else{
    printf("Double signal adress %i in Module %i\n",Unit_Adr,B->Adr.M);
  }


  Si_list_i++;
}

void set_signal(struct signal *Si,int state){
# 44 "./src/signals.c"
  if(Si->type == 0){
    if(state == 4){
      state = 1;
    }else{
      state = 0;
    }
  }else if(Si->type == 1){
    if(state == 4){
      state = 1;
    }else if(state == 2){
      state = 2;
    }else{
      state = 0;
    }
  }

  if(Si->state != state){
    printf("Module %i Signal #%i change to %i\n",Si->MAdr,Si->id,state);
    Si->state = state;
    if(startup == 1){
      COM_change_signal(Si);
    }
  }
}
# 190 "baan.c" 2
# 1 "./src/modules.c" 1
void Create_Unit(int Module){
 struct Unit *Z = (struct Unit*)malloc(sizeof(struct Unit));

 Units[Module] = Z;
}

void join(struct adr Adr, struct adr link){

 if(Adr.type == 'R'){
  blocks[Adr.M][Adr.B][Adr.S]->PAdr = link;

 }else if(Adr.type == 'S'){
  Switch[Adr.M][Adr.B][Adr.S]->App = link;
 }else if(Adr.type == 's'){
  if(Adr_Comp(Switch[Adr.M][Adr.B][Adr.S]->Div, C_AdrT(0,0,0,'e'))){
   Switch[Adr.M][Adr.B][Adr.S]->Div = link;
  }else{
   Switch[Adr.M][Adr.B][Adr.S]->Str = link;
  }
 }
}

struct link Modules(int m, struct link IN){

 struct link link;
 link.Adr3 = C_AdrT(0,0,0,'e');
 link.Adr4 = C_AdrT(0,0,0,'e');

 int Seg_i = 0;
 int Swi_i = 0;
 int Sig_i = 0;

 if(m == 1){
  Create_Unit(m);
  Create_Segment(00,C_Adr(m,1,1),C_AdrT(m,2,1,'S'),C_AdrT(0,0,0,'e'),250,0,2,100);
  C_Seg(01,C_Adr(m,2,0),0);
   Create_Switch(01,C_Adr(m,2,1),C_Adr(m,1,1),C_AdrT(m,3,1,'s'),IN.Adr1,1);

  C_Seg(02,C_Adr(m,3,0),0);
   Create_Switch(02,C_Adr(m,3,1),C_Adr(m,4,1),C_AdrT(m,2,1,'s'),IN.Adr2,1);
  Create_Segment(03,C_Adr(m,4,1),C_AdrT(m,3,1,'S'),C_AdrT(0,0,0,'e'),250,0,1,100);

  link.Adr1 = C_Adr(m,1,1);
  link.Adr2 = C_Adr(m,4,1);
 }
 else if(m == 2){
  Create_Unit(m);
    join(IN.Adr1,C_Adr(m,1,1));
  Create_Segment(00,C_Adr(m,1,1),IN.Adr1,C_AdrT(m,2,1,'S'),250,0,2,100);
  C_Seg(01,C_Adr(m,2,0),0);
   Create_Switch(00,C_Adr(m,2,1),C_Adr(m,1,1),C_AdrT(m,3,1,'s'),C_AdrT(0,0,0,'e'),1);

  C_Seg(02,C_Adr(m,3,0),0);
   Create_Switch(01,C_Adr(m,3,1),C_Adr(m,4,1),C_AdrT(m,2,1,'s'),C_AdrT(0,0,0,'e'),1);
    join(IN.Adr2,C_Adr(m,4,1));
  Create_Segment(03,C_Adr(m,4,1),IN.Adr2,C_AdrT(m,3,1,'S'),250,0,1,100);

  link.Adr1 = C_AdrT(m,2,1,'s');
  link.Adr2 = C_AdrT(m,3,1,'s');
 }
 else if(m == 3){
  Create_Unit(m);
  join(IN.Adr1,C_Adr(m,1,1));
  Create_Segment(Seg_i++,C_Adr(m,1,1),IN.Adr1,C_AdrT(m,1,1,'S'),90,0,0,100);
   Create_Switch(Swi_i++,C_Adr(m,1,1),C_Adr(m,1,1),C_Adr(m,2,1),C_Adr(m,3,1),1);

  Create_Segment(Seg_i++,C_Adr(m,2,1),C_AdrT(m,1,1,'s'),C_Adr(m,2,2),90,0,0,100);
  Create_Segment(Seg_i++,C_Adr(m,2,2),C_Adr(m,2,1),C_AdrT(m,4,1,'s'),90,0,0,100);

  Create_Segment(Seg_i++,C_Adr(m,3,1),C_AdrT(m,1,1,'s'),C_Adr(m,3,2),90,0,0,100);
  Create_Segment(Seg_i++,C_Adr(m,3,2),C_Adr(m,3,1),C_AdrT(m,4,1,'s'),90,0,0,100);

  Create_Segment(Seg_i++,C_Adr(m,4,1),C_AdrT(m,4,1,'S'),C_AdrT(0,0,0,'e'),90,0,0,100);
   Create_Switch(Swi_i++,C_Adr(m,4,1),C_Adr(m,4,1),C_Adr(m,2,2),C_Adr(m,3,2),1);

  join(IN.Adr2,C_Adr(m,5,1));
  Create_Segment(Seg_i++,C_Adr(m,5,1),IN.Adr2,C_AdrT(m,6,1,'S'),90,0,1,100);
   Create_Switch(Swi_i++,C_Adr(m,6,1),C_Adr(m,5,1),C_AdrT(m,6,2,'S'),C_Adr(m,7,1),1);
   Create_Switch(Swi_i++,C_Adr(m,6,2),C_AdrT(m,6,1,'s'),C_Adr(m,8,1),C_Adr(m,9,1),1);

  Create_Segment(Seg_i++,C_Adr(m,7,1),C_AdrT(m,6,1,'s'),C_Adr(m,7,2),90,0,1,100);
  Create_Segment(Seg_i++,C_Adr(m,7,2),C_Adr(m,7,1),C_AdrT(m,10,1,'s'),90,0,1,100);

  Create_Segment(Seg_i++,C_Adr(m,8,1),C_AdrT(m,6,2,'s'),C_Adr(m,8,2),90,0,1,100);
  Create_Segment(Seg_i++,C_Adr(m,8,2),C_Adr(m,8,1),C_AdrT(m,10,2,'s'),90,0,1,100);

  Create_Segment(Seg_i++,C_Adr(m,9,1),C_AdrT(m,6,2,'s'),C_Adr(m,9,2),90,0,1,100);
  Create_Segment(Seg_i++,C_Adr(m,9,2),C_Adr(m,9,1),C_AdrT(m,10,2,'s'),90,0,1,100);

   Create_Switch(Swi_i++,C_Adr(m,10,1),C_Adr(m,11,1),C_AdrT(m,10,2,'S'),C_Adr(m,7,2),1);
   Create_Switch(Swi_i++,C_Adr(m,10,2),C_AdrT(m,10,1,'s'),C_Adr(m,8,2),C_Adr(m,9,2),1);
  Create_Segment(Seg_i++,C_Adr(m,11,1),C_AdrT(m,10,1,'S'),C_AdrT(0,0,0,'e'),90,0,1,100);

  blocks[m][6][0]->dir = 1;
  blocks[m][10][0]->dir = 1;

  link.Adr1 = C_Adr(m,4,1);
  link.Adr2 = C_Adr(m,11,1);
 }
 else if(m == 4){
  Create_Unit(m);
  join(IN.Adr1,C_Adr(m,1,1));
  Create_Segment(00,C_Adr(m,1,1),IN.Adr1,C_AdrT(m,2,1,'S'),140,0,0,100);

  C_Seg(01,C_Adr(m,2,0),0);
   Create_Switch(00,C_Adr(m,2,1),C_Adr(m,1,1),C_AdrT(m,8,1,'s'),C_AdrT(m,2,2,'S'),0);
    Create_Switch(02,C_Adr(m,2,2),C_AdrT(m,2,1,'s'),C_Adr(m,3,1),C_Adr(m,4,1),1);

  Create_Segment(010,C_Adr(m,3,1),C_AdrT(m,2,2,'s'),C_Adr(m,3,2),90,0,0,50);
  Create_Segment(011,C_Adr(m,3,2),C_Adr(m,3,1),C_Adr(m,3,3),90,0,0,50);
  Create_Segment(030,C_Adr(m,3,3),C_Adr(m,3,2),C_Adr(m,3,4),90,0,0,50);
  Create_Segment(031,C_Adr(m,3,4),C_Adr(m,3,3),C_AdrT(m,5,2,'s'),90,0,0,50);

  Create_Segment(012,C_Adr(m,4,1),C_AdrT(m,2,2,'s'),C_Adr(m,4,2),140,0,0,50);
  Create_Segment(013,C_Adr(m,4,2),C_Adr(m,4,1),C_Adr(m,4,3),140,0,0,50);
  Create_Segment(032,C_Adr(m,4,3),C_Adr(m,4,2),C_Adr(m,4,4),140,0,0,50);
  Create_Segment(033,C_Adr(m,4,4),C_Adr(m,4,3),C_AdrT(m,5,2,'s'),140,0,0,50);


  C_Seg(051,C_Adr(m,5,0),0);
   Create_Switch(012,C_Adr(m,5,1),C_Adr(m,6,1),C_AdrT(m,12,1,'s'),C_AdrT(m,5,2,'S'),0);
   Create_Switch(010,C_Adr(m,5,2),C_AdrT(m,5,1,'s'),C_Adr(m,3,4),C_Adr(m,4,4),1);

  Create_Segment(050,C_Adr(m,6,1),C_AdrT(m,5,1,'S'),C_AdrT(0,0,0,'e'),140,0,0,100);

  join(IN.Adr2,C_Adr(m,7,1));
  Create_Segment(02,C_Adr(m,7,1),IN.Adr2,C_AdrT(m,8,1,'s'),140,0,1,50);

  C_Seg(03,C_Adr(m,8,0),0);
   Create_Switch(01,C_Adr(m,8,1),C_AdrT(m,8,2,'S'),C_AdrT(m,2,1,'s'),C_Adr(m,7,1),0);
   Create_Switch(03,C_Adr(m,8,2),C_AdrT(m,8,1,'S'),C_AdrT(m,8,3,'S'),C_Adr(m,9,1),1);
   Create_Switch(04,C_Adr(m,8,3),C_AdrT(m,8,2,'s'),C_Adr(m,10,1),C_Adr(m,11,1),1);

  Create_Segment(014,C_Adr(m,9,1),C_AdrT(m,8,2,'s'),C_Adr(m,9,2),140,0,1,50);
  Create_Segment(015,C_Adr(m,9,2),C_Adr(m,9,1),C_Adr(m,9,3),140,0,1,50);
  Create_Segment(034,C_Adr(m,9,3),C_Adr(m,9,2),C_Adr(m,9,4),140,0,1,50);
  Create_Segment(035,C_Adr(m,9,4),C_Adr(m,9,3),C_AdrT(m,12,2,'s'),140,0,1,50);

  Create_Segment(016,C_Adr(m,10,1),C_AdrT(m,8,3,'s'),C_Adr(m,10,2),90,0,1,50);
  Create_Segment(017,C_Adr(m,10,2),C_Adr(m,10,1),C_Adr(m,10,3),90,0,1,50);
  Create_Segment(036,C_Adr(m,10,3),C_Adr(m,10,2),C_Adr(m,10,4),90,0,1,50);
  Create_Segment(037,C_Adr(m,10,4),C_Adr(m,10,3),C_AdrT(m,12,3,'s'),90,0,1,50);

  Create_Segment(020,C_Adr(m,11,1),C_AdrT(m,8,3,'s'),C_Adr(m,11,2),90,0,1,50);
  Create_Segment(021,C_Adr(m,11,2),C_Adr(m,11,1),C_Adr(m,11,3),90,0,1,50);
  Create_Segment(040,C_Adr(m,11,3),C_Adr(m,11,2),C_Adr(m,11,4),90,0,1,50);
  Create_Segment(041,C_Adr(m,11,4),C_Adr(m,11,3),C_AdrT(m,12,3,'s'),90,0,1,50);

  C_Seg(053,C_Adr(m,12,0),0);
   Create_Switch(011,C_Adr(m,12,1),C_AdrT(m,12,2,'S'),C_AdrT(m,5,1,'s'),C_Adr(m,13,1),0);
   Create_Switch(013,C_Adr(m,12,2),C_AdrT(m,12,1,'S'),C_AdrT(m,12,3,'S'),C_Adr(m,9,4),1);
   Create_Switch(014,C_Adr(m,12,3),C_AdrT(m,12,2,'s'),C_Adr(m,10,4),C_Adr(m,11,4),1);

  Create_Segment(052,C_Adr(m,13,1),C_AdrT(m,12,1,'s'),C_AdrT(0,0,0,'e'),140,0,1,50);


   struct L_Swi_t * B_Swi1 = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));
   struct adr ADR = {m,2,1,'S'};
   B_Swi1->Adr = ADR;
   B_Swi1->states[0] = 0;
   B_Swi1->states[1] = 1;
    Switch[m][5][1]->L_Swi[0] = B_Swi1;
    Switch[m][8][1]->L_Swi[0] = B_Swi1;
   Switch[m][12][1]->L_Swi[0] = B_Swi1;

   struct L_Swi_t * B_Swi2 = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));

   ADR.B = 5;
   B_Swi2->Adr = ADR;
   B_Swi2->states[0] = 0;
   B_Swi2->states[1] = 1;
    Switch[m][2][1]->L_Swi[0] = B_Swi2;
    Switch[m][8][1]->L_Swi[1] = B_Swi2;
   Switch[m][12][1]->L_Swi[1] = B_Swi2;

   struct L_Swi_t * B_Swi3 = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));

    ADR.B = 8;
    B_Swi3->Adr = ADR;
   B_Swi3->states[0] = 0;
   B_Swi3->states[1] = 1;
    Switch[m][2][1]->L_Swi[1] = B_Swi3;
    Switch[m][5][1]->L_Swi[1] = B_Swi3;
   Switch[m][12][1]->L_Swi[2] = B_Swi3;

   struct L_Swi_t * B_Swi4 = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));

    ADR.B = 12;
    B_Swi4->Adr = ADR;
   B_Swi4->states[0] = 0;
   B_Swi4->states[1] = 1;
   Switch[m][2][1]->L_Swi[2] = B_Swi4;
   Switch[m][5][1]->L_Swi[2] = B_Swi4;
   Switch[m][8][1]->L_Swi[2] = B_Swi4;



  struct P_Swi_t * P1 = (struct P_Swi_t *)malloc(sizeof(struct P_Swi_t));
  P1->type = 0;
  P1->state = 0;
  Switch[m][12][1]->pref[0] = P1;
  struct P_Swi_t * P2 = (struct P_Swi_t *)malloc(sizeof(struct P_Swi_t));
  P2->type = 0;
  P2->state = 1;
  Switch[m][8][1]->pref[0] = P2;


   int a;
   a = Create_Station(C_Adr(m,3,0));
   stations[a]->Blocks[0] = blocks[m][3][1];
   stations[a]->Blocks[1] = blocks[m][3][2];
   stations[a]->Blocks[2] = blocks[m][3][3];
   stations[a]->Blocks[3] = blocks[m][3][4];
   stations[a]->type = 1;
   a = Create_Station(C_Adr(m,4,0));
   stations[a]->Blocks[0] = blocks[m][4][1];
   stations[a]->Blocks[1] = blocks[m][4][2];
   stations[a]->Blocks[2] = blocks[m][4][3];
   stations[a]->Blocks[3] = blocks[m][4][4];
   stations[a]->type = 1;
   a = Create_Station(C_Adr(m,9,0));
   stations[a]->Blocks[0] = blocks[m][9][1];
   stations[a]->Blocks[1] = blocks[m][9][2];
   stations[a]->Blocks[2] = blocks[m][9][3];
   stations[a]->Blocks[3] = blocks[m][9][4];
   stations[a]->type = 1;
   a = Create_Station(C_Adr(m,10,0));
   stations[a]->Blocks[0] = blocks[m][10][1];
   stations[a]->Blocks[1] = blocks[m][10][2];
   stations[a]->Blocks[2] = blocks[m][10][3];
   stations[a]->Blocks[3] = blocks[m][10][4];
   stations[a]->type = 1;
   a = Create_Station(C_Adr(m,11,0));
   stations[a]->Blocks[0] = blocks[m][11][1];
   stations[a]->Blocks[1] = blocks[m][11][2];
   stations[a]->Blocks[2] = blocks[m][11][3];
   stations[a]->Blocks[3] = blocks[m][11][4];
   stations[a]->type = 1;




   create_signal(00,blocks[m][3][1],2,0);
   create_signal(01,blocks[m][4][1],2,0);

   create_signal(010,blocks[m][9][4],2,0);
   create_signal(011,blocks[m][10][4],2,0);
   create_signal(012,blocks[m][11][4],2,0);


   create_signal(02,blocks[m][9][1],2,1);
   create_signal(03,blocks[m][10][1],2,1);
   create_signal(04,blocks[m][11][1],2,1);


   blocks[m][1][1]->oneWay = (1==1);
   blocks[m][6][1]->oneWay = (1==1);
   blocks[m][7][1]->oneWay = (1==1);
   blocks[m][13][1]->oneWay = (1==1);


  blocks[m][2][0]->dir = 0;
  blocks[m][5][0]->dir = 0;
  blocks[m][8][0]->dir = 1;
  blocks[m][12][0]->dir = 1;

  link.Adr1 = C_Adr(m,6,1);
  link.Adr2 = C_Adr(m,13,1);
 }
 else if(m == 5){

  Create_Unit(m);

  join(IN.Adr1,C_Adr(m,1,1));
  Create_Segment(Seg_i++,C_Adr(m,1,1),IN.Adr1,C_AdrT(0,0,0,'e'),250,0,0,100);

  C_Seg(Seg_i++,C_Adr(m,2,0),0);
  C_Seg(Seg_i++,C_Adr(m,5,0),0);

  join(IN.Adr2,C_AdrT(m,2,1,'S'));
  Create_Switch(Swi_i++,C_Adr(m,2,1),IN.Adr2,C_Adr(m,3,1),C_AdrT(m,5,1,'s'),1);
  Create_Switch(Swi_i++,C_Adr(m,5,1),C_AdrT(0,0,0,'e'),C_Adr(m,4,1),C_AdrT(m,2,1,'s'),1);

  Create_Segment(Seg_i++,C_Adr(m,3,1),C_AdrT(m,2,1,'s'),C_AdrT(0,0,0,'e'),250,0,1,50);
  Create_Segment(Seg_i++,C_Adr(m,4,1),C_AdrT(m,5,1,'s'),C_AdrT(0,0,0,'e'),250,0,2,50);

  blocks[m][2][0]->dir = 1;
  blocks[m][5][0]->dir = 1;

  link.Adr1 = C_Adr(m,1,1);
  link.Adr2 = C_AdrT(m,5,1,'S');
  link.Adr3 = C_AdrT(m,4,1,'R');
  link.Adr4 = C_AdrT(m,3,1,'R');
 }
 else if(m == 6){
  Create_Unit(m);
  join(IN.Adr1,C_Adr(m,1,1));
  Create_Segment(Seg_i++,C_Adr(m,1,1),IN.Adr1,C_AdrT(m,3,1,'s'),250,0,0,90);

  join(IN.Adr2,C_Adr(m,2,1));
  Create_Segment(Seg_i++,C_Adr(m,2,1),IN.Adr2,C_AdrT(m,3,1,'s'),250,0,1,90);

  C_Seg(Seg_i++,C_Adr(m,3,0),0);

  Create_Switch(Swi_i++,C_Adr(m,3,1),C_AdrT(0,0,0,'e'),C_Adr(m,2,1),C_Adr(m,1,1),1);

  blocks[m][1][1]->oneWay = (1==1);
  blocks[m][2][1]->oneWay = (1==1);

  link.Adr1 = C_AdrT(m,3,1,'S');
  link.Adr2 = C_AdrT(0,0,0,'e');
 }
 else if(m == 7){
  Create_Unit(m);

  C_Seg(Seg_i++,C_Adr(m,1,0),0);

  Create_Switch(Swi_i++,C_Adr(m,1,1),C_AdrT(m,1,2,'s'),C_Adr(m,3,1),C_Adr(m,2,1),1);
  Create_Switch(Swi_i++,C_Adr(m,1,2),C_AdrT(m,1,3,'m'),C_Adr(m,4,1),C_AdrT(m,1,1,'S'),1);

  join(IN.Adr1,C_AdrT(m,1,3,'M'));
  struct adr A[10] = {{m,1,2,'S'},{m,5,1,'R'},{m,1,4,'S'},C_AdrT(0,0,0,'e')};
  struct adr B[10] = {link.Adr1,link.Adr1,link.Adr1,C_AdrT(0,0,0,'e')};
  Create_Moduls(Swi_i++,C_Adr(m,1,3),A,B,3);



  Create_Switch(Swi_i++,C_Adr(m,1,4),C_AdrT(m,1,3,'m'),C_Adr(m,6,1),C_AdrT(m,1,5,'S'),1);
  Create_Switch(Swi_i++,C_Adr(m,1,5),C_AdrT(m,1,4,'s'),C_Adr(m,7,1),C_Adr(m,8,1),1);

  Create_Segment(Seg_i++,C_Adr(m,2,1),C_AdrT(m,1,1,'s'),C_Adr(m,2,2),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,2,2),C_Adr(m,2,1),C_Adr(m,2,3),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,2,3),C_Adr(m,2,2),C_Adr(m,2,4),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,2,4),C_Adr(m,2,3),C_Adr(m,2,5),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,2,5),C_Adr(m,2,4),C_Adr(m,2,6),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,2,6),C_Adr(m,2,5),C_AdrT(0,0,0,'e'),250,0,0,50);

  Create_Segment(Seg_i++,C_Adr(m,3,1),C_AdrT(m,1,1,'s'),C_Adr(m,3,2),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,3,2),C_Adr(m,3,1),C_Adr(m,3,3),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,3,3),C_Adr(m,3,2),C_Adr(m,3,4),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,3,4),C_Adr(m,3,3),C_Adr(m,3,5),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,3,5),C_Adr(m,3,4),C_Adr(m,3,6),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,3,6),C_Adr(m,3,5),C_AdrT(0,0,0,'e'),250,0,0,50);

  Create_Segment(Seg_i++,C_Adr(m,4,1),C_AdrT(m,1,2,'s'),C_Adr(m,4,2),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,4,2),C_Adr(m,4,1),C_Adr(m,4,3),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,4,3),C_Adr(m,4,2),C_Adr(m,4,4),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,4,4),C_Adr(m,4,3),C_Adr(m,4,5),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,4,5),C_Adr(m,4,4),C_Adr(m,4,6),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,4,6),C_Adr(m,4,5),C_AdrT(0,0,0,'e'),250,0,0,50);

  Create_Segment(Seg_i++,C_Adr(m,5,1),C_AdrT(m,1,3,'m'),C_Adr(m,5,2),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,5,2),C_Adr(m,5,1),C_Adr(m,5,3),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,5,3),C_Adr(m,5,2),C_Adr(m,5,4),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,5,4),C_Adr(m,5,3),C_Adr(m,5,5),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,5,5),C_Adr(m,5,4),C_Adr(m,5,6),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,5,6),C_Adr(m,5,5),C_AdrT(0,0,0,'e'),250,0,0,50);

  Create_Segment(Seg_i++,C_Adr(m,6,1),C_AdrT(m,1,4,'s'),C_Adr(m,6,2),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,6,2),C_Adr(m,6,1),C_Adr(m,6,3),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,6,3),C_Adr(m,6,2),C_Adr(m,6,4),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,6,4),C_Adr(m,6,3),C_Adr(m,6,5),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,6,5),C_Adr(m,6,4),C_Adr(m,6,6),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,6,6),C_Adr(m,6,5),C_AdrT(0,0,0,'e'),250,0,0,50);

  Create_Segment(Seg_i++,C_Adr(m,7,1),C_AdrT(m,1,5,'s'),C_Adr(m,7,2),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,7,2),C_Adr(m,7,1),C_Adr(m,7,3),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,7,3),C_Adr(m,7,2),C_Adr(m,7,4),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,7,4),C_Adr(m,7,3),C_Adr(m,7,5),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,7,5),C_Adr(m,7,4),C_Adr(m,7,6),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,7,6),C_Adr(m,7,5),C_AdrT(0,0,0,'e'),250,0,0,50);

  Create_Segment(Seg_i++,C_Adr(m,8,1),C_AdrT(m,1,5,'s'),C_Adr(m,8,2),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,8,2),C_Adr(m,8,1),C_Adr(m,8,3),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,8,3),C_Adr(m,8,2),C_Adr(m,8,4),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,8,4),C_Adr(m,8,3),C_Adr(m,8,5),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,8,5),C_Adr(m,8,4),C_Adr(m,8,6),250,0,0,50);
  Create_Segment(Seg_i++,C_Adr(m,8,6),C_Adr(m,8,5),C_AdrT(0,0,0,'e'),250,0,0,50);

  link.Adr1 = C_AdrT(0,0,0,'e');
  link.Adr2 = C_AdrT(0,0,0,'e');
 }
 else if(m == 8 || m == 9 || m == 10 || m == 12 || m == 13 || m == 14){
  Create_Unit(m);
  join(IN.Adr1,C_Adr(m,1,1));
  Create_Segment(00,C_Adr(m,1,1),IN.Adr1,C_Adr(m,2,1),250,0,0,100);
  Create_Segment(010,C_Adr(m,2,1),C_Adr(m,1,1),C_Adr(m,3,1),250,0,0,100);
  Create_Segment(020,C_Adr(m,3,1),C_Adr(m,2,1),C_Adr(m,4,1),250,0,0,100);
  Create_Segment(030,C_Adr(m,4,1),C_Adr(m,3,1),C_AdrT(0,0,0,'e'),250,0,0,100);

  join(IN.Adr2,C_Adr(m,5,1));
  Create_Segment(01,C_Adr(m,5,1),IN.Adr2,C_Adr(m,6,1),250,0,1,100);
  Create_Segment(011,C_Adr(m,6,1),C_Adr(m,5,1),C_Adr(m,7,1),250,0,1,100);
  Create_Segment(021,C_Adr(m,7,1),C_Adr(m,6,1),C_Adr(m,8,1),250,0,1,100);
  Create_Segment(031,C_Adr(m,8,1),C_Adr(m,7,1),C_AdrT(0,0,0,'e'),250,0,1,100);



  link.Adr1 = C_Adr(m,4,1);
  link.Adr2 = C_Adr(m,8,1);
 }
 else if(m == 11){
  Create_Unit(m);
  join(IN.Adr1,C_Adr(m,1,1));
  Create_Segment(Seg_i++,C_Adr(m,1,1),IN.Adr1,C_AdrT(0,0,0,'e'),250,0,0,100);

  join(IN.Adr2,C_Adr(m,2,1));
  Create_Segment(Seg_i++,C_Adr(m,2,1),IN.Adr2,C_AdrT(0,0,0,'e'),250,0,1,100);



  link.Adr1 = C_Adr(m,1,1);
  link.Adr2 = C_Adr(m,2,1);
 }

 return link;
}
# 191 "baan.c" 2
# 1 "./src/pathfinding.h" 1
struct Sw_A_PATH {
 struct adr adr;
 char length;
 signed char suc[10];
 int state[10];
 int dir;
 struct Sw_A_PATH * Prev;
 struct Sw_A_PATH * Next[20];
};

struct Sw_PATH {
 struct adr adr;
 signed char suc[10];
};

int pathFinding(struct adr Begin, struct adr End, struct Sw_PATH * OUT_Sw_Nodes[200]);
# 192 "baan.c" 2

# 1 "./src/Z21.h" 1
# 10 "./src/Z21.h"
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 30 "/usr/include/arpa/inet.h" 3 4




extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));






extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 11 "./src/Z21.h" 2
# 28 "./src/Z21.h"
void die(char *s);

void Z21_recv(char message[100]);

struct sockaddr_in si_other;
int fd_Z21_server, slen=sizeof(si_other);

void Z21_client();

char Z21_prio_list[05][30] = {{""}};
char Z21_send_list[10][30] = {{""}};

void Z21_recv(char message[100]);

void Z21_send(int Header,char data[30]);

void Z21_GET_LOCO_INFO(int DCC_Adr);

void Z21_SET_LOCO_DRIVE(int DCC_Adr,char steps,_Bool dir,char drive);

void Z21_SET_LOCO_FUNCTION(int DCC_Adr,char function_nr,char switch_type);
# 194 "baan.c" 2

struct Seg * C_Seg(int Unit_Adr, struct adr Adr, char state){
 struct Seg *Z = (struct Seg*)malloc(sizeof(struct Seg));

 Z->Adr = Adr;
 Z->NAdr = C_AdrT(0,0,0,'e');
 Z->PAdr = C_AdrT(0,0,0,'e');
 Z->max_speed = 0;
 Z->state = state;
 Z->train = 0x00;


 blocks[Adr.M][Adr.B][Adr.S] = Z;

 if(!(Adr.M == 0 && Adr.B == 0 && Adr.S == 0)){

  if(Units[Adr.M]->B[Unit_Adr] == ((void *)0)){
   Units[Adr.M]->B[Unit_Adr] = Z;
  }else{
   printf("Double Block adress %i in Module %i\n",Unit_Adr,Adr.M);
  }

  Block_list[B_list_i] = Adr;
  B_list_i++;
 }else{

 }

 return Z;
}

void Create_Segment(int Unit_Adr, struct adr Adr,struct adr NAdr,struct adr PAdr,char max_speed,char state,char dir,char len){
 struct Seg *Z = (struct Seg*)malloc(sizeof(struct Seg));

 Z->Adr = Adr;
 Z->NAdr = NAdr;
 Z->PAdr = PAdr;
 Z->max_speed = max_speed;
 Z->state = state;
 Z->dir = dir;
 Z->length = len;
 Z->change = 0;
 Z->train = 0x00;
 Z->oneWay = (!(1==1));


 blocks[Adr.M][Adr.B][Adr.S] = Z;


 if(Units[Adr.M]->B[Unit_Adr] == ((void *)0)){
  Units[Adr.M]->B[Unit_Adr] = Z;
 }else{
  printf("Double Block adress %i in Module %i (%i:%i)\n",Unit_Adr,Adr.M,Adr.B,Adr.S);
 }


 Block_list[B_list_i] = Adr;
 B_list_i++;
}

int Create_Station(struct adr Adr){
 struct Station * Z = (struct Station*)malloc(sizeof(struct Station));

 Z->Adr = Adr;

 stations[St_list_i++] = Z;
 printf("Station for %i:%i\n",Adr.M,Adr.B);

 return St_list_i - 1;
}

int Adr_Comp(struct adr A,struct adr B){
 if(A.M == B.M && A.B == B.B && A.S == B.S){
  return 1;
 }else{
  return 0;
 }
}

int dir_Comp(struct Seg *A,struct Seg *B){
 if((A->dir == 2 && (B->dir == 1 || B->dir == 0)) || ((A->dir == 1 || A->dir == 0) && B->dir == 2)){
  return 1;
 }else if(A->dir == B->dir){
  return 1;
 }else if(((A->dir == 0 || A->dir == 2) && B->dir == 0b101) || (A->dir == 1 && B->dir == 0b100)){
  return 1;
 }else if(((B->dir == 0 || B->dir == 2) && A->dir == 0b101) || (B->dir == 1 && A->dir == 0b100)){
  return 1;
 }else if(B->Adr.S == 0){
  return 1;
 }else{
  return 0;
 }
# 295 "baan.c"
}

void setup_JSON(int arr[], int arr2[], int size, int size2){
 char buf[100];

 setup_data[0] = 2;
 setup_data_l = 2 + size + size2;

 int i = 2;

 for(i;(i-2)<size;i++){
  setup_data[i] = arr[i-2];
 }

 if(size2 != 0){
  setup_data[1] = size;

  for(i;(i-2-size)<size2;i++){
   setup_data[i] = arr2[i-2-size];
  }
 }
}

struct adr NADR(struct adr Adr){
 struct adr NAdr;
 int dir = blocks[Adr.M][Adr.B][Adr.S]->dir;

 if(dir == 0 || dir == 2 || dir == 0b101){
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
 }else{
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
 }
 return NAdr;
}

struct adr PADR(struct adr Adr){
 struct adr PAdr;
 int dir = blocks[Adr.M][Adr.B][Adr.S]->dir;

 if(dir == 0 || dir == 2){
  PAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
 }else{
  PAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
 }
 return PAdr;
}

struct Seg * Next(struct adr Adr,int i){
 struct adr NAdr,SNAdr;
 int Search_len = i;
 int a = 0;

 int direct = blocks[Adr.M][Adr.B][Adr.S]->dir;
 I:{};
 int dir = blocks[Adr.M][Adr.B][Adr.S]->dir;

 if(direct == 0 || direct == 2 || direct == 5){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
  }else{
   NAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
  }
 }else{
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
  }else{
   NAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
  }
 }

 J:{};

 if(i <= 0){


  return blocks[Adr.M][Adr.B][Adr.S];
 }



 if(NAdr.type == 'R'){
  i--;
  Adr = NAdr;
  goto I;
 }else if(NAdr.type == 'e'){
  return blocks[0][0][0];

 }else if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'm' || NAdr.type == 'M'){
  R:{};

  if(i == 1 && blocks[NAdr.M][NAdr.B][0] != ((void *)0)){
   i--;
   Adr = C_Adr(NAdr.M,NAdr.B,0);
   goto J;
  }
  if(blocks[NAdr.M][NAdr.B][0] != ((void *)0)){
   a++;
  }
  if(NAdr.type == 'S'){
   if(Switch[NAdr.M][NAdr.B][NAdr.S]->state == 0){
    SNAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->Str;
   }else{
    SNAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->Div;
   }
  }
  else if(NAdr.type == 's'){
   SNAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->App;
  }
  else if(NAdr.type == 'M'){

   int s = Moduls[NAdr.M][NAdr.B][NAdr.S]->state;
   SNAdr = Moduls[NAdr.M][NAdr.B][NAdr.S]->mAdr[s];

  }
  else if(NAdr.type == 'm'){

   int s = Moduls[NAdr.M][NAdr.B][NAdr.S]->state;
   SNAdr = Moduls[NAdr.M][NAdr.B][NAdr.S]->MAdr[s];

  }

  if(SNAdr.type == 'S' || SNAdr.type == 's' || SNAdr.type == 'M' || SNAdr.type == 'm'){
   if(SNAdr.B != NAdr.B){
    i--;
   }
   NAdr = SNAdr;
   goto R;
  }else{
   Adr = SNAdr;
   NAdr = Adr;


   i--;
   if(a>0){
    i--;
   }
   goto I;
  }
 }
 return blocks[Adr.M][Adr.B][Adr.S];
}

struct Seg * Prev(struct adr Adr,int i){
 struct adr PAdr,SPAdr;
 int a = 0;

 int direct = blocks[Adr.M][Adr.B][Adr.S]->dir;
 I:{};
 int dir = blocks[Adr.M][Adr.B][Adr.S]->dir;

 if(direct == 0 || direct == 2 || direct == 5){
  if(dir == 0 || dir == 2 || dir == 5){
   PAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
  }else{
   PAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
  }
 }else{
  if(dir == 0 || dir == 2 || dir == 5){
   PAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
  }else{
   PAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
  }
 }

 J:{};

 if(i <= 0){


  return blocks[Adr.M][Adr.B][Adr.S];
 }



 if(PAdr.type == 'R'){
  i--;
  Adr = PAdr;
  goto I;
 }else if(PAdr.type == 'e'){
  return blocks[0][0][0];

 }else if(PAdr.type == 'S' || PAdr.type == 's' || PAdr.type == 'm' || PAdr.type == 'M'){
  R:{};

  if(i == 1 && blocks[PAdr.M][PAdr.B][0] != ((void *)0)){
   i--;
   Adr = C_Adr(PAdr.M,PAdr.B,0);
   goto J;
  }
  if(blocks[PAdr.M][PAdr.B][0] != ((void *)0)){
   a++;
  }
  if(PAdr.type == 'S'){
   if(Switch[PAdr.M][PAdr.B][PAdr.S]->state == 0){
    SPAdr = Switch[PAdr.M][PAdr.B][PAdr.S]->Str;
   }else{
    SPAdr = Switch[PAdr.M][PAdr.B][PAdr.S]->Div;
   }
  }
  else if(PAdr.type == 's'){
   SPAdr = Switch[PAdr.M][PAdr.B][PAdr.S]->App;
  }
  else if(PAdr.type == 'M'){

   int s = Moduls[PAdr.M][PAdr.B][PAdr.S]->state;
   SPAdr = Moduls[PAdr.M][PAdr.B][PAdr.S]->mAdr[s];

  }
  else if(PAdr.type == 'm'){

   int s = Moduls[PAdr.M][PAdr.B][PAdr.S]->state;
   SPAdr = Moduls[PAdr.M][PAdr.B][PAdr.S]->MAdr[s];

  }

  if(SPAdr.type == 'S' || SPAdr.type == 's' || SPAdr.type == 'M' || SPAdr.type == 'm'){
   if(SPAdr.B != PAdr.B && blocks[Adr.M][Adr.B][0] != ((void *)0)){
    i--;
   }
   PAdr = SPAdr;
   goto R;
  }else{
   Adr = SPAdr;
   PAdr = Adr;


   i--;
   if(a>0){
    i--;
   }
   goto I;
  }
 }
 return blocks[Adr.M][Adr.B][Adr.S];
}

void change_block_state(struct Seg * Block,int State){
 if(Block->state != State){
  Block->change = 1;
  Block->state = State;
 }
}

void JSON_new_client(int Client_fd);

struct timer_thread_data{
   int thread_id;
  int t;
};

struct timer_thread_data a[5];

# 1 "./src/status.c" 1
# 19 "./src/status.c"
void Web_Emergency_Stop(int i){
  char data[5];
  data[0] = 1;
  if(i == 0){
    data[1] = 1;
  }else if(i == 1){
    data[1] = 2;
  }else{
    return;
  }
  printf("Emergency_Stop (%i):[%i][%i]",i,data[0],data[1]);

  send_all(data,2,1);
}

void Web_Electrical_Stop(int i){
  char data[5];
  data[0] = 1;
  if(i == 0){
    data[1] = 3;
  }else if(i == 1){
    data[1] = 4;
  }else{
    return;
  }
  send_all(data,2,1);
}

void Web_Train_Split(int i,char tID,struct adr A){
  printf("\n\nWeb_Train_Split(%i,%i,{%i,%i,%i,%c});\n\n",i,tID,A.M,A.B,A.S,A.type);
  char data[8];
  data[0] = 1;
  if(i == 0){
    data[1] = 5;
    data[2] = tID;
    data[3] = A.M;
    data[4] = A.B;
    data[5] = A.S;
    send_all(data,6,1);
  }else if(i == 1){
    data[1] = 6;
    data[2] = tID;
    send_all(data,3,1);
  }else{
    return;
  }
}

void Web_Link_Train(int i,char nr,struct adr A){
  printf("\n\nWeb_Req_Train(%i,%i,{%i,%i,%i,%c});\n\n",i,nr,A.M,A.B,A.S,A.type);
  char data[8];
  data[0] = 1;
  if(i == 0){
    data[1] = 11;
  }else if(i == 1){
    data[1] = 12;
  }else{
    return;
  }
  data[2] = nr;
  data[3] = A.M;
  data[4] = A.B;
  data[5] = A.S;
  send_all(data,6,1);
}

void Web_Train_Data(char data[14]){
  printf("\n\nWeb_Train_Data;\n\n");
  char s_data[20];
  s_data[0] = 7;

  for(int i = 0;i<14;i++){
    s_data[i+1] = data[i];
  }

  send_all(s_data,15,1);
}
# 548 "baan.c" 2
# 1 "./src/trains.c" 1
struct train{
 int DCC_ID;
 char type;
 char name[21];
 char cur_speed;
 long max_speed;
 char accelerate_speed;
 char break_speed;
 char use;
 _Bool control;
 _Bool halt;
 struct Sw_PATH * Route[200];
 struct adr Destination;
 char timer;
 int timer_id;
};

struct train *trains[30] = {};
struct train *train_link[30];
int iTrain = 0;
int bTrain = 0;

int add_train(int DCC,int speed,char name[],char type){
 struct train *Z = (struct train*)malloc(sizeof(struct train));

 struct adr Route[20] = {{0,0,0,0}};

 Z->DCC_ID = DCC;
 Z->type = type;
 strcpy(Z->name,name);
 Z->max_speed = speed;
 Z->accelerate_speed = 60;
 Z->break_speed = 50;
 Z->cur_speed = 100;
 Z->control = 0;
 Z->use = 0;
 Z->halt = (!(1==1));


 trains[iTrain++] = Z;
 return (iTrain - 1);
}

void req_train(char ID, struct adr Adr){
 Web_Link_Train(0,ID,Adr);
}

int create_train(int DCC,int speed,char name[],char type){
 printf("Create train, %i trains in library\n",iTrain);
 for(int i = 0;i<iTrain;i++){
  printf("Train[%i]\n",i);
  if(trains[i]->DCC_ID == DCC){
   printf("Address already in use");
   return -1;
  }
 }
 printf("Open file\n");
 FILE * f;
 f = fopen("./trains/trainlist_raw.txt","a");
 printf("write to file\n");
 fprintf(f,"%s\t%i\t%c\t%i\r\n",name,DCC,type,speed);
 fclose(f);
 printf("Add train\n");


 return add_train(DCC,speed,name,type);
}

void init_trains(){
 FILE *f;
 f = fopen("./trains/trainlist_raw.txt","r");
 char line[256] = "";
 int line_nr = 0;
 int nr_trains = 0;

 while (fgets(line, sizeof(line), f)) {


  char *D1 = strchr(line, '\t');
  char *D2 = strchr(&line[(D1-line)+1], '\t');
  char *D3 = strchr(&line[(D2-line)+1], '\t');
  char *D4 = strchr(&line[(D3-line)+1], '\t');
  char *D5 = strchr(&line[(D3-line)+1], '\r');
  if (D1 && D2 && D3 && D4 && D5){ ;
   int start = 0;
   int tab1 = D1-line;
   int tab2 = D2-line;
   int tab3 = D3-line;
   int tab4 = D4-line;
   int end = D5-line;

   char L1[21],L2[7],L3[5],L4[5],L5[30];

   memset(L1,0,21);
   memset(L2,0,7);
   memset(L3,0,5);
   memset(L4,0,5);
   memset(L5,0,30);

   for(int i = (start);i<=end;i++){
    if(i < tab1){
     L1[(i-start)] = line[i];
    }else if(i > tab1 && i < tab2){
     L2[(i-tab1-1)] = line[i];
    }else if(i > tab2 && i < tab3){
     L3[(i-tab2-1)] = line[i];
    }else if(i > tab3 && i < tab4){
     L4[(i-tab3-1)] = line[i];
    }else if(i > tab4 && i < end){
     L5[(i-tab4-1)] = line[i];
    }
    if(i == tab1){
     L1[(i-start)] = 0;
    }else if(i == tab2){
     L2[(i-tab1-1)] = 0;
    }else if(i == tab3){
     L3[(i-tab2-1)] = 0;
    }else if(i == tab4){
     L4[(i-tab3-1)] = 0;
    }else if(i == end){
     L5[(i-tab4-1)] = 0;
    }
   }


   if(line_nr != 0){
    if(atoi(L2) < 10000){
     add_train(atoi(L2),atoi(L4),L1,L3[0]);
     nr_trains++;
    }
   }
  }else{
   printf("Corrupt trainlist file!!!!!!!\n");
  }
  line_nr++;
 }
 fclose(f);

 printf("|                           %i\ttrains found                               |\n",nr_trains);
 printf("|                                                                          |\n");

 for(int i = 0;i<nr_trains;i++){
  char buf[40] = "|                    ";
  sprintf(buf,"%s(%i) #%04i  %s",buf,i,trains[i]->DCC_ID,trains[i]->name);
  printf("%s",buf);
  for(int j = strlen(buf);j<75;j++)
   printf(" ");
  printf("|\n");
 }

 printf("|                                                                          |\n");
}

int link_train(char link,int train){
 if(train_link[link] == ((void *)0) && trains[train]->use == 0){
  printf("link is empty %i\n",train_link[link]);
  train_link[link] = trains[train];
  if(train != 0 || train != 1){
   train_link[link]->use = 1;
  }else{
   printf("Duplicates allowed");
  }
  printf("Set to %i\n",train_link[link]);
  return 1;
 }else{
  return 0;
 }
}

void unlink_train(char link){
 train_link[link]->use = 0;
 train_link[link] = ((void *)0);
}

struct train_timer_th_data{
   int thread_id;
  int Flag;
  int speed;
  struct train * T;
  struct Seg * B;
};

void *train_timer(void *threadArg){
 struct train_timer_th_data *my_data;
 my_data = (struct train_timer_th_data *) threadArg;
 int id = my_data->thread_id;
 struct train * T = my_data->T;
 struct Seg * B = my_data->B;
 int des_s = my_data->speed;

 free(threadArg);



 float d = (float)B->length/100 * 160;

 int cur_s = T->cur_speed;
 int max_s = T->max_speed;

 float speed_step = (float)max_s/128;

 if(des_s/speed_step > 128){
  des_s = max_s;
 }

 if((int)((float)cur_s/speed_step+0.5) == (int)((float)des_s/speed_step+0.5)){
  return;
 }

 float total_time = (((float)d)/(cur_s))*3.6;


 printf("Train name: %s\t",T->name);
 int step_dif = (int)((float)des_s/speed_step+0.5) - (int)((float)cur_s/speed_step+0.5);
 printf("Length: %f\tstep: %i->%i, d%i\t",d,(int)((float)cur_s/speed_step+0.5),(int)((float)des_s/speed_step+0.5),step_dif);
 int time_step = (int)(((float)total_time/step_dif)*1000000);
 if(time_step < 0){
  time_step = -1*time_step;
 }
 printf("Time %f\tTime step: %i\n",total_time,time_step);

 printf("Max_speed: %i\tCur_speed: %i\tDes_speed: %i\n",max_s,cur_s,des_s);

 if(step_dif>0){
  for(int i = 0;i<=step_dif;i++){
   T->cur_speed++;
   T->cur_speed++;
   printf("++");
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
  }
 }else{
  for(int i = 0;i<=(-step_dif);i++){
   T->cur_speed--;
   T->cur_speed--;
   printf("--");
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
  }
 }
 T->cur_speed = des_s;
 timers[id] = 2;
 T->timer = 0;
 T->timer_id = 0;
 printf("%i done\tCurrent speed %i\n",id,T->cur_speed);

 END:{}
}

void train_speed(struct Seg * B,struct train * T,char speed){
 if(T == ((void *)0)){
  return;
 }
 printf("\t#%i\t%s\n",T->DCC_ID,T->name);

 if(T->timer == 2){
  printf("TIMER ALLREADY STARTED\n");
 }else{

  int des_s = speed;

  struct train_timer_th_data * thread_data = (struct train_timer_th_data*)malloc(sizeof(struct train_timer_th_data));

  int i = 0;
  while(1){
   if(timers[i] == 0){
    timers[i] = 1;
    T->timer_id = i;
    T->timer = 2;

    thread_data->thread_id = i;
    thread_data->T = T;
    thread_data->B = B;
    thread_data->Flag = 1;
    thread_data->speed = des_s;

    pthread_create(&timer_thread[i], ((void *)0), train_timer, (void *) thread_data);
    break;
   }
   i++;
   if(i==5){
    COM_set_train_speed(T,des_s);
   }
  }
 }
}

void train_stop(struct train * T){
 printf("KILL TRAIN:\t#%i\t%s\n",T->DCC_ID,T->name);
}

void train_signal(struct Seg * B,struct train * T,int type){
 if(T == ((void *)0)){
  return;
 }
 printf("\t#%i\t%s\n",T->DCC_ID,T->name);

 if(T->timer == 1){
  printf("TIMER ALLREADY STARTED\n");
 }else{

  int des_s;
  if(type == 1){
   des_s = 40;
  }else{
   des_s = 0;
  }

  struct train_timer_th_data * thread_data = (struct train_timer_th_data*)malloc(sizeof(struct train_timer_th_data));

  int i = 0;
  while(1){
   if(timers[i] == 0){
    timers[i] = 1;
    T->timer = 1;
    T->timer_id = i;
    thread_data->thread_id = i;
    thread_data->T = T;
    thread_data->B = B;
    thread_data->Flag = 2;
    thread_data->speed = des_s;

    pthread_create(&timer_thread[i], ((void *)0), train_timer, (void *) thread_data);
    break;
   }
   i++;
   if(i==5){
    COM_set_train_speed(T,des_s);
   }
  }
 }
}

void train_block_timer();

void train_set_path(struct train * T,struct adr A, struct adr B){
 if(pathFinding(A,B,T->Route)){
  T->halt = 0;
  T->Destination = B;
 }
}
# 549 "baan.c" 2
# 1 "./src/train_sim.c" 1

void *TRAIN_SIMA(){
 struct Seg *B = blocks[8][3][1];
 struct Seg *N = blocks[8][3][1];
 struct Seg *A = blocks[0][0][0];
 int i = 0;
 pthread_mutex_lock(&mutex_lockA);

 while(!stop){

  N = Next(B->Adr,1+i);
  if(i > 0){
   A = Next(B->Adr,i);
  }
  if(N->Adr.type == 'e'){
   while(1){
    usleep(100000);
   }
  }

  N->change = 1;
  N->blocked = 1;
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayA/2);
  pthread_mutex_lock(&mutex_lockA);
  if(i>0){
   A->change = 1;
   A->blocked = 0;
  }else{
   B->change = 1;
   B->blocked = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayA/2);
  pthread_mutex_lock(&mutex_lockA);
  if(N->Adr.S == 0){
   i++;
  }else{
   B = N;
   i = 0;
  }
 }
}

void *TRAIN_SIMB(){
 struct Seg *B2 = blocks[4][11][2];
 struct Seg *N2 = blocks[4][11][2];
 struct Seg *A2[3] = {blocks[0][0][0],blocks[0][0][0],blocks[0][0][0]};
 int i2 = 0;

 B2->blocked = 1;
 B2->change = 1;

 while(blocks[4][11][2]->train == 0){}

 while(!train_link[blocks[4][11][2]->train]){}

 train_link[blocks[4][11][2]->train]->halt = 1;

 while(train_link[blocks[4][11][2]->train]->halt == 1){}

 pthread_mutex_lock(&mutex_lockA);

 while(!stop){

  N2 = Next(B2->Adr,1+i2);
  if(i2 > 0){
   A2[i2] = Next(B2->Adr,i2);
  }
  if(N2->Adr.type == 'e'){
   while(1){
    usleep(100000);
   }
  }

  N2->change = 1;
  N2->blocked = 1;
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayB/2);
  pthread_mutex_lock(&mutex_lockA);
  if(i2>0){
   A2[i2]->change = 1;
   A2[i2]->blocked = 0;
  }else{
   B2->change = 1;
   B2->blocked = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayB/2);
  pthread_mutex_lock(&mutex_lockA);
  if(N2->Adr.S == 0){
   i2++;
  }else{
   B2 = N2;
   i2 = 0;
  }
 }
}

void *TRAIN_SIMC(){
 struct Seg *B2 = blocks[7][3][5];
 struct Seg *N2 = blocks[7][3][5];
 struct Seg *A2[3] = {blocks[0][0][0],blocks[0][0][0],blocks[0][0][0]};
 int i2 = 0;
 pthread_mutex_lock(&mutex_lockA);

 while(!stop){

  N2 = Next(B2->Adr,1+i2);
  if(i2 > 0){
   A2[i2] = Next(B2->Adr,i2);
  }
  if(N2->Adr.type == 'e'){
   while(1){
    usleep(100000);
   }
  }

  N2->change = 1;
  N2->blocked = 1;
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayB/2);
  pthread_mutex_lock(&mutex_lockA);
  if(i2>0){
   A2[i2]->change = 1;
   A2[i2]->blocked = 0;
  }else{
   B2->change = 1;
   B2->blocked = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayB/2);
  pthread_mutex_lock(&mutex_lockA);
  if(N2->Adr.S == 0){
   i2++;
  }else{
   B2 = N2;
   i2 = 0;
  }
 }
}

void *TRAIN_SIMD(){
 struct Seg *B2 = blocks[7][2][5];
 struct Seg *N2 = blocks[7][2][5];
 struct Seg *A2[3] = {blocks[0][0][0],blocks[0][0][0],blocks[0][0][0]};
 int i2 = 0;
 pthread_mutex_lock(&mutex_lockA);

 while(!stop){

  N2 = Next(B2->Adr,1+i2);
  if(i2 > 0){
   A2[i2] = Next(B2->Adr,i2);
  }
  if(N2->Adr.type == 'e'){
   while(1){
    usleep(100000);
   }
  }

  N2->change = 1;
  N2->blocked = 1;
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayB/2);
  pthread_mutex_lock(&mutex_lockA);
  if(i2>0){
   A2[i2]->change = 1;
   A2[i2]->blocked = 0;
  }else{
   B2->change = 1;
   B2->blocked = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayB/2);
  pthread_mutex_lock(&mutex_lockA);
  if(N2->Adr.S == 0){
   i2++;
  }else{
   B2 = N2;
   i2 = 0;
  }
 }
}
# 550 "baan.c" 2
# 1 "./src/Web.c" 1
char websocket_magic_string[] = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

pthread_t client_threads[5];
pthread_mutex_t mutex_lock_web;

struct client_thread_args{
  int fd_client;
  int thread_id;
};

struct client_thread_args clients_data[5];
struct web_client_t * clients[5];
int fd_client_list[5] = {0};
int connected_clients = 0;

void append_Array(char arr1[],int length1, char arr2[],int length2,char arrout[]){
  int index = 0;
  for(index;index<length1;index++){
    arrout[index] = arr1[index];
  }

  int pos = index;

  for(index;(index-pos)<length2;index++){
    arrout[index] = arr2[index-pos];
  }
}

int websocket_connect(struct web_client_t * C){
  int fd_client = C->fd_client;

  char buf[1024];

  memset(buf, 0, 1024);
  read(fd_client, buf, 1023);

  printf("Got data in buffer:\n\n%s\n\n",buf);

  char a[] = "Connection: Upgrade";
  char b[] = "Upgrade: websocket";
  char c[] = "Sec-WebSocket-Key: ";
  char d[] = "Protocol: ";

  char *start, *end, target[60];
  memset(target,0,60);

  if(strstr(buf, a) != ((void *)0) && strstr(buf, b) != ((void *)0) && strstr(buf, c) != ((void *)0)) {
    printf("\nIt is a HTML5 WebSocket!!\n");

    start = strstr(buf, c);
    start += strlen(c);
    if (end = strstr(start,"\r\n")){
        strncat(target,start,end-start);
    }
    printf("Socket-key: '%s'\n",target);
    strcat(target,websocket_magic_string);

    char protocol[5];
    memset(protocol,0,5);

    printf("Searching protocol\n");
    char *S_prot, *E_prot;
    int prot;
    S_prot = strstr(end+1, "\r\n");
    S_prot = strstr(S_prot, " ") + 1;
    printf("S_prot: 0x%x\n",S_prot);
    if(S_prot != ((void *)0)){
      printf("Drotocol: %s\n",S_prot);
      S_prot += strlen(d);
      if (E_prot = strstr(S_prot,"\r\n")){
          strncat(protocol,S_prot,E_prot-S_prot);
      }
      prot = (int)strtol(protocol,((void *)0),10);
    }
    printf("Protocol: %i\n",prot);


    unsigned char hash[20];
    SHA1(target, sizeof(target), hash);
    char b64[40] = "";
    base64_encode(hash,sizeof(hash),b64,40);


    char response[500] = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ";
    strcat(response,b64);
    if(prot != 0){
      strcat(response,"\r\nSec-WebSocket-Protocol: ");
      strcat(response,protocol);
    }
    strcat(response,"\r\n\r\n");
    printf("Sending Response\n\n%s\n\n\n",response);
    write(fd_client, response, strlen(response));

    printf("Done\n");
    C->client_type = prot;


    return 1;
  }else{

    return 0;
  }
}

int recv_packet(int fd_client, char outbuf[]){
  pthread_mutex_lock(&mutex_lock_web);
  char buf[1024];
  memset(buf,0,1024);
  memset(outbuf,0,sizeof(outbuf));
  usleep(10000);
  recv(fd_client,buf,1024,0);

  int byte = 0;
# 122 "./src/Web.c"
  byte = 0;


  int opcode = buf[byte++] & 0b00001111;


  unsigned int mes_length = buf[byte++] & 0b01111111;
  if(mes_length == 126){
    mes_length = (buf[byte++] << 8) + buf[byte++];

  }else if(mes_length == 127){

  }

  int masking_index = byte;
  unsigned int masking_key = (buf[byte++] << 24) + (buf[byte++] << 16) + (buf[byte++] << 8) + (buf[byte++]);


  char output[mes_length+2];
  memset(output,0,mes_length+2);

  for(int i = 0;i<mes_length;0){
    unsigned int test;
    unsigned int text;
    test = (buf[byte++] << 24) + (buf[byte++] << 16) + (buf[byte++] << 8) + (buf[byte++]);
    text = test ^ masking_key;

      output[i++] = (text & 0xFF000000) >> 24;
      if(i<mes_length){

        output[i++] = (text & 0xFF0000) >> 16;
      }
      if(i<mes_length){

        output[i++] = (text & 0xFF00) >> 8;
      }
      if(i<mes_length){

        output[i++] = text & 0xFF;
      }

  }

  strcat(outbuf,output);
  printf("%s\n",output);

  pthread_mutex_unlock(&mutex_lock_web);
  if(opcode == 8){
    printf("Connection closed by client\n\n");
    return -8;
  }
  return 1;
}

int send_packet(int fd_client, char data[],int length,int flag){


  char m_length = 0;
  char outbuf[4096];
  char buf[10];
  memset(outbuf,0,4096);
  buf[0] = 0b10000000 + 0b00000010;
  if(length < 126){
    buf[1] = length;
    m_length = 2;
  }else if(length < 65535){
    buf[1] = 126;
    buf[2] = 0xFF;
    buf[3] = 0xFF;

    buf[2] = (length & 0xFF00) >> 8;
    buf[3] = length & 0xFF;
    m_length = 4;
  }else{
    printf("Too large message\n\n");
  }

  append_Array(buf,m_length,data,length,outbuf);



  write(fd_client,outbuf,m_length+length);
}

int send_all(char data[],int length,int flag){
  pthread_mutex_lock(&mutex_lock_web);
  int m_length = 0;
  char outbuf[4096];
  char buf[10];
  memset(outbuf,0,4096);
  buf[0] = 0b10000000 + 0b00000010;
  if(length < 126){
    buf[1] = length;
    m_length = 2;
  }else if(length < 65535){
    buf[1] = 126;
    buf[2] = 0xFF;
    buf[3] = 0xFF;

    buf[2] = (length & 0xFF00) >> 8;
    buf[3] = length & 0xFF;
    m_length = 4;
  }

  append_Array(buf,m_length,data,length,outbuf);

  for(int i = 0;i<5;i++){
    if(fd_client_list[i] != 0 && (clients[i]->client_type & flag) != 0){

      write(fd_client_list[i],outbuf,m_length+length);
    }
  }
  pthread_mutex_unlock(&mutex_lock_web);
}

int recv_packet_procces(char data[]){
  if(data[0] == 'S' || data[0] == 'M' || data[0] == 'm'){
    char *M = strchr(&data[0], ':');
    char *B = strchr(&data[(M-data)+1], ':');
    if (M != ((void *)0) && B != ((void *)0)){ ;
      int start = 1;
      int colom1 = M-data;
      int colom2 = B-data;
      int end = strlen(data);

      char s_M[5],s_B[5],s_S[5];

      memset(s_M,0,5);
      memset(s_B,0,5);
      memset(s_S,0,5);



      for(int i = (start);i<=end;i++){
        if(i < colom1){
          s_M[(i-start)] = data[i];
        }else if(i > colom1 && i < colom2){
          s_B[(i-colom1-1)] = data[i];
        }else if(i > colom2 && i < end){
          s_S[(i-colom2-1)] = data[i];
        }
        if(i == colom1){
          s_M[(i-start)] = 0;
        }else if(i == colom2){
          s_B[(i-colom1-1)] = 0;
        }else if(i == (B-data)){
          s_S[(i-colom2-1)] = 0;
        }

      }



      int s_m = atoi(s_M);
      int s_b = atoi(s_B);
      int s_s = atoi(s_S);

      if(data[0] == 'S'){
        if(Switch[s_m][s_b][s_s] != ((void *)0)){
          printf("throw switch %i:%i:%i\t",s_m,s_b,s_s);
          printf("%i->%i",Switch[s_m][s_b][s_s]->state, !Switch[s_m][s_b][s_s]->state);
          throw_switch(Switch[s_m][s_b][s_s]);
        }
      }
      else if(data[0] == 'M' || data[0] == 'm'){
        if(Moduls[s_m][s_b][s_s] != ((void *)0)){
          if(data[0] == 'M'){
            printf("throw ms switch + %i:%i:%i\t",s_m,s_b,s_s);
            printf("%i->%i",Moduls[s_m][s_b][s_s]->state, Moduls[s_m][s_b][s_s]->state+1);
            int q = Moduls[s_m][s_b][s_s]->state;
            q += 1;

            if(q >= Moduls[s_m][s_b][s_s]->length){
              q = 0;
            }
            throw_ms_switch(Moduls[s_m][s_b][s_s],q);
          }else if(data[0] == 'm'){
            printf("throw ms switch - %i:%i:%i\t",s_m,s_b,s_s);
            printf("%i->%i",Moduls[s_m][s_b][s_s]->state, Moduls[s_m][s_b][s_s]->state+1);
            int q = Moduls[s_m][s_b][s_s]->state;
            q -= 1;

            if(q < 0){
              q = Moduls[s_m][s_b][s_s]->length;
            }
            throw_ms_switch(Moduls[s_m][s_b][s_s],q);
          }
        }
      }
    }
  }
  else if(data[0] == 'L'){
    printf("%s\n",data);
    char *M = strchr(&data[0], ':');
    if (M != ((void *)0)){ ;
      int start = 1;
      int colom1 = M-data;
      int end = strlen(data);

      char f_ID[5],t_ID[5];

      memset(f_ID,0,5);
      memset(t_ID,0,5);



      for(int i = (start);i<=end;i++){
        if(i < colom1){
          f_ID[(i-start)] = data[i];
        }else if(i > colom1 && i < end){
          t_ID[(i-colom1-1)] = data[i];
        }
        if(i == colom1){
          f_ID[(i-start)] = 0;
        }else if(i == end){
          t_ID[(i-colom1-1)] = 0;
        }
      }



      int fID = atoi(f_ID);
      int tID = atoi(t_ID);

      printf("Linking train %i with dcc address #%i\n",fID,trains[tID]->DCC_ID);
      if(link_train(fID,tID)){
        Web_Link_Train(1,fID,C_Adr(tID, trains[tID]->DCC_ID >> 8,trains[tID]->DCC_ID & 0xFF));
        Z21_GET_LOCO_INFO(trains[tID]->DCC_ID);
      }
    }
  }
  else if(data[0] == 'E' && (data[1] == 'r' || data[1] == 'c')){
    int start = 2;
    int end = strlen(data);

    char nr_s[4];

    for(int i = start;i<=end;i++){
      nr_s[(i-start)] = data[i];
      if(i == end){
        nr_s[(i-start)] = 0;
      }

    }

    int nr = atoi(nr_s);

    char buf[20];

    if(data[1] == 'r'){
      printf("Disable/Release Emergency Stop %i\n",nr);
      Web_Emergency_Stop(1);
    }else if(data[1] == 'c'){
      printf("Disable/Release Emergency Short Circuit Stop %i\n",nr);
      Web_Electrical_Stop(1);
    }
    status_st[nr] = 0;
  }
  else if(data[0] == 'R' && data[1] == 'N' && data[2] == 't'){
    char data_out[40];

    data_out[0] = 8;

    printf("Add a new train to the library\n");
    if(data[3] == 'P'){
      printf("Type\tPassenger train\n");
    }else if(data[3] == 'C'){
      printf("Type\tCargo train\n");
    }else{
      data_out[1] = 0;
      send_all(data_out,2,32);
      return;
    }
    char *NAME = strchr(&data[0], ':');
    char *DCC = strchr(&data[(NAME-data)+1], ':');
    if (NAME != ((void *)0) && DCC != ((void *)0)){ ;
      int start = 4;
      int colom1 = NAME-data;
      int colom2 = DCC-data;
      int end = strlen(data);

      char s_Name[21],s_DCC[5],s_Speed[5];

      memset(s_Name,0,21);
      memset(s_DCC,0,5);
      memset(s_Speed,0,5);

      for(int i = (start);i<=end;i++){
        if(i < colom1){
          s_Name[(i-start)] = data[i];
        }else if(i > colom1 && i < colom2){
          s_DCC[(i-colom1-1)] = data[i];
        }else if(i > colom2 && i < end){
          s_Speed[(i-colom2-1)] = data[i];
        }
        if(i == colom1){
          s_Name[(i-start)] = 0;
        }else if(i == colom2){
          s_DCC[(i-colom1-1)] = 0;
        }else if(i == (DCC-data)){
          s_Speed[(i-colom2-1)] = 0;
        }
      }

      printf("Name\t%s\nDCC\t%s\nSpeed\t%s\n",s_Name,s_DCC,s_Speed);
      int value;
      if((value = create_train(atoi(s_DCC),atoi(s_Speed),s_Name,data[3])) >= 0){
        data_out[1] = 2;
        data_out[2] = value;






        send_all(data_out,3,32);
      }else{
        data_out[1] = 1;
        send_all(data_out,2,32);
      }


    }
  }
  else if(data[0] == 't' && (data[1] == 'D' || data[1] == 'A')){
    printf("Switching control type\t");
    char data_out[13];
    data_out[0] = '\0';
    if(data[1] == 'D'){
      printf("DCC\n");
      digital_track = (1==1);
      data_out[1] = 1;
    }else{
      printf("DC\n");
      digital_track = (!(1==1));
      data_out[1] = 0;
    }
    send_all(data_out,2,1);
  }
  else{
    printf("Wrong request for client\n");
  }
}

void * websocket_client(void * thread_data){
  struct client_thread_args *thread_args;
 thread_args = (struct client_thread_args *) thread_data;
 int i = thread_args->thread_id;
 int fd_client = thread_args->fd_client;

  printf("New websocket_client");
  if(websocket_connect(clients[i])){
      char buf[1024];
      memset(buf,0,1024);

      fd_client_list[i] = fd_client;

      connected_clients++;

      while(initialise == 1){

      }
      printf("Send 1\n");
      char data[2];
      data[0] = 0;
      data[1] = digital_track;
      send_packet(fd_client,data,2,1);
      printf("Send 2\n");

      send_packet(fd_client,setup_data,setup_data_l,8);
      printf("Recv 1\n");
      recv_packet(fd_client,buf);
      memset(buf,0,1024);

      printf("Send 3\n");

      JSON_new_client(fd_client);
      printf("Done\n");

      while(1){

        if(recv(fd_client,buf,1024,MSG_PEEK) > 0){
          printf("Data received\n");
          usleep(10000);
          int status = recv_packet(fd_client,buf);
          if(status == 1){
            recv_packet_procces(buf);
          }
          printf("\n%s\n",buf);
          if(status == -8){
            close(fd_client);
            connected_clients--;
            fd_client_list[i] = 0;
            clients[i]->state = 2;
            return;
          }

        }

        if(stop){
          close(fd_client);
        }
      }
  }else{
    printf("Wrong HTTP request!!!!\n");
    close(fd_client);
    clients[i]->state = 2;
    return;
  }
}

void *clear_clients(){
 while(!stop){
  for(int i = 0;i<5;i++){
   if(clients[i]->state == 2){
    pthread_join(client_threads[i], ((void *)0));
    clients[i]->state = 0;
    printf("Reset client %i\n",i);
   }
  }
    usleep(100000);
 }
}

void * web_server(){
  struct sockaddr_in server_addr, client_addr;
  socklen_t sin_len = sizeof(client_addr);
  int fd_server, fd_client;
  int fdimg;
  int on = 1;

  fd_server = socket(2, SOCK_STREAM, 0);
  if(fd_server < 0){
    printf("ERROR, SOCKET\n");
    exit(1);
  }


  setsockopt(fd_server, 1, 2, &on, sizeof(int));

  server_addr.sin_family = 2;
  server_addr.sin_addr.s_addr = ((in_addr_t) 0x00000000);
  server_addr.sin_port = htons(9000);

  if(bind(fd_server, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1){
    printf("ERROR, BIND\n");
    close(fd_server);
    exit(1);
  }

  if(listen(fd_server, 5) == -1){
    printf("ERROR, LISTEN\n");
    close(fd_server);
    exit(1);
  }

  int q = 0;

  while(startup == 0){
    usleep(10000);
  }


  for(int i = 0;i<5;i++){
    struct web_client_t * Z = (struct web_client_t *)malloc(sizeof(struct web_client_t));
    Z->state = 0;
    Z->fd_client = 0;
    Z->client_type = 0;
    clients[i] = Z;
  }


  pthread_t clear;
  pthread_create(&clear, ((void *)0), clear_clients, ((void *)0));

  while(1){
    fd_client = accept(fd_server, (struct sockaddr *) &client_addr, &sin_len);

    if(fd_client == -1){
      if(q == 0){
        printf("ERROR, Client Connect\n");
      }
      q = 1;
      continue;
    }
    q = 0;

    int i = 0;
   while(1){
    if(clients[i]->state == 0){
     clients_data[i].thread_id = i;
     clients_data[i].fd_client = fd_client;

        clients[i]->fd_client = fd_client;
        clients[i]->state = 1;

     printf("Create client thread %i\n",i);
     pthread_create(&client_threads[i], ((void *)0), websocket_client, (void *) &clients_data[i]);
     break;
    }
    i++;
    if(i==5){
     i = 0;
     printf("Too many clients!!!!!\n\n");
     usleep(100000);
    }
   }

    if(stop){
      close(fd_server);
      break;
    }
  }
}
# 551 "baan.c" 2
# 1 "./src/COM.c" 1



pthread_mutex_t mutex_UART;
# 43 "./src/COM.c"
int uart0_filestream = -1;

void * UART(){


 uart0_filestream = open("/dev/ttyAMA0", 02 | 0400);
 if (uart0_filestream == -1)
 {

  printf("Error - Unable to open UART.  Ensure it is not in use by another application\n");
 }


 struct termios options;
 tcgetattr(uart0_filestream, &options);
 options.c_cflag = 0000017 | 0000060 | 0004000 | 0000200;
 options.c_iflag = 0000004;
 options.c_oflag = 0;
 options.c_lflag = 0;
 tcflush(uart0_filestream, 0);
 tcsetattr(uart0_filestream, 0, &options);

 while(!stop){
  usleep(1000000);
 }


 close(uart0_filestream);
}

char * COM_Send(struct COM_t DATA){
 if (uart0_filestream == -1){
  return "No UART";
 }

 char out[40];

 out[0] = DATA.Adr;
 out[1] = DATA.Length << 4;
 out[1] += DATA.Opcode & 0b1111;
 for(int i = 0;i<DATA.Length;i++){
  out[i+2] = DATA.Data[i];
 }



 tcflush(uart0_filestream, 0);

 digitalWrite(0,1);
 int count = write(uart0_filestream, &out[0], (DATA.Length + 2));
 if (count < 0)
 {
  printf("UART TX error\n");
 }else{

 }
 int t = (1000000/(38400/8))*count;

 usleep(t+100);
 digitalWrite(0,0);
 usleep(100);
}

int COM_Recv(char * OUT_Data){


 if(uart0_filestream == -1){
  return;
 }
  unsigned char data_buffer[256] = {0};
 int index = 0;
 memset(data_buffer,0,256);
  while(1){

    unsigned char rx_buffer[255];
  int rx_length = read(uart0_filestream, (void*)rx_buffer, 255);
  if (rx_length < 0)
  {

  }
  else if (rx_length == 0)
  {

  }
  else if (rx_length == 8)
  {
      rx_buffer[rx_length] = '\0';

   for(int i = 0;i<8;i++){
    data_buffer[index++] = rx_buffer[i];
   }
  }
  else
  {

   rx_buffer[rx_length] = '\0';

   for(int i = 0;i<rx_length;i++){
    data_buffer[index++] = rx_buffer[i];
   }
      break;
  }
  return index;
  }

 for(int i = 0;i<index;i++){
  OUT_Data[i] = data_buffer[i];
 }
}

char * COM_SaR(char * buf[60]){

}

void COM_change_A_signal(int M){
 if (uart0_filestream != -1){

  struct COM_t C;
  memset(C.Data,0,32);
  C.Adr = M;
  C.Opcode = 0b1001;

  int nr_signals = Units[M]->Si_L;

  int location = 0;
  int position = 0;
  int Signal_Adr = 0;
  int empty = 0;

  for(int i = 0;i<=nr_signals;i++){
   if(Units[M]->Signals[i] != ((void *)0)){
    printf("Signal found on 0%o\tRegister: %i\tPosition %i\tState: %i\n",Units[M]->Signals[i]->UAdr,location,position,Units[M]->Signals[i]->state);
    C.Data[location] += Units[M]->Signals[i]->state << position;
    position += (Units[M]->Signals[i]->type+1);
   }else{
    printf("No Signal\t\tRegister: %i\tPosition %i\n",location,position);
    position += 3;
    empty++;
   }

   if(Units[M]->Signals[i+1] != ((void *)0) && position >= (8 - Units[M]->Signals[i+1]->type - 1)){
    position = 0;
    if(empty != 2){
     location++;
     Signal_Adr++;
    }
    empty = 0;
   }else if(position >= 5){
    position = 0;
    if(empty != 2){
     location++;
     Signal_Adr++;
    }
    empty = 0;
   }
  }

  Signal_Adr += 1;

  printf("Binary data: ");
  for(int i = 0;i<Signal_Adr;i++){
   printf("%c%c%c%c%c%c%c%c",(C.Data[i] & 0x80 ? '1' : '0'), (C.Data[i] & 0x40 ? '1' : '0'), (C.Data[i] & 0x20 ? '1' : '0'), (C.Data[i] & 0x10 ? '1' : '0'), (C.Data[i] & 0x08 ? '1' : '0'), (C.Data[i] & 0x04 ? '1' : '0'), (C.Data[i] & 0x02 ? '1' : '0'), (C.Data[i] & 0x01 ? '1' : '0'));
   printf(" ");
  }
  printf("\n");
  C.Length = Signal_Adr;

  pthread_mutex_lock(&mutex_UART);
  COM_Send(C);
  pthread_mutex_unlock(&mutex_UART);
 }
}

void COM_change_A_switch(int M){
 if (uart0_filestream != -1){

  struct COM_t C;
  memset(C.Data,0,32);
  C.Adr = M;
  C.Opcode = 0b0111;

  int nr_signals = Units[M]->S_L;

  int location = 0;
  int position = 0;
  int Switch_Adr = 0;
  int empty = 0;

  for(int i = 0;i<=nr_signals;i++){
   if(Units[M]->S[i] != ((void *)0)){
    printf("Switch found on 0%o\tlocation: %i\tPosition %i\n",Units[M]->S[i]->UAdr,location+2,position);
    if(Units[M]->S[i]->state == 0){
     C.Data[location] += 1 << position;
    }else{
     C.Data[location] += 2 << position;
    }
    position += 2;
   }else{
    printf("No Switch\t\tlocation: %i\tPosition %i\n",location+2,position);
    position += 2;
    empty++;
   }

   if(position >= 7){
    position = 0;
    if(empty != 4){
     location++;
     Switch_Adr++;
    }
    empty = 0;
   }
  }

  Switch_Adr += 1;


  C.Length = Switch_Adr;

  pthread_mutex_lock(&mutex_UART);
  COM_Send(C);
  pthread_mutex_unlock(&mutex_UART);
 }
}

void COM_change_signal(struct signal * Si){
 if (uart0_filestream != -1){
  COM_change_A_signal(Si->MAdr);
# 341 "./src/COM.c"
 }
}

void COM_change_switch(struct Swi * S){
 if (uart0_filestream != -1){
  int M = S->Adr.M;

  int nr_signals = Units[M]->S_L;

  char out[15];

  memset(out,0,15);

  out[0] = M;
  out[1] = 0b101000;

  int location = 0;
  int position = 0;
  int Signal_Adr = 0;
  int empty = 0;
  int loc = -1;
  char data;

  printf("Finding Signal 0%o\n",S->UAdr);

  for(int i = 0;i<=nr_signals;i++){
   if(Units[M]->S[i] != ((void *)0)){
    printf("Switch found on 0%o\tlocation: %i\tPosition %i\n",Units[M]->S[i]->UAdr,location+2,position);
    if(Units[M]->S[i]->UAdr == S->UAdr){
     loc = location;
    }
    if(Units[M]->S[i]->state == 0){
     out[2+location] += 1 << position;
    }else{
     out[2+location] += 2 << position;
    }
    position += 2;
   }else{
    printf("No Switch\t\tlocation: %i\tPosition %i\n",location+2,position);
    position += 2;
    empty++;
   }

   if(position >= 7){
    position = 0;
    if(empty != 4){
     location++;
     Signal_Adr++;
    }
    if(loc != -1){
     break;
    }
    empty = 0;
   }
  }

  out[3] = out[loc+2];
  out[2] = loc;

  printf("Sending: [%i][%i]",out[0],out[1]);
  for(int i = 0;i<2;i++){
   printf("[%i]",out[i+2]);
  }
  printf("\n\n");
  int count = write(uart0_filestream, &out[0], 4);
 }
}

void COM_set_train_speed(struct train * T,char speed){

}
# 552 "baan.c" 2

# 1 "./src/Z21.c" 1
# 13 "./src/Z21.c"
void die(char *s)
{
    perror(s);
    exit(1);
}

void Z21_recv(char message[100]);

void Z21_client(){
    int i;
    char buf[512];
    char message[512];

    if ( (fd_Z21_server=socket(2, SOCK_DGRAM, IPPROTO_UDP)) == -1)
    {
        die("socket");
    }

    memset((char *) &si_other, 0, sizeof(si_other));
    si_other.sin_family = 2;
    si_other.sin_port = htons(4129);

    if (inet_aton("127.0.0.1" , &si_other.sin_addr) == 0)
    {
        fprintf(stderr, "inet_aton() failed\n");
        exit(1);
    }

    while(1)
    {
        printf("Enter message : ");
        gets(message);


        if (sendto(fd_Z21_server, message, strlen(message) , 0 , (struct sockaddr *) &si_other, slen)==-1)
        {
            die("sendto()");
        }



        memset(buf,'\0', 512);

        if (recvfrom(fd_Z21_server, buf, 512, 0, (struct sockaddr *) &si_other, &slen) == -1)
        {
            die("recvfrom()");
        }

        Z21_recv(buf);
    }

    close(fd_Z21_server);
    return;
}

void Z21_recv(char message[100]){
 int dataLen = message[0] + message[1] << 8;
 int Header = message[2] + message[3] << 8;

 printf("A message is recieved :)\n\n");

 printf("DataLen:\t%i\n",dataLen);
 printf("Header:\t%i\n\n",Header);

  for(int i = 0;i<96;){
    printf("%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\n",message[i++],message[i++],message[i++],message[i++],message[i++],message[i++],message[i++],message[i++]);
  }
  printf("%i\t%i\t%i\t%i\n",message[96],message[97],message[98],message[99]);






 if(Header == 0x10 && dataLen >= 8){

  int Serial_number = message[4] + message[5] << 8 + message[6] << 16 + message[7] << 24;
  printf("The Serial number of the Z21-base station is:\n%x\n",Serial_number);
 }
 else if(Header == 0x1A && dataLen >= 12){

    int HW_number = message[4] + message[5] << 8 + message[6] << 16 + message[7] << 24;
    printf("The Hardware number of the Z21-base station is:\n%x\n",HW_number);

    int SW_number = message[8] + message[9] << 8 + message[10] << 16 + message[11] << 24;
  printf("The Software number of the Z21-base station is:\n%x\n",SW_number);
 }
 else if(Header == 0x40 && dataLen >= 5){
    int X_header = message[4];
  if(X_header == 0x43 && dataLen >= 8){

      int FAdr = message[5] + message[6] << 8;
      printf("TURNOUT INFO\n");
      printf("Function Address:\t%x\n",FAdr);
      printf("Turnout position:\t%x\n\n",message[7] & 3);
  }
    else if(X_header == 0x61){
      if(message[5] == 0x00){

        printf("BC TRACK POWER OFF\n");
    }
      else if(message[5] == 0x01){

        printf("BC TRACK POWER ON\n");
    }
      else if(message[5] == 0x02){

        printf("BC PROGRAMMING MODE\n");
    }
      else if(message[5] == 0x08){

        printf("BC TRACK SHORT CIRCUIT\n");
    }
      else if(message[5] == 0x12){

        printf("CV Programming Failed (CV NACK SC)\n");
    }
      else if(message[5] == 0x13){

        printf("CV No ACKnolegment\n");
      }
      else if(message[5] == 0x82){

        printf("UNKOWN COMMAND\n");
    }
      else if(message[5] == 0x22){

        printf("LAN STATUS CHANGED\n");
        printf("Centrale status: 0x%x\n",message[6]);
# 150 "./src/Z21.c"
    }
      else if(message[5] == 0x21){

        printf("X-Bus Version\n");
        printf("\t%x.%x\n",message[6] >> 4,message[6] & 0xF);
    }
      else if(message[5] == 0x14){

        printf("CV Read\n");
        printf("CV Adr:\t%i\n",(message[6] << 8 + message[7]));
        printf("Value:\t%i\n",message[8]);
      }
  }
    else if(X_header == 0x81 && dataLen >= 7){

      printf("EMERGENCY STOP // BC_STOPPED\n");
  }
    else if(X_header == 0xEF && dataLen >= 7){

      printf("LOCO INFO\n");
      char data[14];
      memset(data,0,14);
      for(int i = 5;i < (dataLen - 1);i++){
        printf("DB%02i:\t%x\n",message[i]);
        data[i-5] = message[i];
      }

      printf("\nLoc Address:     \t%04i",((data[0] & 0x3F) << 8) + data[1]);
      printf("\nX-Bus Hand block:\t%i",data[2] & 0x8);
      printf("\nSpeed step:      \t%03i",data[2] & 0x7);
      printf("\nDirection:       \t%i",data[3] & 0x80);
      printf("\nMM speed:        \t%03i",data[3] & 0x7F);
      printf("\n'Doppeltraktion':\t%i",data[4] & 0x40);
      printf("\n'Smartsearch':   \t%i",data[4] & 0x20);
      printf("\n\nF00:\t%i\tLight",data[4] & 0x10);
      printf("\nF01:\t%i",data[4] & 0x1);
      printf("\nF02:\t%i",data[4] & 0x2);
      printf("\nF03:\t%i",data[4] & 0x4);
      printf("\nF04:\t%i",data[4] & 0x8);
      printf("\nF05:\t%i",data[5] & 0x1);
      printf("\nF06:\t%i",data[5] & 0x2);
      printf("\nF07:\t%i",data[5] & 0x4);
      printf("\nF08:\t%i",data[5] & 0x8);
      printf("\nF09:\t%i",data[5] & 0x10);
      printf("\nF10:\t%i",data[5] & 0x20);
      printf("\nF11:\t%i",data[5] & 0x40);
      printf("\nF12:\t%i",data[5] & 0x80);
      printf("\nF13:\t%i",data[6] & 0x1);
      printf("\nF14:\t%i",data[6] & 0x2);
      printf("\nF15:\t%i",data[6] & 0x4);
      printf("\nF16:\t%i",data[6] & 0x8);
      printf("\nF17:\t%i",data[6] & 0x10);
      printf("\nF18:\t%i",data[6] & 0x20);
      printf("\nF19:\t%i",data[6] & 0x40);
      printf("\nF20:\t%i",data[6] & 0x80);
      printf("\nF21:\t%i",data[7] & 0x1);
      printf("\nF22:\t%i",data[7] & 0x2);
      printf("\nF23:\t%i",data[7] & 0x4);
      printf("\nF24:\t%i",data[7] & 0x8);
      printf("\nF25:\t%i",data[7] & 0x10);
      printf("\nF26:\t%i",data[7] & 0x20);
      printf("\nF27:\t%i",data[7] & 0x40);
      printf("\nF28:\t%i",data[7] & 0x80);
      printf("\n\nExtra Data\n08:\t");
      for(int j = 8;j<14;j){
        printf("%c%c%c%c%c%c%c%c",(data[j++] & 0x80 ? '1' : '0'), (data[j++] & 0x40 ? '1' : '0'), (data[j++] & 0x20 ? '1' : '0'), (data[j++] & 0x10 ? '1' : '0'), (data[j++] & 0x08 ? '1' : '0'), (data[j++] & 0x04 ? '1' : '0'), (data[j++] & 0x02 ? '1' : '0'), (data[j++] & 0x01 ? '1' : '0'));
        printf("\n%02i\t",j);
      }
      Web_Train_Data(data);

      printf("\n");
  }
    else if(X_header == 0xF3 && message[5] == 0x0A){

      printf("FIRMWARE VERSION\n");
      printf("v%x.%x\n",message[6],message[7]);
  }
 }
 else if(Header == 0x51 && dataLen >= 8){

    int Flags = message[4] + message[5] << 8 + message[6] << 16 + message[7] << 24;
    printf("BROADCASTFLAGS\t%x\n",Flags);
 }
 else if(Header == 0x60 && dataLen >= 7){

    printf("LOCO MODE\n");
    printf("Address:\t%x\n",(message[4] << 8 + message[5]));
    printf("Modues: \t%i\n",message[6]);
 }
 else if(Header == 0x70 && dataLen >= 7){

    printf("TURNOUT MODE\n");
    printf("Address:\t%x\n",(message[4] << 8 + message[5]));
    printf("Modues: \t%i\n",message[6]);
 }
 else if(Header == 0x80 && dataLen >= 15){

    printf("Block detection\n");
    if(message[4] == 0){
      printf("Address 1 to 10\n");
    }

    for(int i = 5;i<(dataLen-1);i++){
      printf("Status detector %02i\t%x\n",(i-5),message[i]);
    }
 }
 else if(Header == 0x84 && dataLen >= 20){


    int i = 4;
    short MainCurrent = message[i++] + message[i++] << 8;
    short ProgCurrent = message[i++] + message[i++] << 8;
    short FilteredMainCurrent = message[i++] + message[i++] << 8;
    short Temperature = message[i++] + message[i++] << 8;
    unsigned short SupplyVoltage = message[i++] + message[i++] << 8;
    unsigned short VCCVoltage = message[i++] + message[i++] <<8;
    unsigned char CentralState = message[i++];
    unsigned char CentralStateEx = message[i++];
# 281 "./src/Z21.c"
    printf("MainCurrent\t%imA\n",MainCurrent);
    printf("ProgCurrent\t%imA\n",ProgCurrent);
    printf("FilteredMainCurrent\t%imA\n",FilteredMainCurrent);
    printf("Temperature\t%i C\n",Temperature);
    printf("SupplyVoltage\t%imV\n",SupplyVoltage);
    printf("VCCVoltage\t%imV\n",VCCVoltage);
    printf("CentralState\t%x\n",CentralState);
    printf("CentralStateEx\t%x\n",CentralStateEx);
 }
 else if(Header == 0x88){

    printf("RAILCOM DATACHANGED\nNot supported\n");
 }
 else if(Header == 0xA0){

    printf("LOCONET RX\nNot supported\n");
 }
 else if(Header == 0xA1){

    printf("LOCONET TX\nNot supported\n");
 }
 else if(Header == 0xA2){

    printf("LOCONET FROM LAN\nNot supported\n");
 }
 else if(Header == 0xA3){

    printf("LOCONET DISPATCH ADDR\nNot supported\n");
 }
 else if(Header == 0xA4){

    printf("LOCONET DETECTOR\nNot supported\n");
 }
}

void Z21_send(int Header,char data[30]){

}

void Z21_GET_LOCO_INFO(int DCC_Adr){



  if(fd_Z21_server != 0){
    char data[10];
    data[0] = 9;
    data[2] = 0x40;
    data[4] = 0xE3;
    data[5] = 0xF0;
    data[6] = (DCC_Adr & 0x3F00) >> 8;
    data[7] = DCC_Adr & 0xFF;
    data[8] = data[4] ^ data[5] ^ data[6] ^ data[7];


    if (sendto(fd_Z21_server, data, data[0], 0 , (struct sockaddr *) &si_other, slen)==-1){
        printf("failed sendto()\n");
    }
  }else{
    printf("No Z21 server connected\n");
    char data[15];
    data[0] = 13;
    data[2] = 0x40;
    data[4] = 0xEF;
    data[5] = (DCC_Adr & 0x3F00) >> 8;
    data[6] = DCC_Adr & 0xFF;
    data[7] = 0b00000100;
    data[8] = 0b10011010;
    data[9] = 0b00010001;
    data[10] = 0b00000000;
    data[11] = 0b00000000;
    data[12] = 0b00000000;
    printf("DCC_Adr:0x%x\t=>\t%x %x",DCC_Adr,data[5],data[6]);
    Web_Train_Data(data);
  }
}

void Z21_SET_LOCO_DRIVE(int DCC_Adr,char steps,_Bool dir,char drive){



  if(fd_Z21_server != 0){
    char data[10];
    data[0] = 0x0A;
    data[2] = 0x40;
    data[4] = 0xE4;
    data[5] = 0x10;
    if(steps == 28){
      data[5] += 0x2;
    }else if(steps == 128){
      data[5] += 0x3;
    }
    data[6] = (DCC_Adr & 0x3F00) >> 8;
    data[7] = DCC_Adr & 0xFF;
    data[8] = (dir << 7) + (drive & 0x7F);
    data[9] = data[4] ^ data[5] ^ data[6] ^ data[7] ^ data[8];


    if (sendto(fd_Z21_server, data, data[0], 0 , (struct sockaddr *) &si_other, slen)==-1)
    {
        printf("Failed sendto()\n");
    }
  }else{
    printf("No Z21 server connected\n");
  }
}

void Z21_SET_LOCO_FUNCTION(int DCC_Adr,char function_nr,char switch_type){



  if(fd_Z21_server != 0){
    char data[10];
    data[0] = 0x0A;
    data[2] = 0x40;
    data[4] = 0xE4;
    data[5] = 0xF8;
    data[6] = (DCC_Adr & 0x3F00) >> 8;
    data[7] = DCC_Adr & 0xFF;
    data[8] = (switch_type << 6) + (function_nr & 0x3F);
    data[9] = data[4] ^ data[5] ^ data[6] ^ data[7] ^ data[8];


    if (sendto(fd_Z21_server, data, data[0], 0 , (struct sockaddr *) &si_other, slen)==-1)
    {
        printf("Failed sendto()\n");
    }
  }else{
    printf("No Z21 server connected\n");
  }
}
# 554 "baan.c" 2

int check_Switch(struct adr adr, int direct){
 struct adr NAdr;
 int dir = blocks[adr.M][adr.B][adr.S]->dir;

 if(direct == 0){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = blocks[adr.M][adr.B][adr.S]->NAdr;
  }else{
   NAdr = blocks[adr.M][adr.B][adr.S]->PAdr;
  }
 }else{
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = blocks[adr.M][adr.B][adr.S]->PAdr;
  }else{
   NAdr = blocks[adr.M][adr.B][adr.S]->NAdr;
  }
 }

 int n;
 R:{};

 if(NAdr.type == 'R'){

  return 1;
 }else if(NAdr.type == 'e'){
  return 0;
 }else if(NAdr.type == 'S'){
  if(Switch[NAdr.M][NAdr.B][NAdr.S]->pref[0] && Switch[NAdr.M][NAdr.B][NAdr.S]->pref[0]->type == 0 &&
     Switch[NAdr.M][NAdr.B][NAdr.S]->pref[0]->state != Switch[NAdr.M][NAdr.B][NAdr.S]->state){
   return 0;
  }
  if(Switch[NAdr.M][NAdr.B][NAdr.S]->state == 0){
   adr = NAdr;
   NAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->Str;
  }else{
   adr = NAdr;
   NAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->Div;
  }
  goto R;
 }else if(NAdr.type == 'M'){
  int s = Moduls[NAdr.M][NAdr.B][NAdr.S]->state;
  if(Adr_Comp(Moduls[NAdr.M][NAdr.B][NAdr.S]->MAdr[s],adr)){
   NAdr = Moduls[NAdr.M][NAdr.B][NAdr.S]->mAdr[s];
   goto R;
  }else{
   return 0;
  }
 }else if(NAdr.type == 'm'){
  int s = Moduls[NAdr.M][NAdr.B][NAdr.S]->state;
  if(Adr_Comp(Moduls[NAdr.M][NAdr.B][NAdr.S]->mAdr[s],adr)){
   NAdr = Moduls[NAdr.M][NAdr.B][NAdr.S]->MAdr[s];
   goto R;
  }else{
   return 0;
  }
 }else{
  struct adr Div = Switch[NAdr.M][NAdr.B][NAdr.S]->Div;
  struct adr Str = Switch[NAdr.M][NAdr.B][NAdr.S]->Str;


  if(Adr_Comp(Div,adr)){
   if(Switch[NAdr.M][NAdr.B][NAdr.S]->state == 1){
    n = 1;
   }else{
    return 0;
   }
  }else if(Adr_Comp(Str,adr)){
   if(Switch[NAdr.M][NAdr.B][NAdr.S]->state == 0){
    n = 1;
   }else{
    return 0;
   }
  }else{
   return 0;
  }


  adr = Switch[NAdr.M][NAdr.B][NAdr.S]->Adr;
  NAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->App;
  goto R;

 }
 printf("Retrun %i\n",n);
 return n;
}

int free_Switch(struct adr adr, int direct){
 struct adr NAdr;
 int return_Value = 1;
 int dir = blocks[adr.M][adr.B][adr.S]->dir;

 if(direct == 0){
  if(dir == 0 || dir == 2){
   NAdr = blocks[adr.M][adr.B][adr.S]->NAdr;
  }else{
   NAdr = blocks[adr.M][adr.B][adr.S]->PAdr;
  }
 }else{
  if(dir == 0 || dir == 2){
   NAdr = blocks[adr.M][adr.B][adr.S]->PAdr;
  }else{
   NAdr = blocks[adr.M][adr.B][adr.S]->NAdr;
  }
 }

 R:{};
 printf("NAdr: %i:%i:%i\t",NAdr.M,NAdr.B,NAdr.S);
 printf("%i\n",return_Value);
 if(return_Value == 0){
  return 0;
 }

 if(NAdr.type == 'S'){
  struct Swi * S = Switch[NAdr.M][NAdr.B][NAdr.S];
  if(S->pref[0] && S->pref[0]->type == 0 && S->state != S->pref[0]->state){
   throw_switch(S);
  }
  if(S->state == 0){
   adr = NAdr;
   NAdr = S->Str;
  }else{
   adr = NAdr;
   NAdr = S->Div;
  }
  goto R;
 }else if(NAdr.type == 's'){
  struct adr Div = Switch[NAdr.M][NAdr.B][NAdr.S]->Div;
  struct adr Str = Switch[NAdr.M][NAdr.B][NAdr.S]->Str;
  if(Adr_Comp(Div,adr)){
   if(Switch[NAdr.M][NAdr.B][NAdr.S]->state == 0){
    return_Value = throw_switch(Switch[NAdr.M][NAdr.B][NAdr.S]);
   }
  }else if(Adr_Comp(Str,adr)){
   if(Switch[NAdr.M][NAdr.B][NAdr.S]->state == 1){
    return_Value = throw_switch(Switch[NAdr.M][NAdr.B][NAdr.S]);
   }
  }


  adr = Switch[NAdr.M][NAdr.B][NAdr.S]->Adr;
  NAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->App;
  goto R;

 }else if(NAdr.type == 'M'){
  struct Mod * M = Moduls[NAdr.M][NAdr.B][NAdr.S];
  int s = M->state;
  if(Adr_Comp(M->MAdr[s],adr)){
   NAdr = M->mAdr[s];
  }else{
   for(int i = 0;i<M->length;i++){
    if(Adr_Comp(M->MAdr[i],adr)){
     return_Value = throw_ms_switch(M,i);
     break;
    }
   }
  }
  adr = M->Adr;
  NAdr = M->mAdr[M->state];
  goto R;
 }else if(NAdr.type == 'm'){
  struct Mod * M = Moduls[NAdr.M][NAdr.B][NAdr.S];
  int s = M->state;
  if(Adr_Comp(M->mAdr[s],adr)){
   NAdr = M->MAdr[s];
  }else{
   for(int i = 0;i<M->length;i++){
    if(Adr_Comp(M->mAdr[i],adr)){
     return_Value = throw_ms_switch(M,i);
     break;
    }
   }
  }
  adr = M->Adr;
  NAdr = M->MAdr[M->state];
  goto R;
 }
 return 1;
}

void JSON(){
 pthread_mutex_lock(&mutex_lockB);
 char buf[4096];
 memset(buf,0,4096);

 buf[0] = 3;
 int buf_l;

 _Bool data = 0;

 int index = 0;

 for(int i = 0;i<B_list_i;i++){

  struct adr A = Block_list[i];
  if(blocks[A.M][A.B][A.S]->change != 0){
   data = 1;


   buf[index*5+1] = A.M;
   buf[index*5+2] = A.B;
   buf[index*5+3] = A.S;
   buf[index*5+4] = (blocks[A.M][A.B][A.S]->dir << 7) + (blocks[A.M][A.B][A.S]->blocked << 4) + blocks[A.M][A.B][A.S]->state;
   buf[index*5+5] = blocks[A.M][A.B][A.S]->train;

   index++;

   blocks[A.M][A.B][A.S]->change = 0;



   buf_l = index*5;
  }
 }

 if(data == 1){
  send_all(buf,buf_l,8);
 }

 pthread_mutex_unlock(&mutex_lockB);
}

void JSON_new_client(int Client_fd){
 pthread_mutex_lock(&mutex_lockB);
 char buf[4096];
 memset(buf,0,4096);



  buf[0] = 3;
  int buf_l;
  _Bool data = 0;

  for(int i = 1;(i-1)<B_list_i;i++){

   struct adr A = Block_list[i-1];

   data = 1;



   buf[(i-1)*5+1] = A.M;
   buf[(i-1)*5+2] = A.B;
   buf[(i-1)*5+3] = A.S;
   buf[(i-1)*5+4] = (blocks[A.M][A.B][A.S]->dir << 7) + (blocks[A.M][A.B][A.S]->blocked << 4) + blocks[A.M][A.B][A.S]->state;
   buf[(i-1)*5+5] = blocks[A.M][A.B][A.S]->train;



   buf_l = (i-1)*5+6;
  }

  if(data == 1){
   send_packet(Client_fd,buf,buf_l,8);
  }

  memset(buf,0,4096);



  buf[0] = 4;
  buf_l = 0;
  data = 0;

  for(int i = 1;(i-1)<S_list_i;i++){

   struct adr A = Switch_list[i-1];

   data = 1;



   buf[(i-1)*4+1] = A.M;
   buf[(i-1)*4+2] = A.B;
   buf[(i-1)*4+3] = A.S;
   buf[(i-1)*4+4] = Switch[A.M][A.B][A.S]->state;



   buf_l = (i-1)*4+5;
  }

  if(data == 1){
   send_packet(Client_fd,buf,buf_l,8);
  }

  memset(buf,0,4096);



  buf[0] = 5;
  buf_l = 0;
  data = 0;

  for(int i = 1;(i-1)<M_list_i;i++){

   struct adr A = MS_Switch_list[i-1];

   data = 1;



   buf[(i-1)*5+1] = A.M;
   buf[(i-1)*5+2] = A.B;
   buf[(i-1)*5+3] = A.S;
   buf[(i-1)*5+4] = Moduls[A.M][A.B][A.S]->state;
   buf[(i-1)*5+5] = Moduls[A.M][A.B][A.S]->length;

   buf_l = (i-1)*5+6;
  }

  if(data == 1){
   send_packet(Client_fd,buf,buf_l,8);
  }

  memset(buf,0,4096);



 buf[0] = 6;
 buf_l = 0;
 data = 0;

 for(int i = 1;(i-1)<St_list_i;i++){

  struct adr A = stations[i-1]->Adr;

  data = 1;

  printf("entry %i\tStation %i:%i\tbuf_l: %i\n",i,A.M,A.B,buf_l);

  buf[(i-1)*2+1] = A.M;
  buf[(i-1)*2+2] = A.B;

  buf_l = 2*i+1;
 }

 if(data == 1){
  send_packet(Client_fd,buf,buf_l,8);
 }

 memset(buf,0,4096);

 pthread_mutex_unlock(&mutex_lockB);
}

void *Test(void *threadArg){
 struct timer_thread_data *my_data;
 my_data = (struct timer_thread_data *) threadArg;
 int i = my_data->thread_id;
 int t = my_data->t;
 printf("\t%i Sleep %i\n",i,t);
 usleep(t);
 timers[i] = 2;
 printf("%i done\n",i);
}

void STOP_train(char train){
 usleep(500000);

}

void create_timer(){
 int i = 0;
 while(1){
  if(timers[i] == 0){
   timers[i] = 1;
   a[i].thread_id = i;
   a[i].t = (rand() % 50) * 100000 + 400000;
   printf("Create time %i, sleep %i\n",i,a[i].t);
   pthread_create(&timer_thread[i], ((void *)0), Test, (void *) &a[i]);
   break;
  }
  i++;
  if(i==5){
   i = 0;
   printf("Not enought timers!!!!!\n\n");
   usleep(100000);
  }
 }
}

# 1 "./src/algorithm.c" 1
void procces(struct adr adr,int debug){
 if(adr.S == 0){
  if(blocks[adr.M][adr.B][adr.S]->blocked == 0){
   blocks[adr.M][adr.B][adr.S]->train = 0;
  }

   struct Seg *BA = blocks[adr.M][adr.B][adr.S];
   if(BA->train != 0){

   }






 }
 else{


  struct adr bl[4] = {0};
  struct adr bp,bp2;
  bl[0] = adr;
  int i = 0;
  int p = 0;
  struct Seg B;

  for(i = 0;i<4;i){
   B = *blocks[bl[i].M][bl[i].B][bl[i].S];
   i++;

   if(NADR(B.Adr).type == 'e' && B.Adr.S != 0){
    break;
   }else if(NADR(B.Adr).type == 's' || NADR(B.Adr).type == 'S' || NADR(B.Adr).type == 'm' || NADR(B.Adr).type == 'M'){

    if(!check_Switch(B.Adr,0)){

     break;
    }
   }
   bl[i] = Next(adr,i)->Adr;
  }
  i--;


  if(check_Switch(adr,1)){
   bp = Prev(adr,1)->Adr;
   p = 1;
  }
  if(bp.S != 0 && p == 1 && check_Switch(bp,1) == 1){
   bp2 = Prev(adr,2)->Adr;
   p = 2;
  }

  struct Seg *BA = blocks[bl[0].M][bl[0].B][bl[0].S];
  struct Seg *BPP;
  struct Seg *BP;
  struct Seg *BN;
  struct Seg *BNN;
  struct Seg *BNNN;

  if(i > 0){
   BN = blocks[bl[1].M][bl[1].B][bl[1].S];
  }

  if(i > 1){
   BNN = blocks[bl[2].M][bl[2].B][bl[2].S];
  }

  if(i > 2){
   BNNN = blocks[bl[3].M][bl[3].B][bl[3].S];
  }

  if(p > 0){
   BP = blocks[bp.M][bp.B][bp.S];
  }

  if(p > 1){
   BPP = blocks[bp2.M][bp2.B][bp2.S];
  }
# 94 "./src/algorithm.c"
   if(!BA->blocked && BA->train != 0){


    BA->train = 0;
   }
   if(i > 0 && BA->blocked && !BP->blocked && BN->train && !BA->train){

    BA->dir ^= 0b100;

   }
   else if(p > 0 && i > 0 && BA->blocked && BA->train == 0 && BN->train == 0 && BP->train == 0){

     BA->train = ++bTrain;

     Web_Link_Train(0,bTrain,BA->Adr);
   }
   else if(p > 0 && i > 0 && BN->blocked && BP->blocked && BN->train == BP->train){

    Web_Train_Split(0,BN->train,BN->Adr);
   }
   if(p > 0 && BP->blocked && BA->blocked && BA->train == 0){
    BA->train = BP->train;
   }
   if(i > 0 && BN->train == 0 && BN->blocked && BA->blocked){
    BN->train = BA->train;
   }
   if(i > 1 && BNN->train == 0 && BNN->blocked && BN->blocked){
    BNN->train = BN->train;
   }




   if(i > 0 && (NADR(BN->Adr).type == 's' || NADR(BN->Adr).type == 'S' || NADR(BN->Adr).type == 'm' || NADR(BN->Adr).type == 'M') && BA->blocked){
    if(!check_Switch(BN->Adr,0)){
     if(free_Switch(BN->Adr,0)){
      if(i < 2){
       BNN = Next(BN->Adr,1);
       BNNN = Next(BN->Adr,2);
       i = 3;
      }
      if(BNN->state != 5){
       if(Adr_Comp(NADR(BN->Adr),BN->Adr)){
        change_block_state(BN,5);
        if(i > 1 && BNN->Adr.S == 0){
         change_block_state(BNN,5);
        }
       }else{
        change_block_state(BNN,5);
        if(i > 2 && BNNN->Adr.S == 0){
         change_block_state(BNNN,5);
        }
       }
      }
     }
    }else{
     if(BNN->state != 5){
      if(Adr_Comp(NADR(BN->Adr),BN->Adr)){

       change_block_state(BN,5);
       if(i > 1 && BNN->Adr.S == 0){
        change_block_state(BNN,5);
       }
      }else{
       change_block_state(BNN,5);
       if(i > 2 && BNNN->Adr.S == 0){
        change_block_state(BNNN,5);
       }
      }
     }
    }
   }
   else if(i > 0 && p > 0 && (NADR(BA->Adr).type == 's' || NADR(BA->Adr).type == 'S' || NADR(BA->Adr).type == 'm' || NADR(BA->Adr).type == 'M') && BP->blocked){
    if(!check_Switch(BA->Adr,0)){
     if(free_Switch(BA->Adr,0)){
      if(i < 2){
       BN = Next(BA->Adr,1);
       BNN = Next(BA->Adr,2);
       i = 2;
      }
      if(BN->state != 5){
       if(Adr_Comp(NADR(BA->Adr),BA->Adr)){
        change_block_state(BA,5);
        if(i > 1 && BN->Adr.S == 0){
         change_block_state(BN,5);
        }
       }else{
        change_block_state(BN,5);
        if(i > 2 && BNN->Adr.S == 0){
         change_block_state(BNN,5);
        }
       }
      }
     }
    }else{
     if(BN->state != 5){
      if(Adr_Comp(NADR(BA->Adr),BA->Adr)){

       change_block_state(BA,5);
       if(i > 1 && BN->Adr.S == 0){
        change_block_state(BN,5);
       }
      }else{
       change_block_state(BN,5);
       if(i > 2 && BNN->Adr.S == 0){
        change_block_state(BNN,5);
       }
      }
     }
    }
   }




   if(i > 1 && BA->blocked && !dir_Comp(BA,BNN) && BN->Adr.S == 0 && BNN->Adr.S != 0){
    printf("%i:%i:%i:%i <-> %i:%i:%i:%i\t",BA->Adr.M,BA->Adr.B,BA->Adr.S,BA->dir,BNN->Adr.M,BNN->Adr.B,BNN->Adr.S,BNN->dir);
    printf("Reverse in advance 1\n");
    if(BNN->Adr.S == 1){
     for(int a = 1;a<8;a++){
      if(blocks[BNN->Adr.M][BNN->Adr.B][a] != ((void *)0)){
       if(blocks[BNN->Adr.M][BNN->Adr.B][a]->blocked){
        break;
       }
       blocks[BNN->Adr.M][BNN->Adr.B][a]->dir ^= 0b100;
      }
     }
    }else{

     for(int a = 8;0<a;a--){
      if(blocks[BNN->Adr.M][BNN->Adr.B][a] != ((void *)0)){

       if(blocks[BNN->Adr.M][BNN->Adr.B][a]->blocked){
        break;
       }
       blocks[BNN->Adr.M][BNN->Adr.B][a]->dir ^= 0b100;
      }
     }
    }
   }

   if(i > 2 && BA->blocked && !dir_Comp(BA,BNNN) && BN->Adr.S == 0 && BNN->Adr.S == 0 && BNNN->Adr.S != 0){
    printf("%i:%i:%i:%i <-> %i:%i:%i:%i\t",BA->Adr.M,BA->Adr.B,BA->Adr.S,BA->dir,BNNN->Adr.M,BNNN->Adr.B,BNNN->Adr.S,BNNN->dir);
    printf("Reverse in advance 2\n");
    if(BNNN->Adr.S == 1){
     for(int a = 1;a<8;a++){
      if(blocks[BNNN->Adr.M][BNNN->Adr.B][a] != ((void *)0)){
       if(blocks[BNNN->Adr.M][BNNN->Adr.B][a]->blocked){
        break;
       }
       blocks[BNNN->Adr.M][BNNN->Adr.B][a]->dir ^= 0b100;
      }
     }
    }else{

     for(int a = 8;0<a;a--){
      if(blocks[BNNN->Adr.M][BNNN->Adr.B][a] != ((void *)0)){

       if(blocks[BNNN->Adr.M][BNNN->Adr.B][a]->blocked){
        break;
       }
       blocks[BNNN->Adr.M][BNNN->Adr.B][a]->dir ^= 0b100;
      }
     }
    }
   }

   if(i > 0 && BA->blocked && !dir_Comp(BA,BN) && BN->Adr.S != 0 && !BN->blocked){
    printf("%i:%i:%i:%i <-> %i:%i:%i:%i\t",BA->Adr.M,BA->Adr.B,BA->Adr.S,BA->dir,BN->Adr.M,BN->Adr.B,BN->Adr.S,BN->dir);
    printf("Reverse next\n");
    BN->dir ^= 0b100;
   }
# 276 "./src/algorithm.c"
   if(i > 2 && BN->Adr.S == 0 && BNN->Adr.S == 0 && !BN->blocked && (BNN->blocked || BNNN->blocked)){
    change_block_state(BA,1);
   }else if(i > 1 && p > 1 && !dir_Comp(BA,BN) && BNN->blocked && BPP->blocked){
    change_block_state(BA,2);
    change_block_state(BN,1);
    change_block_state(BP,1);
   }
   else if(i > 1 && p > 1 && !dir_Comp(BA,BN) && !BNN->blocked && !BPP->blocked){
    change_block_state(BA,0);
   }
   else if(i > 1 && !dir_Comp(BA,BNN) && BN->Adr.S == 0 && !BNN->blocked && BNN->state == 0){
    change_block_state(BA,0);
   }
   else if(i > 0 && BN->blocked){
    change_block_state(BA,2);
   }
   else if(i > 1 && dir_Comp(BA,BNN) && BNN->blocked && !BN->blocked){
    change_block_state(BA,1);
   }
   else if(i > 2 && dir_Comp(BA,BNN) && !BNN->blocked && !BN->blocked){
    if(BA->state != 5){
     change_block_state(BA,0);
    }
   }
   else if(i == 0){
    change_block_state(BA,1);
   }
   else if(i == 1){
    change_block_state(BA,0);
   }


   if(i > 2 && BN->Adr.S == 0 && BNN->Adr.S == 0 && !BN->blocked && (BNN->blocked || BNNN->blocked)){
    change_block_state(BN,2);
    change_block_state(BNN,2);
   }else if(i > 2 && dir_Comp(BA,BNNN) && BNN->blocked && !BN->blocked){
    change_block_state(BN,2);
   }
   else if(i > 2 && dir_Comp(BA,BNNN) && BNNN->blocked && !BNN->blocked){
    change_block_state(BN,1);
   }
   else if(i > 2 && dir_Comp(BA,BNNN) && !BN->blocked && !BNN->blocked && !BNNN->blocked){
    if(BN->state != 5){
     change_block_state(BN,0);
    }
   }


   if(i > 2 && dir_Comp(BA,BNNN) && BNNN->blocked && !BNN->blocked){
    change_block_state(BNN,2);
   }


   if(i > 2 && p > 0 && BP->blocked && BNNN->blocked && !dir_Comp(BP,BNN)){
    change_block_state(BNN,1);
    change_block_state(BN,2);
    change_block_state(BA,1);
    debug = 1;

   }
   else if(p > 0 && i > 0 && dir_Comp(BN,BP) && !BA->blocked && BN->blocked){
    change_block_state(BP,1);
   }
   else if(p > 0 && i > 0 && dir_Comp(BN,BP) && !BA->blocked && !BN->blocked){
    if(BP->state != 5){
     change_block_state(BP,0);
    }
   }



   if(BA->NSi != ((void *)0)){


    if((BA->dir == 0 || BA->dir == 1 || BA->dir == 2) && !check_Switch(BA->Adr,0) || (BA->dir == 4 || BA->dir == 5 || BA->dir == 6)){
     set_signal(BA->NSi,1);

    }

    if(!(BA->dir == 4 || BA->dir == 5 || BA->dir == 6) && check_Switch(BA->Adr,0) && i > 0){

     if(BN->blocked || BN->state == 2){
      set_signal(BA->NSi,1);
     }else if(BN->state == 4){
      set_signal(BA->NSi,6);
     }else if(BN->state == 1){
      set_signal(BA->NSi,2);
     }else{
      set_signal(BA->NSi,4);
     }
    }
   }

   if(BA->PSi != ((void *)0)){

    if((BA->dir == 4 || BA->dir == 5 || BA->dir == 6) && !check_Switch(BA->Adr,0) || (BA->dir == 0 || BA->dir == 1 || BA->dir == 2)){
     set_signal(BA->PSi,1);

    }

    if(!(BA->dir == 0 || BA->dir == 1 || BA->dir == 2) && check_Switch(BA->Adr,0) && i > 0){

     if(BN->blocked || BN->state == 2){
      set_signal(BA->PSi,1);
     }else if(BN->state == 4){
      set_signal(BA->PSi,6);
     }else if(BN->state == 1){
      set_signal(BA->PSi,2);
     }else{
      set_signal(BA->PSi,4);
     }
    }
   }




   if(digital_track == 1){



    if(BA->blocked && BN->blocked && BA->train != BN->train){

     printf("COLLISION PREVENTION\n\t");
     train_stop(train_link[BA->train]);
    }

    if(((BA->blocked && !BN->blocked && BN->state == 2) || (i == 0 && BA->blocked)) && train_link[BA->train]->timer != 1){

     printf("NEXT SIGNAL: RED\n\tSTOP TRAIN:");
     train_signal(BA,train_link[BA->train],2);
    }

    if(((BA->blocked && !BN->blocked && BN->state == 1) || (i == 1 && BA->blocked && !BN->blocked)) && train_link[BA->train]->timer != 1){

     printf("NEXT SIGNAL: AMBER\n\tSLOWDOWN TRAIN:\t");
     train_signal(BA,train_link[BA->train],1);
    }



    if(i > 0 && !BN->blocked && BA->train != 0 && train_link[BA->train] != ((void *)0) && train_link[BA->train]->timer != 2 && train_link[BA->train]->timer != 1){
     if((BN->state == 0 || BN->state == 5) && train_link[BA->train]->cur_speed < BA->max_speed && BN->max_speed >= BA->max_speed){
      printf("Next block has a higher speed limit (%i > %i)",BN->max_speed,BA->max_speed);
      train_speed(BA,train_link[BA->train],BA->max_speed);
     }
    }


    if(BA->train != 0 && train_link[BA->train] != ((void *)0) && train_link[BA->train]->timer != 2){
     if((BN->state == 0 || BN->state == 5) && train_link[BA->train]->cur_speed > BN->max_speed && BN->Adr.S != 0){
      printf("Next block has a lower speed limit");
      train_speed(BN,train_link[BA->train],BN->max_speed);
     }else if(i > 1 && BN->Adr.S == 0 && BNN->Adr.S != 0 && (BNN->state == 0 || BNN->state == 5) && train_link[BA->train]->cur_speed > BNN->max_speed){
      printf("Block after Switches has a lower speed limit");
      train_speed(BNN,train_link[BA->train],BNN->max_speed);
     }else if(train_link[BA->train]->cur_speed != BN->max_speed && BN->Adr.S != 0){
      printf("%i <= %i\n",train_link[BA->train]->cur_speed,BN->max_speed && BN->Adr.S != 0);
     }
    }



   if(BA->train != 0 && train_link[BA->train] && !Adr_Comp(C_AdrT(0,0,0,'e'),train_link[BA->train]->Destination)){
    if(i > 0 && Adr_Comp(train_link[BA->train]->Destination,BN->Adr)){
     printf("Destination almost reached\n");
     train_signal(BNN,train_link[BA->train],1);
    }else if(Adr_Comp(train_link[BA->train]->Destination,BA->Adr)){
     printf("Destination Reached\n");
     train_signal(BNN,train_link[BA->train],2);
    }
   }

   }



   if(BA->train != 0){

   }
   if(debug){
    if(p > 0){
     printf("\t\tP %i:%i:%i;B:%i\t",BP->Adr.M,BP->Adr.B,BP->Adr.S,BP->blocked);
    }else{
     printf("\t\t          \t");
    }
    printf("A%i %i:%i:%i;T%iD%i",i,adr.M,adr.B,adr.S,BA->train,BA->dir);
    if(BA->blocked){
     printf("B");
    }
    printf("\t");
    if(i > 0){
     printf("N %i:%i:%i;B%iDC%i\t",BN->Adr.M,BN->Adr.B,BN->Adr.S,BN->blocked,dir_Comp(BA,BN));
    }
    if(i > 1){
     printf("NN %i:%i:%i;B%iDC%i\t",BNN->Adr.M,BNN->Adr.B,BNN->Adr.S,BNN->blocked,dir_Comp(BA,BNN));
    }
    if(i > 2){
     printf("NNN %i:%i:%i;B%iDC%i\t",BNNN->Adr.M,BNNN->Adr.B,BNNN->Adr.S,BNNN->blocked,dir_Comp(BA,BNNN));
    }

     printf("\n");

   }
 }
}
# 937 "baan.c" 2
# 1 "./src/pathfinding.c" 1
int pathFinding(struct adr Begin, struct adr End, struct Sw_PATH *(OUT_Sw_Nodes)[200]){
 struct adr NAdr,SNAdr,Adr = Begin;
 struct Sw_A_PATH * Sw_Nodes[200] = {((void *)0)};
 int nr_switches = 0;
 struct Sw_A_PATH * Prev_PATH_Node = ((void *)0);
 struct Sw_A_PATH * Curr_PATH_Node = ((void *)0);

 char list_of_M[16] = {0};

 _Bool init = (1==1);
 _Bool found = (!(1==1));

 int a = 0;

 printf("S\t%i:%i:%i\ttype:%c\n",Adr.M,Adr.B,Adr.S,Adr.type);

 int direct = blocks[Adr.M][Adr.B][Adr.S]->dir;
 char prev_dir = direct;
 Next_Adr:{};

 if(Adr.type == 'e'){
  goto Next_Switch;
 }

 char dir = blocks[Adr.M][Adr.B][Adr.S]->dir;

 if(prev_dir == 0 && dir == 1){
  prev_dir ^= 0x80;
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
 }
 else if(prev_dir == 1 && dir == 0){
  prev_dir ^= 0x80;
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
 }
 else if(prev_dir == 129 && dir == 0){
  prev_dir ^= 0x80;
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
 }
 else if(prev_dir == 128 && dir == 1){
  prev_dir ^= 0x80;
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
 }
 else if((prev_dir >> 7) == 1){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
  }else{
   NAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
  }
 }
 else if(dir == 0 || dir == 2 || dir == 5){
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->NAdr;
 }
 else{
  NAdr = blocks[Adr.M][Adr.B][Adr.S]->PAdr;
 }

 prev_dir = (prev_dir & 0xC0) + (dir & 0xF);

 Next_Switch:{};




 if(NAdr.M == End.M && NAdr.B == End.B && NAdr.S == End.S){

  FOUND:{}



  for(int i = 0;i<200;i++){
   if(Sw_Nodes[i]){
    for(int j = 0;j<10;j++){
     if(Sw_Nodes[i]->suc[j] == 1){
      Sw_Nodes[i]->suc[j] = 2;
     }
    }
    _Bool A = (!(1==1));
    for(int k = 0;k<16;k++){
     if(list_of_M[k] == 0 || list_of_M[k] == Sw_Nodes[i]->adr.M){
      list_of_M[k] = Sw_Nodes[i]->adr.M;
      break;
     }
    }
   }else{
    break;
   }
  }
  found = (1==1);

  for(int i = 0;i<200;i++){

   if(Sw_Nodes[i] != ((void *)0)){

    if(Sw_Nodes[i]->adr.type == 'S' && (Sw_Nodes[i]->suc[0] == 0 || Sw_Nodes[i]->suc[1] == 0)){
     Curr_PATH_Node = Sw_Nodes[i];
          NAdr = Adr = Curr_PATH_Node->adr;
          dir = prev_dir = Curr_PATH_Node->dir;
     printf("Retrying %i:%i:%i\n",NAdr.M,NAdr.B,NAdr.S);
     usleep(1000);
     goto Next_Switch;
    }else if((Sw_Nodes[i]->adr.type == 'm' || Sw_Nodes[i]->adr.type == 'M')){
     printf("Test Moduls\n");
# 115 "./src/pathfinding.c"
    }
   }else{
    break;
   }
  }
  printf("FOUND the route\n");
  goto DONE;
  return 1;
 }
 usleep(2000);





 if(NAdr.type == 'e' || (NAdr.type == 'R') && blocks[NAdr.M][NAdr.B][NAdr.S]->oneWay == 1 && (char)(dir + (prev_dir & 0x80)) != blocks[NAdr.M][NAdr.B][NAdr.S]->dir){
    if(NAdr.type == 'e'){

    }else{

    }
  goto FAIL;
 }
 else if(NAdr.M == Begin.M && NAdr.B == Begin.B && NAdr.S == Begin.S){

  goto FAIL;
 }
 else if(NAdr.type == 'R'){
  Adr = NAdr;
  goto Next_Adr;
 }
 else if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'm' || NAdr.type == 'M'){

  if(blocks[NAdr.M][NAdr.B][0] != ((void *)0)){
   a++;
  }
  if(NAdr.type == 'S'){

   goto New_S_Node;
   Ret_S_Node:{}

   if(Curr_PATH_Node != ((void *)0)){
    if(Curr_PATH_Node->suc[0] == 1){

     SNAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->Str;
    }else if(Curr_PATH_Node->suc[1] == 1){

     SNAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->Div;
    }
   }
  }
  else if(NAdr.type == 's'){
   SNAdr = Switch[NAdr.M][NAdr.B][NAdr.S]->App;

  }
  else if(NAdr.type == 'M'){
   goto New_M_Node;
   Ret_M_Node:{}

   if(Curr_PATH_Node != ((void *)0)){
    for(int i = 0;i<Moduls[NAdr.M][NAdr.B][NAdr.S]->length;i++){
     if(Curr_PATH_Node->suc[i] == 1){

      SNAdr = Moduls[NAdr.M][NAdr.B][NAdr.S]->mAdr[i];
      break;
     }
    }
   }
  }
  else if(NAdr.type == 'm'){
   goto New_M_Node;
   Ret_m_Node:{}

   if(Curr_PATH_Node != ((void *)0)){
    for(int i = 0;i<Moduls[NAdr.M][NAdr.B][NAdr.S]->length;i++){
     if(Curr_PATH_Node->suc[i] == 1){

      SNAdr = Moduls[NAdr.M][NAdr.B][NAdr.S]->MAdr[i];
     }
    }
   }
  }

  if(SNAdr.type == 'S' || SNAdr.type == 's'){
   NAdr = SNAdr;
   goto Next_Switch;
  }else if(SNAdr.type == 'M' || SNAdr.type == 'm'){
   NAdr = SNAdr;
   goto Next_Switch;

  }else{
   Adr = SNAdr;

   NAdr = Adr;
   goto Next_Switch;
  }
 }else{
  printf("\n\n!!!!!!!!!UNKOWN RAIL TYPE!!!!!\n\n");
 }
  printf("Return 0\n");
 return 0;

 FAIL:{
  if(Curr_PATH_Node != ((void *)0)){

      if(Curr_PATH_Node->adr.type == 'S'){
        if(Curr_PATH_Node->suc[0] == 1){
          Curr_PATH_Node->suc[0] = -1;
         Curr_PATH_Node->suc[1] = 1;
     NAdr = Curr_PATH_Node->adr;
     dir = prev_dir = Curr_PATH_Node->dir;

     if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){

      goto Next_Switch;
     }else{
      goto Next_Adr;
     }
        }else if(Curr_PATH_Node->suc[1] == 1){
          Curr_PATH_Node->suc[1] = -1;

        }else if(Curr_PATH_Node->suc[0] == 2 || Curr_PATH_Node->suc[1] == 2){
     if(!Curr_PATH_Node->Prev){
      goto NOT_FOUND;
     }else if(found == (1==1)){
      goto FOUND;
     }
    }
      }
   else{
     for(int i = 0;i<10;i++){
      if(Curr_PATH_Node->suc[i] == 1){
       Curr_PATH_Node->suc[i] = -1;
      if((i+1) < Moduls[Curr_PATH_Node->adr.M][Curr_PATH_Node->adr.B][Curr_PATH_Node->adr.S]->length){
        Curr_PATH_Node->suc[i+1] = 1;
      }
       NAdr = Curr_PATH_Node->adr;
       dir = prev_dir = Curr_PATH_Node->dir;

       if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){

        goto Next_Switch;
       }else{

        goto Next_Adr;
       }
      }
     }
      }
   Curr_PATH_Node = Curr_PATH_Node->Prev;
   goto FAIL;
  }
 }

 printf("Return FAIL\n");
 return 0;

 New_S_Node:{

  if((Curr_PATH_Node && !Adr_Comp(Curr_PATH_Node->adr,NAdr)) || !Curr_PATH_Node){
   if(Sw_Nodes[0] != ((void *)0) && Adr_Comp(Sw_Nodes[0]->adr,NAdr)){


    if(Curr_PATH_Node != ((void *)0)){
     for(int i = 0;i<10;i++){
      if(Curr_PATH_Node->suc[i] == 1){
       Curr_PATH_Node->suc[i] = -1;
       NAdr = Curr_PATH_Node->adr;
       dir = Curr_PATH_Node->dir;
       prev_dir = dir;
       if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
        goto Next_Switch;
       }else{
        goto Next_Adr;
       }
      }
     }
    }
   }
   else if(found == (1==1)){

    for(int i = 0;i<16;i++){
     if(list_of_M[i] == NAdr.M){
      break;
     }

     if((i+1) == 16){
      if(Curr_PATH_Node != ((void *)0)){
       for(int i = 0;i<10;i++){
        if(Curr_PATH_Node->suc[i] == 1){
         Curr_PATH_Node->suc[i] = -1;
         NAdr = Curr_PATH_Node->adr;
         dir = Curr_PATH_Node->dir;
         prev_dir = dir;
         if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
          goto Next_Switch;
         }else{
          goto Next_Adr;
         }
        }
       }
       if(found == (1==1)){
        goto FOUND;
       }
       Curr_PATH_Node = Curr_PATH_Node->Prev;
      }
     }
    }

    for(int i = 0;i<200;i++){
     if(Sw_Nodes[i] != ((void *)0) && Adr_Comp(Sw_Nodes[i]->adr,NAdr)){

      if(Sw_Nodes[i]->adr.type == 'S'){

       if(Sw_Nodes[i]->suc[0] == -1 && Sw_Nodes[i]->suc[1] == -1){

        goto FAIL;
       }
      }
      goto FOUND;
      break;
     }
    }
   }



   struct Sw_A_PATH * Z = (struct Sw_A_PATH *)malloc(sizeof(struct Sw_A_PATH));

   Z->adr = NAdr;
   Z->length = 2;
   memset(Z->suc,0,10);
   Z->suc[0] = 1;
   Z->dir = dir + (prev_dir & 0x80);
   Z->Prev = Curr_PATH_Node;

   for(int i = 0;i<200;i++){
    if(Sw_Nodes[i] == ((void *)0)){

     Sw_Nodes[i] = Z;

     break;
    }else{

    }
   }

   Curr_PATH_Node = Z;
  }
  else if(Curr_PATH_Node != ((void *)0) && Adr_Comp(Curr_PATH_Node->adr,NAdr)){

   if(Curr_PATH_Node->suc[0] != 0 && Curr_PATH_Node->suc[0] != 1){
    if(Curr_PATH_Node->suc[1] == 0){

     Curr_PATH_Node->suc[1] = 1;
    }else if(Curr_PATH_Node->suc[1] == -1){
     goto FAIL;
    }
   }
  }
  goto Ret_S_Node;
 }

 printf("Return New_S_Node\n");
 return 0;

 New_M_Node:{

  if((Curr_PATH_Node && !Adr_Comp(Curr_PATH_Node->adr,NAdr)) || !Curr_PATH_Node){
   if(Sw_Nodes[0] != ((void *)0) && Adr_Comp(Sw_Nodes[0]->adr,NAdr)){


    if(Curr_PATH_Node != ((void *)0)){
     for(int i = 0;i<10;i++){
      if(Curr_PATH_Node->suc[i] == 1){
       Curr_PATH_Node->suc[i] = -1;
       NAdr = Curr_PATH_Node->adr;
       dir = Curr_PATH_Node->dir;
       prev_dir = dir;
       if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
        goto Next_Switch;
       }else{
        goto Next_Adr;
       }
      }
     }
    }
   }
   else if(found == (1==1)){

    for(int i = 0;i<16;i++){
     if(list_of_M[i] == NAdr.M){
      break;
     }

     if((i+1) == 16){
      if(Curr_PATH_Node != ((void *)0)){
       for(int i = 0;i<10;i++){
        if(Curr_PATH_Node->suc[i] == 1){
         Curr_PATH_Node->suc[i] = -1;
         NAdr = Curr_PATH_Node->adr;
         dir = Curr_PATH_Node->dir;
         prev_dir = dir;
         if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
          printf("Next_Switch\n");
          goto Next_Switch;
         }else{
          goto Next_Adr;
         }
        }
       }
       if(found == (1==1)){
        goto FOUND;
       }
       Curr_PATH_Node = Curr_PATH_Node->Prev;
      }
     }
    }
   }

   for(int i = 0;i<200;i++){
    if(Sw_Nodes[i] != ((void *)0) && Adr_Comp(Sw_Nodes[i]->adr,NAdr)){
     printf("Allready known Node\n");
     if(Sw_Nodes[i]->adr.type == 'S'){
      printf("It a switch\t");
      if(Sw_Nodes[i]->suc[0] == -1 && Sw_Nodes[i]->suc[1] == -1){
       printf("Both have no route\t");
       goto FAIL;
      }
     }else if(Sw_Nodes[i]->adr.type == 'M' || Sw_Nodes[i]->adr.type == 'm'){
      printf("It a MS switch\t");
      _Bool NoSucc = (1==1);
      for(int i = 0;i<Moduls[Sw_Nodes[i]->adr.M][Sw_Nodes[i]->adr.B][Sw_Nodes[i]->adr.S]->length;i++){
       if(Sw_Nodes[i]->suc[i] == 2){
        NoSucc = (!(1==1));
        break;
       }
      }
      if(NoSucc == (1==1)){
       printf("No route\t");
       goto FAIL;
      }
     }
     goto FOUND;
     break;
    }
   }



   struct Sw_A_PATH * Z = (struct Sw_A_PATH *)malloc(sizeof(struct Sw_A_PATH));

   Z->adr = NAdr;
   Z->length = 2;
   memset(Z->suc,0,10);
   Z->suc[0] = 1;
   Z->dir = prev_dir;
   Z->Prev = Curr_PATH_Node;

   for(int i = 0;i<200;i++){
    if(Sw_Nodes[i] == ((void *)0)){
     printf("%i",i);
     Sw_Nodes[i] = Z;
     break;
    }
   }

   Curr_PATH_Node = Z;
  }
  else if(Curr_PATH_Node != ((void *)0) && Adr_Comp(Curr_PATH_Node->adr,NAdr)){

   for(int i = 0;i<Moduls[NAdr.M][NAdr.B][NAdr.S]->length;i++){
    if(Curr_PATH_Node->suc[i] == 0){

     Curr_PATH_Node->suc[i] = 1;
    }else if(Curr_PATH_Node->suc[i] == -1 && (i+1) == Moduls[NAdr.M][NAdr.B][NAdr.S]->length){

     Curr_PATH_Node = Curr_PATH_Node->Prev;
     NAdr = Curr_PATH_Node->adr;
     if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
      goto Next_Switch;
     }else{
      goto Next_Adr;
     }
    }
   }
  }
  if(NAdr.type == 'M'){
   goto Ret_M_Node;
  }else{
   goto Ret_m_Node;
  }
 }

 printf("Return New_S_Node\n");
 return 0;

 NOT_FOUND:{}


 printf("Return NOT_FOUND\n");
 return 0;

 DONE:{}

 printf("All Switches:\n");

 int k = 0;

 for(int i = 0;i<200;i++){
  if(Sw_Nodes[i] != ((void *)0)){
   _Bool A = (!(1==1));
   for(int j = 0;j<10;j++){
    if(Sw_Nodes[i]->suc[j] == 2){
     A = (1==1);
    }
   }
   if(A){
    printf("\n%i\t%i:%i:%i:%c  \t",k,Sw_Nodes[i]->adr.M,Sw_Nodes[i]->adr.B,Sw_Nodes[i]->adr.S,Sw_Nodes[i]->adr.type);
    for(int j = 0;j<10;j++){
     if(Sw_Nodes[i]->suc[j] == 0){
      break;
     }
     printf("%d\t",Sw_Nodes[i]->suc[j]);
    }
    struct Sw_PATH * Z = (struct Sw_PATH *)malloc(sizeof(struct Sw_PATH));
    Z->adr = Sw_Nodes[i]->adr;
    for(int l = 0;l<10;l++){
     Z->suc[l] = Sw_Nodes[i]->suc[l];
    }
    *OUT_Sw_Nodes++ = Z;
   }
  }else{
   break;
  }
 }

 return 1;
}
# 938 "baan.c" 2

void *do_Magic(){
 while(!stop){

  clock_t t;
  t = clock();
  pthread_mutex_lock(&mutex_lockA);
  for(int i = 0;i<strlen(List_of_Modules);i++){
   printf("R%i ",List_of_Modules[i]);
   struct COM_t C;
   memset(C.Data,0,32);
   C.Adr = List_of_Modules[i];
   C.Opcode = 6;
   C.Length = 0;

   pthread_mutex_lock(&mutex_UART);
   COM_Send(C);
   char COM_data[20];
   memset(COM_data,0,20);
   COM_Recv(COM_data);
   usleep(10000);
   pthread_mutex_unlock(&mutex_UART);
  }
  printf("\n");


  for(int i = 0;i<B_list_i;i++){

   procces(Block_list[i],1);
  }
  JSON();
  pthread_mutex_unlock(&mutex_lockA);
  t = clock() - t;
# 979 "baan.c"
  usleep(100000);
 }
}

void do_once_Magic(){
 pthread_mutex_lock(&mutex_lockA);
 for(int i = 0;i<B_list_i;i++){

  procces(Block_list[i],0);
 }
 COM_change_A_signal(4);
 COM_change_A_switch(4);
 JSON();
 pthread_mutex_unlock(&mutex_lockA);
}

void *STOP_FUNC(){

 while(!stop){
  printf("Type q{Enter} to stop\n");

  int r;
  unsigned char c;
    if ((r = read(0, &c, sizeof(c))) < 0) {
        continue;
    } else {
        if(c == 'q'){
     stop = 1;
     break;
    }
    }
 }
 printf("STOPPING...\n");
}

void *clear_timers(){
 while(!stop){
  for(int i = 0;i<5;i++){
   if(timers[i] == 2){
    pthread_join(timer_thread[i], ((void *)0));
    timers[i] = 0;
    printf("Reset time %i\n",i);
   }
  }
  usleep(10000);
 }
}

void main(){
 setbuf(stdout,((void *)0));
 setbuf(stderr,((void *)0));

 wiringPiSetup();

 pinMode(0, 1);
 pinMode(1, 1);
 digitalWrite(0,0);
 digitalWrite(1,0);


  printf("\n\n                o  o   o\n");
  printf("            O  o  o\n");
  printf("        o oO  o\n");
  printf("      OoO\n");
  printf("     oOo ___             __________  ___________  ___________  __-----__\n");
  printf("    _\\/__|_|_  _,oo.,_  | |.\\/.| |  |         |  | EXPRESS |  ||_| |_||\n");
  printf("   [=      _|--|______|--|_|_/\\_|_|--|_________|--|_________|--|_______|\n");
  printf("   //o--=OOO-  o  o  o    o  o     o  o     o  o   o\n");

  printf("----------------------------------------------------------------------------\n");
  printf("|                                                                          |\n");
  printf("|                         RASPBERRY RAIL SOFTWARE                          |\n");
  printf("|                               is booting                                 |\n");
  printf("|                                                                          |\n");
  printf("----------------------------------------------------------------------------\n");
  printf("|                                                                          |\n");


  printf("----------------------------------------------------------------------------\n");
  printf("|                                                                          |\n");
  printf("|                               Web server                                 |\n");
  printf("|                                                                          |\n");
  pthread_t thread_web_server;
  pthread_create(&thread_web_server, ((void *)0), web_server, ((void *)0));
  usleep(100000);

  printf("|                                  UART                                    |\n");
  printf("|                                                                          |\n");

  pthread_t thread_UART;
  pthread_create(&thread_UART, ((void *)0), UART, ((void *)0));
  usleep(100000);

  printf("|                          Z21@%s:%i\t                   |\n","192.168.2.92",4129);
  printf("|                                                                          |\n");

  pthread_t thread_Z21_client;


  usleep(100000);

  blocks[0][0][0] = C_Seg(0,C_AdrT(0,0,0,'e'),3);
  blocks[0][0][0]->NAdr.type = 'e';
  blocks[0][0][0]->PAdr.type = 'e';

  printf("|                              BLOCK LINKING                               |\n");
  printf("|                                                                          |\n");

  struct link LINK;
  struct link LINK2;
  LINK.Adr1 = C_AdrT(0,0,0,'e');
  LINK.Adr2 = C_AdrT(0,0,0,'e');
  LINK.Adr3 = C_AdrT(0,0,0,'e');
  LINK.Adr4 = C_AdrT(0,0,0,'e');
  LINK2.Adr1 = C_AdrT(0,0,0,'e');
  LINK2.Adr2 = C_AdrT(0,0,0,'e');
  int nr_Modules = 0;
  usleep(100000);
  digitalWrite(1,1);

  int setup[16] = {1,8,4,5,12,2,0};
  int setup2[5] = {11,6,7,0};

  for(int i = 0;i<4;i++){
   char Line_Data[25];
   memset(Line_Data,0,25);
   int L = COM_Recv(Line_Data);
   if(L == 3 && Line_Data[0] == 0 && (Line_Data[1] & 0xF) == 0){
    printf("|                            Module %i\t found                             |\n",Line_Data[2]);

    LINK = Modules(Line_Data[2],LINK);
    if(!Adr_Comp(LINK.Adr3,C_AdrT(0,0,0,'e'))){
     printf("Branch needed\n");
     LINK2.Adr1 = LINK.Adr3;
     LINK2.Adr2 = LINK.Adr4;
    }

    setup[i] = Line_Data[2];
    List_of_Modules[nr_Modules++] = Line_Data[2];
   }else{
    printf("Wrong data length recieved: %i\n",L);
    for(int i = 0;i<L;i++){
     printf("[%i]",Line_Data[i]);
    }
    printf("\n");
   }
  }

  if(!Adr_Comp(LINK2.Adr1,C_AdrT(0,0,0,'e'))){
   printf("|                                                                          |\n");
   printf("|                               Branch one                                 |\n");
  }

  for(int i = 0;i<0;i++){
   printf("|                            Module %i\t found                             |\n",setup2[i]);
   LINK2 = Modules(setup2[i],LINK2);
  }
  setup_JSON(setup,setup2,4,0);
  usleep(1000000);

  printf("|                                                                          |\n");
  printf("|                             Loading trains                               |\n");
  printf("|                                                                          |\n");

  init_trains();

 printf("|                                                                          |\n");
 printf("----------------------------------------------------------------------------\n\n");
 printf("                              STARTUP COMPLETE\n\n\n");


 do_once_Magic();

 delay(5);
# 1206 "baan.c"
 startup = 1;


 if(connected_clients == 0){
  printf("                   Waiting until for a client connects\n");
 }
 while(connected_clients == 0){
  usleep(1000000);
 }
 initialise = 0;

 usleep(400000);

 pthread_t tid[10];
# 1273 "baan.c"
 printf("Test octal: 023 = %i\n",023);


  struct adr A = {4,3,2,'R'};
  struct adr B = {7,7,3,'R'};

  struct Sw_PATH * (Route)[200] = {((void *)0)};


  train_set_path(trains[4],A,B);




 printf("Creating Threads\n");
 pthread_create(&tid[0], ((void *)0), do_Magic, ((void *)0));
 pthread_create(&tid[1], ((void *)0), STOP_FUNC, ((void *)0));
 pthread_create(&tid[2], ((void *)0), clear_timers, ((void *)0));

 pthread_create(&tid[3], ((void *)0), TRAIN_SIMA, ((void *)0));
 pthread_create(&tid[4], ((void *)0), TRAIN_SIMB, ((void *)0));
# 1309 "baan.c"
 pthread_join(tid[0],((void *)0));
 printf("Magic JOINED\n");
 pthread_join(tid[1],((void *)0));
 printf("STOP JOINED\n");
 pthread_join(tid[2],((void *)0));
 printf("Timer JOINED\n");
 pthread_join(tid[3],((void *)0));
 printf("SimA JOINED\n");
 pthread_join(tid[4],((void *)0));
 printf("SimB JOINED\n");
 pthread_join(thread_UART,((void *)0));
 pthread_join(thread_web_server,((void *)0));



 close(uart0_filestream);

 printf("STOPPED");

}
