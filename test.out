# 1 "baan.c"
# 1 "/var/www/html/baan/PiRail_pi//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "baan.c"



# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 1 3 4
# 385 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 386 "/usr/include/arm-linux-gnueabihf/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 1 3 4
# 10 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/gnu/stubs-hard.h" 1 3 4
# 11 "/usr/include/arm-linux-gnueabihf/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 3 4
typedef unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/types.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/bits/types.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 121 "/usr/include/arm-linux-gnueabihf/bits/types.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/typesizes.h" 1 3 4
# 122 "/usr/include/arm-linux-gnueabihf/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;


__extension__ typedef int __fsword_t;

__extension__ typedef int __ssize_t;


__extension__ typedef long int __syscall_slong_t;

__extension__ typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 90 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4

# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/arm-linux-gnueabihf/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "/usr/include/stdio.h" 3 4

# 5 "baan.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 324 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/arm-linux-gnueabihf/bits/waitflags.h" 1 3 4
# 50 "/usr/include/arm-linux-gnueabihf/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/arm-linux-gnueabihf/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 1 3 4
# 34 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap-16.h" 1 3 4
# 35 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 2 3 4
# 43 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 74 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/arm-linux-gnueabihf/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 235 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 236 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/arm-linux-gnueabihf/sys/types.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 147 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/sys/select.h" 1 3 4
# 30 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/select.h" 1 3 4
# 31 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
# 22 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
# 30 "/usr/include/arm-linux-gnueabihf/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/arm-linux-gnueabihf/sys/select.h" 2 3 4
# 54 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4

# 106 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/arm-linux-gnueabihf/sys/select.h" 3 4

# 220 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/arm-linux-gnueabihf/sys/sysmacros.h" 3 4

# 223 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/arm-linux-gnueabihf/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 1 3 4
# 37 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
# 144 "/usr/include/arm-linux-gnueabihf/bits/pthreadtypes.h" 3 4
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;

    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/arm-linux-gnueabihf/sys/types.h" 2 3 4



# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/arm-linux-gnueabihf/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4

# 6 "baan.c" 2
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdarg.h" 1 3 4
# 7 "baan.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/environments.h" 1 3 4
# 22 "/usr/include/arm-linux-gnueabihf/bits/environments.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 23 "/usr/include/arm-linux-gnueabihf/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/arm-linux-gnueabihf/bits/confname.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));





extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__));
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1005 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1026 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1091 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1151 "/usr/include/unistd.h" 3 4

# 8 "baan.c" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 1 3 4
# 43 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 2 3 4
# 241 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 311 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4
struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 341 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4





extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);





extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);





extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 396 "/usr/include/arm-linux-gnueabihf/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 54 "/usr/include/arm-linux-gnueabihf/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 76 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 77 "/usr/include/fcntl.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 1 3 4
# 38 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;
    unsigned short int __pad1;

    __ino_t st_ino;



    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned short int __pad2;

    __off_t st_size;



    __blksize_t st_blksize;


    __blkcnt_t st_blocks;
# 72 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 87 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 3 4
    unsigned long int __glibc_reserved4;
    unsigned long int __glibc_reserved5;



  };


struct stat64
  {
    __dev_t st_dev;
    unsigned int __pad1;

    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned int __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;

    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 129 "/usr/include/arm-linux-gnueabihf/bits/stat.h" 3 4
    __ino64_t st_ino;
  };
# 78 "/usr/include/fcntl.h" 2 3 4
# 146 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 156 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 166 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 180 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 191 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 202 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 212 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 248 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 270 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 281 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 292 "/usr/include/fcntl.h" 3 4

# 9 "baan.c" 2
# 1 "/usr/include/termios.h" 1 3 4
# 35 "/usr/include/termios.h" 3 4




# 1 "/usr/include/arm-linux-gnueabihf/bits/termios.h" 1 3 4
# 23 "/usr/include/arm-linux-gnueabihf/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;


struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
# 40 "/usr/include/termios.h" 2 3 4
# 48 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern speed_t cfgetispeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));




extern int tcgetattr (int __fd, struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsetattr (int __fd, int __optional_actions,
        const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));




extern void cfmakeraw (struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsendbreak (int __fd, int __duration) __attribute__ ((__nothrow__ , __leaf__));





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) __attribute__ ((__nothrow__ , __leaf__));



extern int tcflow (int __fd, int __action) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t tcgetsid (int __fd) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/arm-linux-gnueabihf/sys/ttydefaults.h" 1 3 4
# 105 "/usr/include/termios.h" 2 3 4



# 10 "baan.c" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
# 86 "/usr/include/arm-linux-gnueabihf/bits/time.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/timex.h" 1 3 4
# 25 "/usr/include/arm-linux-gnueabihf/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/arm-linux-gnueabihf/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 42 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 11 "baan.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/time.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/time.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/sys/time.h" 2 3 4
# 37 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4

# 55 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 189 "/usr/include/arm-linux-gnueabihf/sys/time.h" 3 4

# 12 "baan.c" 2
# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4




# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_val.h" 1 3 4
# 33 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_valf.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/huge_vall.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/inf.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/nan.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/mathdef.h" 1 3 4
# 26 "/usr/include/arm-linux-gnueabihf/bits/mathdef.h" 3 4
typedef float float_t;

typedef double double_t;
# 46 "/usr/include/math.h" 2 3 4
# 69 "/usr/include/math.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;





extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));







extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow10 (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));






extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));








extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));






extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));








extern int __issignaling (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));




extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 70 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;





extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));







extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __pow10f (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));








extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));






extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));








extern int __issignalingf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));




extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 89 "/usr/include/math.h" 2 3 4
# 132 "/usr/include/math.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/arm-linux-gnueabihf/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                           ;





extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));







extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __pow10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));






extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));








extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));




extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 133 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
extern int signgam;
# 189 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 301 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 326 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);
# 488 "/usr/include/math.h" 3 4

# 13 "baan.c" 2

# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4
# 41 "/usr/include/sched.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 1 3 4
# 72 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));


extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));


extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));











struct __sched_param
  {
    int __sched_priority;
  };
# 118 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 201 "/usr/include/arm-linux-gnueabihf/bits/sched.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 42 "/usr/include/sched.h" 2 3 4







extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));
# 116 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/setjmp.h" 1 3 4
# 34 "/usr/include/arm-linux-gnueabihf/bits/setjmp.h" 3 4
typedef int __jmp_buf[64] __attribute__((__aligned__ (8)));
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 125 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 166 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 201 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 239 "/usr/include/pthread.h" 3 4





extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 505 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 517 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 551 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 691 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;
# 703 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;
# 726 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;
# 739 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 899 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1011 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1055 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1122 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));
# 1170 "/usr/include/pthread.h" 3 4

# 15 "baan.c" 2
# 1 "/usr/include/wiringPi.h" 1 3 4
# 113 "/usr/include/wiringPi.h" 3 4
extern const char *piModelNames [16] ;
extern const char *piRevisionNames [16] ;
extern const char *piMakerNames [16] ;
extern const int piMemorySize [ 8] ;
# 139 "/usr/include/wiringPi.h" 3 4
struct wiringPiNodeStruct
{
  int pinBase ;
  int pinMax ;

  int fd ;
  unsigned int data0 ;
  unsigned int data1 ;
  unsigned int data2 ;
  unsigned int data3 ;

           void (*pinMode) (struct wiringPiNodeStruct *node, int pin, int mode) ;
           void (*pullUpDnControl) (struct wiringPiNodeStruct *node, int pin, int mode) ;
           int (*digitalRead) (struct wiringPiNodeStruct *node, int pin) ;

           void (*digitalWrite) (struct wiringPiNodeStruct *node, int pin, int value) ;

           void (*pwmWrite) (struct wiringPiNodeStruct *node, int pin, int value) ;
           int (*analogRead) (struct wiringPiNodeStruct *node, int pin) ;
           void (*analogWrite) (struct wiringPiNodeStruct *node, int pin, int value) ;

  struct wiringPiNodeStruct *next ;
} ;

extern struct wiringPiNodeStruct *wiringPiNodes ;
# 178 "/usr/include/wiringPi.h" 3 4
extern int wiringPiFailure (int fatal, const char *message, ...) ;



extern struct wiringPiNodeStruct *wiringPiFindNode (int pin) ;
extern struct wiringPiNodeStruct *wiringPiNewNode (int pinBase, int numPins) ;

extern void wiringPiVersion (int *major, int *minor) ;
extern int wiringPiSetup (void) ;
extern int wiringPiSetupSys (void) ;
extern int wiringPiSetupGpio (void) ;
extern int wiringPiSetupPhys (void) ;

extern void pinModeAlt (int pin, int mode) ;
extern void pinMode (int pin, int mode) ;
extern void pullUpDnControl (int pin, int pud) ;
extern int digitalRead (int pin) ;
extern void digitalWrite (int pin, int value) ;
extern unsigned int digitalRead8 (int pin) ;
extern void digitalWrite8 (int pin, int value) ;
extern void pwmWrite (int pin, int value) ;
extern int analogRead (int pin) ;
extern void analogWrite (int pin, int value) ;




extern int wiringPiSetupPiFace (void) ;
extern int wiringPiSetupPiFaceForGpioProg (void) ;



extern int piGpioLayout (void) ;
extern int piBoardRev (void) ;
extern void piBoardId (int *model, int *rev, int *mem, int *maker, int *overVolted) ;
extern int wpiPinToGpio (int wpiPin) ;
extern int physPinToGpio (int physPin) ;
extern void setPadDrive (int group, int value) ;
extern int getAlt (int pin) ;
extern void pwmToneWrite (int pin, int freq) ;
extern void pwmSetMode (int mode) ;
extern void pwmSetRange (unsigned int range) ;
extern void pwmSetClock (int divisor) ;
extern void gpioClockSet (int pin, int freq) ;
extern unsigned int digitalReadByte (void) ;
extern unsigned int digitalReadByte2 (void) ;
extern void digitalWriteByte (int value) ;
extern void digitalWriteByte2 (int value) ;




extern int waitForInterrupt (int pin, int mS) ;
extern int wiringPiISR (int pin, int mode, void (*function)(void)) ;



extern int piThreadCreate (void *(*fn)(void *)) ;
extern void piLock (int key) ;
extern void piUnlock (int key) ;



extern int piHiPri (const int pri) ;



extern void delay (unsigned int howLong) ;
extern void delayMicroseconds (unsigned int howLong) ;
extern unsigned int millis (void) ;
extern unsigned int micros (void) ;
# 16 "baan.c" 2
# 1 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4


# 1 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 1 3 4
# 25 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 1 3 4
# 56 "/usr/include/arm-linux-gnueabihf/bits/uio.h" 3 4



extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


# 29 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 2 3 4
# 39 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;
# 50 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;
# 65 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 77 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 103 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset) ;
# 115 "/usr/include/arm-linux-gnueabihf/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset) ;




# 27 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 29 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
# 32 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4






# 1 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4
# 38 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/socket_type.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4
# 146 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/arm-linux-gnueabihf/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 147 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 162 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 272 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));
# 299 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};
# 345 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/arm-linux-gnueabihf/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/socket.h" 2 3 4
# 346 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 2 3 4
# 379 "/usr/include/arm-linux-gnueabihf/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 39 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 90 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
typedef union { struct sockaddr *__restrict __sockaddr__; struct sockaddr_at *__restrict __sockaddr_at__; struct sockaddr_ax25 *__restrict __sockaddr_ax25__; struct sockaddr_dl *__restrict __sockaddr_dl__; struct sockaddr_eon *__restrict __sockaddr_eon__; struct sockaddr_in *__restrict __sockaddr_in__; struct sockaddr_in6 *__restrict __sockaddr_in6__; struct sockaddr_inarp *__restrict __sockaddr_inarp__; struct sockaddr_ipx *__restrict __sockaddr_ipx__; struct sockaddr_iso *__restrict __sockaddr_iso__; struct sockaddr_ns *__restrict __sockaddr_ns__; struct sockaddr_un *__restrict __sockaddr_un__; struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __SOCKADDR_ARG __attribute__ ((__transparent_union__));


typedef union { const struct sockaddr *__restrict __sockaddr__; const struct sockaddr_at *__restrict __sockaddr_at__; const struct sockaddr_ax25 *__restrict __sockaddr_ax25__; const struct sockaddr_dl *__restrict __sockaddr_dl__; const struct sockaddr_eon *__restrict __sockaddr_eon__; const struct sockaddr_in *__restrict __sockaddr_in__; const struct sockaddr_in6 *__restrict __sockaddr_in6__; const struct sockaddr_inarp *__restrict __sockaddr_inarp__; const struct sockaddr_ipx *__restrict __sockaddr_ipx__; const struct sockaddr_iso *__restrict __sockaddr_iso__; const struct sockaddr_ns *__restrict __sockaddr_ns__; const struct sockaddr_un *__restrict __sockaddr_un__; const struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));





struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;

  };






extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 137 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);



extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, __CONST_SOCKADDR_ARG __addr,
         socklen_t __addr_len);
# 174 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, __SOCKADDR_ARG __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);







extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);







extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);







extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       const struct timespec *__tmo);






extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 243 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int accept (int __fd, __SOCKADDR_ARG __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 261 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));
# 283 "/usr/include/arm-linux-gnueabihf/sys/socket.h" 3 4

# 17 "baan.c" 2
# 1 "/usr/include/netinet/in.h" 1 3 4
# 22 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wchar.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 128 "/usr/include/stdint.h" 3 4
typedef unsigned int uintptr_t;
# 137 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 10 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stdint.h" 2 3 4
# 23 "/usr/include/netinet/in.h" 2 3 4







typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/arm-linux-gnueabihf/bits/in.h" 1 3 4
# 112 "/usr/include/arm-linux-gnueabihf/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 209 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 237 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 374 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/arm-linux-gnueabihf/bits/byteswap.h" 1 3 4
# 386 "/usr/include/netinet/in.h" 2 3 4
# 501 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 531 "/usr/include/netinet/in.h" 3 4
struct cmsghdr;


struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));



extern socklen_t inet6_rth_space (int __type, int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_reverse (const void *__in, void *__out) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_segments (const void *__bp) __attribute__ ((__nothrow__ , __leaf__));
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     __attribute__ ((__nothrow__ , __leaf__));





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));



# 18 "baan.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 110 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 166 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "/usr/include/string.h" 3 4

# 236 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 277 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 373 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 604 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4

# 19 "baan.c" 2
# 1 "/usr/include/openssl/sha.h" 1 3 4
# 62 "/usr/include/openssl/sha.h" 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 63 "/usr/include/openssl/sha.h" 2 3 4
# 1 "/usr/include/openssl/e_os2.h" 1 3 4
# 56 "/usr/include/openssl/e_os2.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/openssl/opensslconf.h" 1 3 4
# 57 "/usr/include/openssl/e_os2.h" 2 3 4
# 64 "/usr/include/openssl/sha.h" 2 3 4
# 100 "/usr/include/openssl/sha.h" 3 4
typedef struct SHAstate_st {
    unsigned int h0, h1, h2, h3, h4;
    unsigned int Nl, Nh;
    unsigned int data[16];
    unsigned int num;
} SHA_CTX;





int SHA_Init(SHA_CTX *c);
int SHA_Update(SHA_CTX *c, const void *data, size_t len);
int SHA_Final(unsigned char *md, SHA_CTX *c);
unsigned char *SHA(const unsigned char *d, size_t n, unsigned char *md);
void SHA_Transform(SHA_CTX *c, const unsigned char *data);





int SHA1_Init(SHA_CTX *c);
int SHA1_Update(SHA_CTX *c, const void *data, size_t len);
int SHA1_Final(unsigned char *md, SHA_CTX *c);
unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md);
void SHA1_Transform(SHA_CTX *c, const unsigned char *data);
# 134 "/usr/include/openssl/sha.h" 3 4
typedef struct SHA256state_st {
    unsigned int h[8];
    unsigned int Nl, Nh;
    unsigned int data[16];
    unsigned int num, md_len;
} SHA256_CTX;






int SHA224_Init(SHA256_CTX *c);
int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);
int SHA224_Final(unsigned char *md, SHA256_CTX *c);
unsigned char *SHA224(const unsigned char *d, size_t n, unsigned char *md);
int SHA256_Init(SHA256_CTX *c);
int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);
int SHA256_Final(unsigned char *md, SHA256_CTX *c);
unsigned char *SHA256(const unsigned char *d, size_t n, unsigned char *md);
void SHA256_Transform(SHA256_CTX *c, const unsigned char *data);
# 183 "/usr/include/openssl/sha.h" 3 4
typedef struct SHA512state_st {
    unsigned long long h[8];
    unsigned long long Nl, Nh;
    union {
        unsigned long long d[16];
        unsigned char p[(16*8)];
    } u;
    unsigned int num, md_len;
} SHA512_CTX;







int SHA384_Init(SHA512_CTX *c);
int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);
int SHA384_Final(unsigned char *md, SHA512_CTX *c);
unsigned char *SHA384(const unsigned char *d, size_t n, unsigned char *md);
int SHA512_Init(SHA512_CTX *c);
int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);
int SHA512_Final(unsigned char *md, SHA512_CTX *c);
unsigned char *SHA512(const unsigned char *d, size_t n, unsigned char *md);
void SHA512_Transform(SHA512_CTX *c, const unsigned char *data);
# 20 "baan.c" 2
# 1 "/usr/include/openssl/md5.h" 1 3 4
# 62 "/usr/include/openssl/md5.h" 3 4
# 1 "/usr/include/openssl/e_os2.h" 1 3 4
# 56 "/usr/include/openssl/e_os2.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/openssl/opensslconf.h" 1 3 4
# 57 "/usr/include/openssl/e_os2.h" 2 3 4
# 63 "/usr/include/openssl/md5.h" 2 3 4
# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 64 "/usr/include/openssl/md5.h" 2 3 4
# 100 "/usr/include/openssl/md5.h" 3 4
typedef struct MD5state_st {
    unsigned int A, B, C, D;
    unsigned int Nl, Nh;
    unsigned int data[(64/4)];
    unsigned int num;
} MD5_CTX;




int MD5_Init(MD5_CTX *c);
int MD5_Update(MD5_CTX *c, const void *data, size_t len);
int MD5_Final(unsigned char *md, MD5_CTX *c);
unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);
void MD5_Transform(MD5_CTX *c, const unsigned char *b);
# 21 "baan.c" 2
# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4




# 1 "/usr/include/arm-linux-gnueabihf/bits/errno.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/arm-linux-gnueabihf/bits/errno.h" 2 3 4
# 50 "/usr/include/arm-linux-gnueabihf/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;




# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 22 "baan.c" 2
# 1 "/usr/include/signal.h" 1 3 4
# 30 "/usr/include/signal.h" 3 4


# 1 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 1 3 4
# 102 "/usr/include/arm-linux-gnueabihf/bits/sigset.h" 3 4
extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 33 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/signum.h" 1 3 4
# 58 "/usr/include/signal.h" 2 3 4
# 80 "/usr/include/signal.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/bits/wordsize.h" 1 3 4
# 25 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 50 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 3 4
typedef struct
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 3)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
     short int si_addr_lsb;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;


 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;
      } _sifields;
  } siginfo_t;
# 141 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 295 "/usr/include/arm-linux-gnueabihf/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 3)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 81 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);




extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 167 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);



extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 189 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 204 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/arm-linux-gnueabihf/bits/sigaction.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 246 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));
# 303 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 327 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 1 3 4
# 27 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 3 4
# 1 "/usr/include/arm-linux-gnueabihf/asm/sigcontext.h" 1 3 4
# 9 "/usr/include/arm-linux-gnueabihf/asm/sigcontext.h" 3 4
struct sigcontext {
 unsigned long trap_no;
 unsigned long error_code;
 unsigned long oldmask;
 unsigned long arm_r0;
 unsigned long arm_r1;
 unsigned long arm_r2;
 unsigned long arm_r3;
 unsigned long arm_r4;
 unsigned long arm_r5;
 unsigned long arm_r6;
 unsigned long arm_r7;
 unsigned long arm_r8;
 unsigned long arm_r9;
 unsigned long arm_r10;
 unsigned long arm_fp;
 unsigned long arm_ip;
 unsigned long arm_sp;
 unsigned long arm_lr;
 unsigned long arm_pc;
 unsigned long arm_cpsr;
 unsigned long fault_address;
};
# 28 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 2 3 4



# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 32 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 2 3 4
# 333 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/arm-linux-gnueabihf/4.9/include/stddef.h" 1 3 4
# 343 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/arm-linux-gnueabihf/bits/sigstack.h" 1 3 4
# 25 "/usr/include/arm-linux-gnueabihf/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 49 "/usr/include/arm-linux-gnueabihf/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 350 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 1 3 4
# 24 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 25 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 2 3 4



# 1 "/usr/include/arm-linux-gnueabihf/bits/sigcontext.h" 1 3 4
# 29 "/usr/include/arm-linux-gnueabihf/sys/ucontext.h" 2 3 4

typedef int greg_t;





typedef greg_t gregset_t[18];


enum
{
  REG_R0 = 0,

  REG_R1 = 1,

  REG_R2 = 2,

  REG_R3 = 3,

  REG_R4 = 4,

  REG_R5 = 5,

  REG_R6 = 6,

  REG_R7 = 7,

  REG_R8 = 8,

  REG_R9 = 9,

  REG_R10 = 10,

  REG_R11 = 11,

  REG_R12 = 12,

  REG_R13 = 13,

  REG_R14 = 14,

  REG_R15 = 15

};

struct _libc_fpstate
{
  struct
  {
    unsigned int sign1:1;
    unsigned int unused:15;
    unsigned int sign2:1;
    unsigned int exponent:14;
    unsigned int j:1;
    unsigned int mantissa1:31;
    unsigned int mantissa0:32;
  } fpregs[8];
  unsigned int fpsr:32;
  unsigned int fpcr:32;
  unsigned char ftype[8];
  unsigned int init_flag;
};

typedef struct _libc_fpstate fpregset_t;





typedef struct sigcontext mcontext_t;


typedef struct ucontext
  {
    unsigned long uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    unsigned long uc_regspace[128] __attribute__((__aligned__(8)));
  } ucontext_t;
# 353 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));







extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/include/arm-linux-gnueabihf/bits/sigthread.h" 1 3 4
# 30 "/usr/include/arm-linux-gnueabihf/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 389 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));




# 23 "baan.c" 2
# 1 "./src/encryption.c" 1



char *str2md5(const char *str, int length) {
    int n;
    MD5_CTX c;
    unsigned char digest[16];
    char *out = (char*)malloc(33);

    MD5_Init(&c);

    while (length > 0) {
        if (length > 512) {
            MD5_Update(&c, str, 512);
        } else {
            MD5_Update(&c, str, length);
        }
        length -= 512;
        str += 512;
    }

    MD5_Final(digest, &c);

    for (n = 0; n < 16; ++n) {
        snprintf(&(out[n*2]), 16*2, "%02x", (unsigned int)digest[n]);
    }

    return out;
}




const char *BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";







void _base64_encode_triple(unsigned char triple[3], char result[4])
 {
    int tripleValue, i;

    tripleValue = triple[0];
    tripleValue *= 256;
    tripleValue += triple[1];
    tripleValue *= 256;
    tripleValue += triple[2];

    for (i=0; i<4; i++)
    {
 result[3-i] = BASE64_CHARS[tripleValue%64];
 tripleValue /= 64;
    }
}
# 68 "./src/encryption.c"
int base64_encode(unsigned char *source, size_t sourcelen, char *target, size_t targetlen)
 {

    if ((sourcelen+2)/3*4 > targetlen-1)
 return 0;


    while (sourcelen >= 3)
    {
 _base64_encode_triple(source, target);
 sourcelen -= 3;
 source += 3;
 target += 4;
    }


    if (sourcelen > 0)
    {
 unsigned char temp[3];
 memset(temp, 0, sizeof(temp));
 memcpy(temp, source, sourcelen);
 _base64_encode_triple(temp, target);
 target[3] = '=';
 if (sourcelen == 1)
     target[2] = '=';

 target += 4;
    }


    target[0] = 0;

    return 1;
}







int _base64_char_value(char base64char)
 {
    if (base64char >= 'A' && base64char <= 'Z')
 return base64char-'A';
    if (base64char >= 'a' && base64char <= 'z')
 return base64char-'a'+26;
    if (base64char >= '0' && base64char <= '9')
 return base64char-'0'+2*26;
    if (base64char == '+')
 return 2*26+10;
    if (base64char == '/')
 return 2*26+11;
    return -1;
}
# 131 "./src/encryption.c"
int _base64_decode_triple(char quadruple[4], unsigned char *result)
 {
    int i, triple_value, bytes_to_decode = 3, only_equals_yet = 1;
    int char_value[4];

    for (i=0; i<4; i++)
 char_value[i] = _base64_char_value(quadruple[i]);


    for (i=3; i>=0; i--)
    {
 if (char_value[i]<0)
 {
     if (only_equals_yet && quadruple[i]=='=')
     {


  char_value[i]=0;
  bytes_to_decode--;
  continue;
     }
     return 0;
 }

 only_equals_yet = 0;
    }


    if (bytes_to_decode < 0)
 bytes_to_decode = 0;


    triple_value = char_value[0];
    triple_value *= 64;
    triple_value += char_value[1];
    triple_value *= 64;
    triple_value += char_value[2];
    triple_value *= 64;
    triple_value += char_value[3];


    for (i=bytes_to_decode; i<3; i++)
 triple_value /= 256;
    for (i=bytes_to_decode-1; i>=0; i--)
    {
 result[i] = triple_value%256;
 triple_value /= 256;
    }

    return bytes_to_decode;
}
# 191 "./src/encryption.c"
size_t base64_decode(char *source, unsigned char *target, size_t targetlen)
 {
    char *src, *tmpptr;
    char quadruple[4], tmpresult[3];
    int i, tmplen = 3;
    size_t converted = 0;


    src = (char *)malloc(strlen(source)+5);
    if (src == ((void *)0))
 return -1;
    strcpy(src, source);
    strcat(src, "====");
    tmpptr = src;


    while (tmplen == 3)
    {

 for (i=0; i<4; i++)
 {

     while (*tmpptr != '=' && _base64_char_value(*tmpptr)<0)
  tmpptr++;

     quadruple[i] = *(tmpptr++);
 }


 tmplen = _base64_decode_triple(quadruple, tmpresult);


 if (targetlen < tmplen)
 {
     free(src);
     return -1;
 }


 memcpy(target, tmpresult, tmplen);
 target += tmplen;
 targetlen -= tmplen;
 converted += tmplen;
    }

    free(src);
    return converted;
}
# 24 "baan.c" 2

# 1 "settings.h" 1
# 26 "baan.c" 2
# 45 "baan.c"
int stop = 0;
int startup = 0;

struct adr{
 int M;
 int B;
 int S;
 int type;
};

int Adr_Comp(struct adr A,struct adr B);

int B_list_i = 0, St_list_i = 0, S_list_i = 0, M_list_i = 0, Si_list_i = 0;

# 1 "./src/rail.c" 1
# 1 "./src/./rail.h" 1

  struct Swi;



  struct signal;




  struct Rail_link {
    char type;

    struct Seg * B;
    struct Swi * Sw;
    struct Mod * M;
    struct signal * Si;
  };

  struct Station_link{
    struct Station * St;
    char type;
  };


struct SegC {
  long Adr;
  char Module;
  char type;
};



  struct Seg{
    int Module;
    int id;
    char type;

    struct Rail_link Next;
    struct Rail_link Prev;

    struct SegC NextC;
    struct SegC PrevC;

    struct Station * Station;

   char max_speed;
   char state;
   char dir;
   char length;
   char train;
   _Bool blocked;
   _Bool change;
   _Bool oneWay;






   struct signal * NSi;
   struct signal * PSi;

  };




  struct Switch_state_link{
    char type;
    char state;
    struct Swi * Sw;
    struct Mod * MSw;
  };

  struct Station{
    int Module;
    int id;
    int UnID;
    char Name[20];
   struct Seg * Blocks[8];
   char type;

    char Switches;
    struct Switch_state_link ** Sw;
  };


struct link{
 struct SegC Adr1;
 struct SegC Adr2;
 struct SegC Adr3;
 struct SegC Adr4;
};

void Create_Segment(int IO_Adr,struct SegC Adr ,struct SegC Next, struct SegC Prev,char max_speed,char state,char dir,char len);

char DeviceList[20];
# 2 "./src/rail.c" 2


# 1 "./src/./modules.h" 1




  struct Unit_IO{
   char type;
   struct Seg * B;
   struct Swi * S;
   struct Mod * M;
   struct signal * Signals;
  };




  struct Unit{
   int B_L;
   int S_L;
   int Si_L;

   _Bool Sig_change;

   char Out_length;
   char In_length;

    struct Rail_link ** Out;
    struct Rail_link ** In;

    uint8_t *BlinkMask;
    uint8_t *OutRegs;
    uint8_t *InRegs;

    uint8_t InRegisters;
    uint8_t OutRegisters;

   struct Seg ** B;
   struct Swi ** S;
   struct Mod * M[16*8];
   struct signal * Signals[16*8];
    struct Station * St[20];

   char B_nr, Swi_nr, Mod_nr, Signal_nr,Station_nr;
  };

  struct Unit *Units[16];

  void clear_Modules();

  void LoadModules(int M);
# 5 "./src/rail.c" 2



# 1 "./src/./switch.h" 1


 struct L_Swi_t{
  struct SegC Adr;
  int states[5];
 };

 struct P_Swi_t{
  char type;
  char state;
 };




 struct Swi{
  int Module;
  int id;

  struct Rail_link div;
  struct Rail_link str;
  struct Rail_link app;

  struct SegC DivC;
  struct SegC StrC;
  struct SegC AppC;

  char state;
  char default_state;
  char len;

  char UAdr;
  char Out[5];

  struct Seg * Detection_Block;

  struct L_Swi_t * L_Swi[5];

  struct P_Swi_t * pref[5];
 };




 struct Mod{
  int Module;
  int id;
  struct adr Adr;

  struct Seg * Detection_Block;

  struct adr mAdr[10];
  struct adr MAdr[10];

  struct Rail_link m_Adr[10];
  struct Rail_link M_Adr[10];

  struct SegC m_AdrC[10];
  struct SegC M_AdrC[10];

  char length;
  char s_length;
  char state;
 };




 struct Swi *Switch[16][16][8] = {};
 struct Swi *Switch2[16][16*8] = {};
 struct Mod *Moduls[16][16][8/4] = {};

 int throw_switch(struct Swi * S);

 int throw_ms_switch(struct Mod * M, char c);

 void Create_Switch(struct SegC Adr,struct SegC App,struct SegC Div,struct SegC Str,int * adr,char state);

 void Create_Moduls(int Unit_Adr, struct adr Adr,struct adr mAdr[10],struct adr MAdr[10],char length);
# 9 "./src/rail.c" 2



struct Station * stations[16*16] = {};

struct SegC EMPTY_BL(){
  struct SegC A;
  A.Module = 0;
  A.Adr = 0;
  A.type = 0;
  return A;
}

struct SegC CAdr(int M,int B,char type){
  struct SegC A;
  A.Module = M;
  A.Adr = B;
  A.type = type;
  return A;
}

int Adr_Comp2(struct SegC A,struct SegC B);

void Create_Segment(int IO_Adr,struct SegC Adr ,struct SegC Next, struct SegC Prev,char max_speed,char state,char dir,char len){
 struct Seg *Z = (struct Seg*)malloc(sizeof(struct Seg));



  Z->id = Adr.Adr;
  Z->Module = Adr.Module;
 Z->type = Adr.type;
 Z->NextC = Next;
 Z->PrevC = Prev;
 Z->max_speed = max_speed;
 Z->state = state;
 Z->dir = dir;
 Z->length = len;
 Z->change = 1;
  Z->blocked = 0;
 Z->train = 0x00;
 Z->oneWay = (!(1==1));
  Z->NSi = 0;
  Z->PSi = 0;

  Z->Next.type = 0;Z->Next.B = 0;Z->Next.Sw = 0;Z->Next.M = 0;Z->Next.Si = 0;
  Z->Prev.type = 0;Z->Prev.B = 0;Z->Prev.Sw = 0;Z->Prev.M = 0;Z->Prev.Si = 0;



 if(Units[Adr.Module]->InRegisters*8 <= IO_Adr){

  Units[Adr.Module]->InRegisters++;

    printf("Expand to %i shift register, size(%i)\n",Units[Adr.Module]->InRegisters,8*Units[Adr.Module]->InRegisters);


    Units[Adr.Module]->In = (struct Rail_link **)realloc(Units[Adr.Module]->In,8*Units[Adr.Module]->InRegisters*sizeof(struct Rail_link *));


    for(int i = 8*Units[Adr.Module]->InRegisters-8;i<8*Units[Adr.Module]->InRegisters;i++){
      Units[Adr.Module]->In[i] = 0;
    }
 }


  if(Z->id >= Units[Adr.Module]->B_L){

    printf("Expand B list of module %i to %i\n",Adr.Module,8*((Z->id + 8)/8));

    Units[Adr.Module]->B = (struct Seg **)realloc(Units[Adr.Module]->B,8*((Z->id + 8)/8)*sizeof(struct Seg *));


    for(int i = 8*((Z->id)/8);i<8*((Z->id + 8)/8);i++){
      Units[Adr.Module]->B[i] = 0;
    }
    Units[Adr.Module]->B_L = 8*((Z->id + 8)/8);
  }

 if(Units[Adr.Module]->B[Z->id] == ((void *)0)){
    printf("Module %i segment %i\n",Adr.Module,Z->id);
  Units[Adr.Module]->B[Z->id] = Z;

    if(Z->id > Units[Adr.Module]->B_nr){
      Units[Adr.Module]->B_nr = Z->id;
    }
 }else{
  printf("Double Block Number %i in Module %i\n",Z->id,Adr.Module);
 }

  struct Rail_link Y;
  Y.type = 'R';
  Y.B = Z;

  if(Units[Adr.Module]->In[IO_Adr] == 0){
    struct Rail_link * Y = (struct Rail_link*)calloc(1,sizeof(struct Rail_link));
    Y->type = 'R';Y->B = Z;
    Units[Adr.Module]->In[IO_Adr] = Y;
  }else{
  printf("Double Block IO Address %i in Module %i\n",IO_Adr,Adr.Module);
 }
}

void Create_Segment2(int IO_Adr,char M,int ID,char Type,struct SegC Next, struct SegC Prev,char max_speed,char state,char dir,char len){
  Create_Segment(IO_Adr,CAdr(M,ID,Type),Next,Prev,max_speed,state,dir,len) ;
}

int Block_cmp(struct Seg * A,struct Seg * B){
  if(A && A == B){
   return 1;
  }else{
    return 0;
  }
}

int Link_cmp(struct Rail_link A, struct Rail_link B){

  if(A.B == B.B && A.Sw == B.Sw && A.M == B.M && A.Si == B.Si){
    if(A.type == B.type || (A.type == 'S' && B.type == 's') || (A.type == 's' && B.type == 'S')){
      return 1;
    }else{return 0;}
  }else{
    return 0;
  }
}

void Connect_Segments(){
  for(int i = 0;i<16;i++){
    if(Units[i]){

      for(int j = 0;j<Units[i]->B_L;j++){
        if(Units[i]->B[j]){


          if(Units[i]->B[j]->type != 'T'){


            if(!Adr_Comp2(Units[i]->B[j]->NextC,EMPTY_BL())){
              int nM = Units[i]->B[j]->NextC.Module;
              int nA = Units[i]->B[j]->NextC.Adr;
              char nT = Units[i]->B[j]->NextC.type;
              Units[i]->B[j]->Next.type = nT;
              if(nT == 'R'){
                Units[i]->B[j]->Next.B = Units[nM]->B[nA];
              }else if(nT == 'S' || nT == 's'){
                Units[i]->B[j]->Next.Sw = Units[nM]->S[nA];
              }else if(nT == 'M' || nT == 'm'){
                Units[i]->B[j]->Next.M = Units[nM]->M[nA];
              }
            }else{
              Units[i]->B[j]->Next.type = 0;
            }



            if(!Adr_Comp2(Units[i]->B[j]->PrevC,EMPTY_BL())){
              int pM = Units[i]->B[j]->PrevC.Module;
              int pA = Units[i]->B[j]->PrevC.Adr;
              char pT = Units[i]->B[j]->PrevC.type;
              Units[i]->B[j]->Prev.type = pT;
              if(pT == 'R'){
                Units[i]->B[j]->Prev.B = Units[pM]->B[pA];
              }else if(pT == 'S' || pT == 's'){
                Units[i]->B[j]->Prev.Sw = Units[pM]->S[pA];
              }else if(pT == 'M' || pT == 'm'){
                Units[i]->B[j]->Prev.M = Units[pM]->M[pA];
              }
            }else{
              Units[i]->B[j]->Next.type = 0;
            }
          }
        }
      }
      for(int j = 0;j<Units[i]->S_L;j++){
        if(Units[i]->S[j]){



          int aM = Units[i]->S[j]->AppC.Module;
          int aA = Units[i]->S[j]->AppC.Adr;
          char aT = Units[i]->S[j]->AppC.type;
          Units[i]->S[j]->app.type = aT;
          if(aT == 'R'){
            Units[i]->S[j]->app.B = Units[aM]->B[aA];
          }else if(aT == 'S' || aT == 's'){
            Units[i]->S[j]->app.Sw = Units[aM]->S[aA];
          }else if(aT == 'M' || aT == 'm'){
            Units[i]->S[j]->app.M = Units[aM]->M[aA];
          }


          int dM = Units[i]->S[j]->DivC.Module;
          int dA = Units[i]->S[j]->DivC.Adr;
          char dT = Units[i]->S[j]->DivC.type;
          Units[i]->S[j]->div.type = dT;
          if(dT == 'R'){
            Units[i]->S[j]->div.B = Units[dM]->B[dA];
          }else if(dT == 'S' || dT == 's'){
            Units[i]->S[j]->div.Sw = Units[dM]->S[dA];
          }else if(dT == 'M' || dT == 'm'){
            Units[i]->S[j]->div.M = Units[dM]->M[dA];
          }


          int sM = Units[i]->S[j]->StrC.Module;
          int sA = Units[i]->S[j]->StrC.Adr;
          char sT = Units[i]->S[j]->StrC.type;
          Units[i]->S[j]->str.type = sT;
          if(sT == 'R'){
            Units[i]->S[j]->str.B = Units[sM]->B[sA];
          }else if(sT == 'S' || sT == 's'){
            Units[i]->S[j]->str.Sw = Units[sM]->S[sA];
          }else if(sT == 'M' || sT == 'm'){
            Units[i]->S[j]->str.M = Units[sM]->M[sA];
          }
        }
      }

    }
  }
}
# 241 "./src/rail.c"
int Create_Station(char Module,char * Name,char type,char nr,int Blocks[]){
 struct Station * Z = (struct Station*)malloc(sizeof(struct Station));


  Z->Module = Module;
  Z->id = Units[Module]->Station_nr;
  Z->UnID = St_list_i;
  Z->type = type;
  Z->Switches = 0;
  strcpy(Z->Name,Name);

  for(int i = 0;i<nr;i++){
    Z->Blocks[i] = Units[Module]->B[Blocks[i]];
    Units[Module]->B[Blocks[i]]->Station = Z;
  }

  Units[Module]->St[Units[Module]->Station_nr++] = Z;

 stations[St_list_i++] = Z;
 printf("Station for %i ('%s')\n",Module,Name);

 return St_list_i - 1;
}

void Station_Add_Switch(struct Station * St,struct Swi * Sw,char state){
  struct Switch_state_link * Z = (struct Switch_state_link *)malloc(sizeof(struct Switch_state_link));
  Z->type = 'S';
  Z->state = state;
  Z->Sw = Sw;

  if(St->Switches == 0){
    St->Sw = (struct Switch_state_link **)malloc(sizeof(struct Switch_state_link *));
    St->Sw[0] = Z;
    St->Switches++;
  }else{
    St->Sw = (struct Switch_state_link **)realloc(St->Sw,++St->Switches * sizeof(struct Switch_state_link *));
    St->Sw[St->Switches-1] = Z;
  }
}

void Station_Add_MSwitch(struct Station * St,struct Mod * MSw, char state){
  struct Switch_state_link * Z = (struct Switch_state_link *)malloc(sizeof(struct Switch_state_link));
  Z->type = 'M';
  Z->state = state;
  Z->MSw = MSw;

  if(St->Switches == 0){
    St->Sw = (struct Switch_state_link **)malloc(sizeof(struct Switch_state_link *));
    St->Sw[0] = Z;
    St->Switches++;
  }else{
    St->Sw = (struct Switch_state_link **)realloc(St->Sw,++St->Switches * sizeof(struct Switch_state_link *));
    St->Sw[St->Switches-1] = Z;
  }
}


struct Seg * Next2(struct Seg * B,int i){
  if(!B){printf("Empty Next2");return 0;}

 struct Rail_link NAdr,SNAdr;
  struct Swi * S;struct Mod * M;
 int Search_len = i;
 int a = 0;



 char prev_dir = B->dir;


 I:{};





  if(!B){

    return 0;
  }
 char dir = B->dir;

 if(prev_dir == 0 && dir == 1 || prev_dir == 129 && dir == 0){
  prev_dir ^= 0x80;
  NAdr = B->Next;
 }
 else if(prev_dir == 1 && dir == 0 || prev_dir == 128 && dir == 1){
  prev_dir ^= 0x80;
  NAdr = B->Prev;
 }
 else if((prev_dir >> 7) == 1){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Prev;
  }else{
   NAdr = B->Next;
  }
 }
 else if(dir == 0 || dir == 2 || dir == 5){
  NAdr = B->Next;
 }
 else{
  NAdr = B->Prev;
 }

 prev_dir = (prev_dir & 0xC0) + (dir & 0xF);

 J:{};

 if(i <= 0){


  return B;
 }
# 367 "./src/rail.c"
 if(NAdr.type == 'R'){
  i--;
  B = NAdr.B;
  goto I;
 }else if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'm' || NAdr.type == 'M'){
  R:{};
# 381 "./src/rail.c"
  if((NAdr.type == 'S' || NAdr.type=='s') && NAdr.Sw->Detection_Block){
      if(NAdr.Sw->Detection_Block->type == 'T'){
        if(i == 1){

       i--;
       B = NAdr.Sw->Detection_Block;
       goto J;
        }else{
          a++;
        }
      }
  }
  if(NAdr.type == 'S'){
   if(NAdr.Sw->state == 0){
    SNAdr = NAdr.Sw->str;
   }else{
    SNAdr = NAdr.Sw->div;
   }
  }
  else if(NAdr.type == 's'){
   SNAdr = NAdr.Sw->app;
  }
  else if(NAdr.type == 'M'){

   int s = NAdr.M->state;
   SNAdr = NAdr.M->m_Adr[s];

  }
  else if(NAdr.type == 'm'){

   int s = NAdr.M->state;
   SNAdr = NAdr.M->M_Adr[s];

  }

  if(SNAdr.type == 'S' || SNAdr.type == 's'){
   if(!Block_cmp(SNAdr.Sw->Detection_Block,NAdr.Sw->Detection_Block)){

    i--;
   }
   NAdr = SNAdr;
   goto R;
    }else if(SNAdr.type == 'M' || SNAdr.type == 'm'){
   if(SNAdr.B != NAdr.B){
    i--;
   }
   NAdr = SNAdr;
   goto R;
  }else{
   B = SNAdr.B;


      if(NAdr.type == 'S' || NAdr.type == 's'){
        if(Block_cmp(SNAdr.B,NAdr.Sw->Detection_Block)){
          i++;
        }
      }
   i--;
      if(a>0){
        i--;
      }
   goto I;
  }
 }
 return B;
}

struct Seg * Prev2(struct Seg * B,int i){
  if(!B){printf("Empty Next2");return 0;}

 struct Rail_link NAdr,SNAdr;
  struct Swi * S;struct Mod * M;
 int Search_len = i;
 int a = 0;



 char prev_dir = B->dir;


 I:{};





  if(!B){

    return 0;
  }
 char dir = B->dir;

 if(prev_dir == 0 && dir == 1 || prev_dir == 129 && dir == 0){
  prev_dir ^= 0x80;
  NAdr = B->Prev;
 }
 else if(prev_dir == 1 && dir == 0 || prev_dir == 128 && dir == 1){
  prev_dir ^= 0x80;
  NAdr = B->Next;
 }
 else if((prev_dir >> 7) == 1){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Next;
  }else{
   NAdr = B->Prev;
  }
 }
 else if(dir == 0 || dir == 2 || dir == 5){
  NAdr = B->Prev;
 }
 else{
  NAdr = B->Next;
 }

 prev_dir = (prev_dir & 0xC0) + (dir & 0xF);

 J:{};

 if(i <= 0){


  return B;
 }
# 516 "./src/rail.c"
  if(NAdr.type == 'R'){
  i--;
  B = NAdr.B;
  goto I;
 }else if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'm' || NAdr.type == 'M'){
  R:{};
# 530 "./src/rail.c"
  if((NAdr.type == 'S' || NAdr.type=='s') && NAdr.Sw->Detection_Block){
      if(NAdr.Sw->Detection_Block->type == 'T'){
        if(i == 1){

       i--;
       B = NAdr.Sw->Detection_Block;
       goto J;
        }else{
          a++;
        }
      }
  }
  if(NAdr.type == 'S'){
   if(NAdr.Sw->state == 0){
    SNAdr = NAdr.Sw->str;
   }else{
    SNAdr = NAdr.Sw->div;
   }
  }
  else if(NAdr.type == 's'){
   SNAdr = NAdr.Sw->app;
  }
  else if(NAdr.type == 'M'){

   int s = NAdr.M->state;
   SNAdr = NAdr.M->m_Adr[s];

  }
  else if(NAdr.type == 'm'){

   int s = NAdr.M->state;
   SNAdr = NAdr.M->M_Adr[s];

  }

  if(SNAdr.type == 'S' || SNAdr.type == 's'){
   if(!Block_cmp(SNAdr.Sw->Detection_Block,NAdr.Sw->Detection_Block)){

    i--;
   }
   NAdr = SNAdr;
   goto R;
    }else if(SNAdr.type == 'M' || SNAdr.type == 'm'){
   if(SNAdr.B != NAdr.B){
    i--;
   }
   NAdr = SNAdr;
   goto R;
  }else{
   B = SNAdr.B;


      if(NAdr.type == 'S' || NAdr.type == 's'){
        if(Block_cmp(SNAdr.B,NAdr.Sw->Detection_Block)){
          i++;
        }
      }
   i--;
      if(a>0){
        i--;
      }
   goto I;
  }
 }
 return B;
}

struct Rail_link NADR2(struct Seg * B){
  struct Rail_link NAdr;
  if(!B){printf("Empty NADR2");return NAdr;}
 int dir = B->dir;

 if(dir == 0 || dir == 2 || dir == 0b101){
  NAdr = B->Next;
 }else{
  NAdr = B->Prev;
 }
 return NAdr;
}

struct Rail_link PADR2(struct Seg * B){
  struct Rail_link NAdr;
  NAdr.type = 0;NAdr.Sw = 0;NAdr.B = 0;NAdr.M = 0;NAdr.Si = 0;
  if(!B){printf("Empty PADR2");return NAdr;}
 int dir = B->dir;

 if(dir == 0 || dir == 2 || dir == 0b101){
  NAdr = B->Prev;
 }else{
  NAdr = B->Next;
 }
 return NAdr;
}
# 60 "baan.c" 2
# 1 "./src/signals.c" 1
# 1 "./src/./signals.h" 1


  struct signal{
    int id;
    int MAdr;
    int UAdr;
    int state;
    int type;
    uint8_t length;

    short adr[6];
    char states[4];
    char flash[4];
  };

  struct signal *signals[16*16*8] = {};

  struct Unit;
# 2 "./src/signals.c" 2


# 1 "./src/./COM.h" 1


 struct train;

 struct COM_t{
  char length;
  char data[32];
 };

 void * UART();

 char * COM_Send(struct COM_t DATA);

 int COM_Recv(char * OUT_Data);

 char * COM_SaR(char * buf[60]);

 void COM_change_A_signal(int M);

 void COM_change_signal(struct signal * Si);

 void COM_change_switch(int M);

 void COM_set_train_speed(struct train * T,char speed);
# 5 "./src/signals.c" 2
# 41 "./src/signals.c"
void create_signal2(struct Seg * B,char adr_nr, uint8_t addresses[adr_nr], char state[4], char flash[4], char side){





  struct signal *Z = (struct signal*)malloc(sizeof(struct signal));

  Z->state = 0;

  Z->id = Units[B->Module]->Signal_nr;
  long Unit_Adr = Units[B->Module]->Signal_nr++;

  Z->MAdr = B->Module;
  Z->type = 1;
  Z->length = adr_nr;

  for(char i = 0;i<adr_nr;i++){
    if(Units[Z->MAdr]->OutRegisters*8 < addresses[i]){
      printf("Expansion needed\t");
      printf("Address %i doesn't fit\n",addresses[i]);


      Units[Z->MAdr]->OutRegisters++;

      printf("Expanded to: %i bytes\n",Units[Z->MAdr]->OutRegisters);


      Units[Z->MAdr]->Out = (struct Rail_link **)realloc(Units[Z->MAdr]->Out,8*Units[Z->MAdr]->OutRegisters*sizeof(struct Rail_link *));


      for(int i = 8*Units[Z->MAdr]->OutRegisters-8;i<8*Units[Z->MAdr]->OutRegisters;i++){
        Units[Z->MAdr]->Out[i] = 0;
      }
    }
    Z->adr[i] = addresses[i];
  }

  memcpy(Z->states,state,4);
  memcpy(Z->flash,flash,4);

  signals[Si_list_i] = Z;

  if(side == 0){
    B->NSi = Z;
  }else if(side == 1){
    B->PSi = Z;
  }

  if(!Units[B->Module]->Signals[Unit_Adr]){
    Units[B->Module]->Signals[Unit_Adr] = Z;
    Z->UAdr = Unit_Adr;
    if(Unit_Adr > (Units[B->Module]->Si_L-1)){
      Units[B->Module]->Si_L = Unit_Adr + 1;
    }
  }else{
    printf("Double signal adress %i in Module %i\n",Unit_Adr,B->Module);
  }


  Si_list_i++;
}

void set_signal(struct signal *Si,int state){
  if(!(Si->state == state || Si->state == (0x80 + state))){
# 117 "./src/signals.c"
    Si->state = 0x80 + state;
  }
}
# 61 "baan.c" 2
# 1 "./src/switch.c" 1





# 1 "./src/./Web.h" 1




  struct web_client_t{
    int fd_client;
    int client_type;
# 18 "./src/./Web.h"
    int state;



  };

  struct client_thread_args{
    int fd_client;
    int thread_id;
  };

  int websocket_connect(struct web_client_t * C);

  int recv_packet(int fd_client, char outbuf[], int * L);

  int send_packet(int fd_client, char data[],int length,int flag);

  void send_all(char data[],int length,int flag);

  int recv_packet_procces(char data[1024],struct client_thread_args * client_data);

  void * websocket_client(void * thread_data);

  void *clear_clients();

  void * web_server();
# 7 "./src/switch.c" 2



# 1 "./src/./trains.h" 1

struct train{
 int DCC_ID;
 int ID;
 char type;
 char name[21];
 char cur_speed;
 long max_speed;
 char accelerate_speed;
 char break_speed;
 char use;
 char control;
 _Bool halt;
 _Bool dir;

 struct Sw_train_PATH * Route[200];
 int Sw_len;
 struct Seg * Destination;

 struct Seg * Cur_Block;

 char timer;
 int timer_id;
};

struct train_timer_th_data{
   int thread_id;
  int Flag;
  int speed;
  struct train * T;
  struct Seg * B;
};

struct train *trains[30] = {};
struct train *DCC_train[9999] = {};
struct train *train_link[30];
int iTrain = 0;
int bTrain = 0;

int add_train(int DCC,int speed,char name[],char type);

int create_train(int DCC,int speed,char name[],char type);

void init_trains();

int link_train(char link,int train);

void unlink_train(char link);

void *train_timer(void *threadArg);

void train_speed(struct Seg * B,struct train * T,char speed);

void train_set_speed(struct train *T,char speed);

void train_set_dir(struct train *T,char dir);

void train_set_route(struct train *T,struct Station * S);

void train_stop(struct train * T);

void train_signal(struct Seg * B,struct train * T,int type);

void train_block_timer();
# 11 "./src/switch.c" 2



# 1 "./src/./pathfinding.h" 1


struct Sw_A_PATH {
 struct Rail_link adr;
 char length;
 signed char suc[10];
 int state[10];
 int dir;
 struct Sw_A_PATH * Prev;
 struct Sw_A_PATH * Next[20];
};

struct Sw_PATH {
 struct Rail_link adr;
 signed char suc[10];
};

struct Sw_train_PATH{
 struct Rail_link adr;
 char states;
 signed char suc[10];
};

int pathFinding(struct Seg * Begin, struct Seg * End, struct Sw_train_PATH *(OUT_Sw_Nodes)[200], int * len);
# 15 "./src/switch.c" 2


struct adr Switch_list[16*16*8] = {};
struct adr MS_Switch_list[16*16*8] = {};

int throw_switch(struct Swi * S){
 int linked = 0;
  for(int i = 0;i<5;i++){
    if(S->L_Swi[i]){
   linked = 1;
      struct SegC A = S->L_Swi[i]->Adr;

   if(A.type == 'S' || A.type == 's'){
       if(Switch2[A.Module][A.Adr]->Detection_Block && (Switch2[A.Module][A.Adr]->Detection_Block->state == 5 || Switch2[A.Module][A.Adr]->Detection_Block->blocked)){
     printf("Linked switches blocked\n");
         return 0;
       }
   }else if(A.type == 'M' || A.type == 'm'){

   }
    }
  }
  if(S->Detection_Block && (S->Detection_Block->state != 5 && !S->Detection_Block->blocked) || !S->Detection_Block){
    S->state = 0x80 + !(S->state & 0x7F);

    char buf[40];
    buf[0] = 0x27;
  int index = 1;

  buf[index++] = S->Module;
  buf[index++] = S->id & 0x7F;
  buf[index++] = Switch2[S->Module][S->id]->state & 0x7F;

    for(int i = 0;i<5;i++){
      if(S->L_Swi[i]){
        struct SegC A = S->L_Swi[i]->Adr;
        printf("Linked switching (%c%i:%i",A.type,A.Module,A.Adr);

        Switch2[A.Module][A.Adr]->state = 0x80 + (S->L_Swi[i]->states[S->state&0x7F] & 0x7F);
        printf(" => %i)\n",Switch2[A.Module][A.Adr]->state);

    buf[index++] = A.Module;
    buf[index++] = A.Adr & 0x7F;
    buf[index++] = Switch2[A.Module][A.Adr]->state & 0x7F;
      }
    }
    printf("Throw Switch %s\n\n",buf);
 COM_change_switch(S->Module);
    send_all(buf,index,2);
    return 1;
  }else{
  printf("Switch blocked\n");
    return 0;
  }
}

int set_switch(struct Swi * S,char state){
 int linked = 0;
 for(int i = 0;i<5;i++){
  if(S->L_Swi[i]){
   linked = 1;
   struct SegC A = S->L_Swi[i]->Adr;

   if(A.type == 'S' || A.type == 's'){
    if(Switch2[A.Module][A.Adr]->Detection_Block && (Switch2[A.Module][A.Adr]->Detection_Block->state == 5 || Switch2[A.Module][A.Adr]->Detection_Block->blocked)){
      printf("Linked switches blocked\n");
    return 0;
   }
  }else if(A.type == 'M' || A.type == 'm'){

  }
    }
  }
  if(S->Detection_Block && (S->Detection_Block->state != 5 && !S->Detection_Block->blocked) || !S->Detection_Block){
    S->state = state + 0x80;

    char buf[40];
    buf[0] = 0x26;
  int index = 1;

  buf[index++] = S->Module;
  buf[index++] = S->id;
  buf[index++] = Switch2[S->Module][S->id]->state;

    for(int i = 0;i<5;i++){
      if(S->L_Swi[i]){
        struct SegC A = S->L_Swi[i]->Adr;
        printf("Linked switching (%c%i:%i",A.type,A.Module,A.Adr);

        Switch2[A.Module][A.Adr]->state = S->L_Swi[i]->states[S->state];
        printf(" => %i)\n",Switch2[A.Module][A.Adr]->state);

    buf[index++] = A.Module;
    buf[index++] = A.Adr;
    buf[index++] = Switch2[A.Module][A.Adr]->state;
      }
    }
    printf("Throw Switch %s\n\n",buf);
 COM_change_switch(S->Module);
    send_all(buf,index,2);
    return 1;
  }else{
  printf("Switch blocked\n");
    return 0;
  }
}

int throw_ms_switch(struct Mod * M, char c){
# 132 "./src/switch.c"
    return 0;
}


void Create_Switch(struct SegC Adr,struct SegC App,struct SegC Div,struct SegC Str,int * adr,char state){
 struct Swi *Z = (struct Swi*)malloc(sizeof(struct Swi));

 Adr.type = 'S';

 Z->id = Adr.Adr;
 Z->Module = Adr.Module;
 Z->StrC = Str;
 Z->DivC = Div;
 Z->AppC = App;
 Z->state = state + 0x80;
 Z->default_state = state;
 Z->len = 1;


 for(char i = 0;i<2;i++){
  if(Units[Adr.Module]->OutRegisters*8 < adr[i]){
   printf("Expansion needed\t");
   printf("Address %i doesn't fit\n",adr[i]);


   Units[Adr.Module]->OutRegisters++;

   printf("Expanded to: %i bytes\n",Units[Adr.Module]->OutRegisters);


   Units[Adr.Module]->Out = (struct Rail_link **)realloc(Units[Adr.Module]->Out,8*Units[Adr.Module]->OutRegisters*sizeof(struct Rail_link *));


   for(int i = 8*Units[Adr.Module]->OutRegisters-8;i<8*Units[Adr.Module]->OutRegisters;i++){
    Units[Adr.Module]->Out[i] = 0;
   }
  }
  Z->Out[i] = adr[i];
 }


 if(Z->id >= Units[Adr.Module]->S_L){

  printf("Expand S list of module %i to %i\n",Adr.Module,8*((Z->id + 8)/8));

  Units[Adr.Module]->S = (struct Swi **)realloc(Units[Adr.Module]->S,8*((Z->id + 8)/8)*sizeof(struct Swi *));


  for(int i = 8*((Z->id)/8);i<8*((Z->id + 8)/8);i++){
    Units[Adr.Module]->S[i] = 0;
  }
  Units[Adr.Module]->S_L = 8*((Z->id + 8)/8);
 }
# 197 "./src/switch.c"
 for(int i = 0;i<5;i++){
  Z->L_Swi[i] = ((void *)0);
 }

 for(int i = 0;i<5;i++){
  Z->pref[i] = ((void *)0);
 }

 Switch2[Adr.Module][Adr.Adr] = Z;

  if(!Units[Adr.Module]->S[Adr.Adr]){
    Units[Adr.Module]->S[Adr.Adr] = Z;
  Units[Adr.Module]->Swi_nr++;
  }else{
    printf("WARNING - Double switch number %i in Module %i\n",Adr.Adr,Adr.Module);
  }
}

void Create_Moduls(int Unit_Adr, struct adr Adr,struct adr mAdr[10],struct adr MAdr[10],char length){
 struct Mod *Z = (struct Mod*)malloc(sizeof(struct Mod));

 Adr.type = 'M';

 Z->Adr = Adr;
 for(int i = 0;i<length;i++){
  printf("i:%i\n",i);
  Z->mAdr[i] = mAdr[i];
  Z->MAdr[i] = MAdr[i];
 }
 Z->length = length;
 Z->state = 0;
 Z->s_length = 1;

 if(Adr.S > 1){
  Z->s_length = Adr.S;
  for(int i = 1;i<Adr.S;i++){
   if(Switch[Adr.M][Adr.B][i] != ((void *)0)){
    Switch[Adr.M][Adr.B][i]->len = Adr.S;
   }else if(Moduls[Adr.M][Adr.B][i] != ((void *)0)){
    Moduls[Adr.M][Adr.B][i]->s_length = Adr.S;
   }
  }
 }







 Moduls[Adr.M][Adr.B][Adr.S] = Z;



 if(Units[Adr.M]->M[Unit_Adr] == ((void *)0)){
  Units[Adr.M]->M[Unit_Adr] = Z;
 }else{
  printf("Double Switch adress %i in Module %i\n",Unit_Adr,Adr.M);
 }

 MS_Switch_list[M_list_i] = Adr;
 M_list_i++;
}


int check_Switch_state(struct Rail_link NAdr){
 if(((NAdr.type == 's' || NAdr.type == 'S') && NAdr.Sw->Detection_Block && NAdr.Sw->Detection_Block->state != 5) ||
   ((NAdr.type == 'm' || NAdr.type == 'M') && NAdr.M->Detection_Block && NAdr.M->Detection_Block->state != 5)){

  return 1;
 }else{
  return 0;
 }
}

int check_Switch(struct Seg * B, int direct, _Bool incl_pref){
 struct Rail_link Adr,NAdr,SNAdr;
 struct Swi * S;

 int debug = 0;

 if(B->Module == 4 && B->id == 18){

 }

 Adr.type = 'R';Adr.B = B;Adr.Sw = 0;Adr.M = 0;Adr.Si = 0;

 if(!B){printf("Empty ChSw2");return 0;}
 int dir = B->dir;




 if(direct == 0){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Next;
  }else{
   NAdr = B->Prev;
  }
 }else{
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Prev;
  }else{
   NAdr = B->Next;
  }
 }

 int n;
 R:{};
 if(debug){
   printf("Switch P type:%c\t",NAdr.type);
   if(NAdr.type == 'R'){
     printf("R   %i:%i\n",NAdr.B->Module,NAdr.B->id);
   }else if(NAdr.type == 'S' || NAdr.type == 's'){
     printf("Sw  %i:%i\n",NAdr.Sw->Module,NAdr.Sw->id);
   }else if(NAdr.type == 'M' || NAdr.type == 'm'){
     printf("MSw %i:%i\n",NAdr.M->Module,NAdr.M->id);
   }
 }

 if(NAdr.type == 0){
  return 0;
 }else if(NAdr.type == 'R'){

  return 1;
 }
 else if(NAdr.type == 'S'){
  S = NAdr.Sw;
  if(incl_pref == (1==1) && S->pref[0] && S->pref[0]->type == 0 && S->pref[0]->state != (S->state & 0x7F)){
   if(debug)printf("Wrong state for the preference\n");
   return 0;
  }

  uint8_t SwState = S->state & 0x7F;
  if(SwState == 0 && S->str.type != 0){
   Adr = NAdr;
   NAdr = S->str;
  }else if(SwState == 1 && S->div.type != 0){
   Adr = NAdr;
   NAdr = S->div;
  }else{

   return 0;
  }

  goto R;
 }
 else if(NAdr.type == 'M'){
  int s = NAdr.M->state;
  if(Link_cmp(NAdr.M->M_Adr[s],Adr)){
   NAdr = NAdr.M->m_Adr[s];
   goto R;
  }else{
   return 0;
  }
 }
 else if(NAdr.type == 'm'){
  int s = NAdr.M->state;
  if(Link_cmp(NAdr.M->m_Adr[s],Adr)){
   NAdr = NAdr.M->M_Adr[s];
   goto R;
  }else{
   return 0;
  }
 }
 else if(NAdr.type == 's'){
  struct Rail_link Div = NAdr.Sw->div;
  struct Rail_link Str = NAdr.Sw->str;


  if(Link_cmp(Div,Adr)){
   if((NAdr.Sw->state & 0x7F) == 1){
    if(debug)printf("Diverging\n");
    n = 1;
   }else{
    if(debug)printf("Wrong Diverging\n");
    return 0;
   }
  }else if(Link_cmp(Str,Adr)){
   if((NAdr.Sw->state & 0x7F) == 0){
    if(debug)printf("Straight\n");
    n = 1;
   }else{
    if(debug)printf("Wrong Diverging\n");
    return 0;
   }
  }else{
   if(debug)printf("Failed Link_cmp\n");
   return 0;
  }


  Adr = NAdr;
  NAdr = NAdr.Sw->app;
  goto R;

 }

 return n;
}

int free_Switch(struct Seg *B, int direct){
 struct Rail_link Adr,NAdr,SNAdr;

 int debug = 0;

 if(B->Module == 4 && B->id == 17){
  debug = 1;
 }

 Adr.type = 'R';Adr.B = B;Adr.Sw = 0;Adr.M = 0;Adr.Si = 0;
 int return_Value = 1;
 int dir = B->dir;

 if(direct == 0){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Next;
  }else{
   NAdr = B->Prev;
  }
 }else{
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Prev;
  }else{
   NAdr = B->Next;
  }
 }

 R:{};
 if(debug){
   printf("Switch P type:%c\t",NAdr.type);
   if(NAdr.type == 'R'){
     printf("R   %i:%i\n",NAdr.B->Module,NAdr.B->id);
   }else if(NAdr.type == 'S' || NAdr.type == 's'){
     printf("Sw  %i:%i\n",NAdr.Sw->Module,NAdr.Sw->id);
   }else if(NAdr.type == 'M' || NAdr.type == 'm'){
     printf("MSw %i:%i\n",NAdr.M->Module,NAdr.M->id);
   }
 }

 if(return_Value == 0){
  return 0;
 }

 if(NAdr.type == 'S'){
  struct Swi * S = NAdr.Sw;
  uint8_t SwState = S->state & 0x3F;
  if(S->pref[0] && S->pref[0]->type == 0 && SwState != S->pref[0]->state){
   throw_switch(S);
  }
  if(SwState == 0 && S->str.type != 0){
   Adr = NAdr;
   NAdr = S->str;
  }else if(SwState == 1 && S->div.type != 0){
   Adr = NAdr;
   NAdr = S->div;
  }else{
   throw_switch(S);
  }
  goto R;
 }else if(NAdr.type == 's'){
  struct Rail_link Div = NAdr.Sw->div;
  struct Rail_link Str = NAdr.Sw->str;
  uint8_t SwState = NAdr.Sw->state & 0x3F;
  if(Link_cmp(Div,Adr)){
   if(SwState == 0){
    return_Value = throw_switch(NAdr.Sw);
   }
  }else if(Link_cmp(Str,Adr)){
   if(SwState == 1){
    return_Value = throw_switch(NAdr.Sw);
   }
  }


  Adr = NAdr;
  NAdr = NAdr.Sw->app;
  goto R;

 }else if(NAdr.type == 'M'){
  struct Mod * M = NAdr.M;
  int s = M->state;
  if(Link_cmp(M->M_Adr[s],Adr)){
   NAdr = M->m_Adr[s];
  }else{
   for(int i = 0;i<M->length;i++){
    if(Link_cmp(M->M_Adr[i],Adr)){
     return_Value = throw_ms_switch(M,i);
     break;
    }
   }
  }
  Adr = NAdr;
  NAdr = M->m_Adr[M->state];
  goto R;
 }else if(NAdr.type == 'm'){
  struct Mod * M = NAdr.M;
  int s = M->state;
  if(Link_cmp(M->m_Adr[s],Adr)){
   NAdr = M->M_Adr[s];
  }else{
   for(int i = 0;i<M->length;i++){
    if(Link_cmp(M->m_Adr[i],Adr)){
     return_Value = throw_ms_switch(M,i);
     break;
    }
   }
  }
  Adr = NAdr;
  NAdr = M->M_Adr[M->state];
  goto R;
 }
 return 1;
}

int free_Route_Switch(struct Seg *B, int direct, struct train * T){
 struct Rail_link Adr,NAdr,SNAdr;

 int debug = 0;

 if(B->Module == 4 && B->id == 17){
  debug = 1;
 }

 Adr.type = 'R';Adr.B = B;Adr.Sw = 0;Adr.M = 0;Adr.Si = 0;
 int return_Value = 1;
 int dir = B->dir;

 if(direct == 0){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Next;
  }else{
   NAdr = B->Prev;
  }
 }else{
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Prev;
  }else{
   NAdr = B->Next;
  }
 }

 R:{};

 if(return_Value == 0){
  return 0;
 }

 if(NAdr.type == 'S'){
  struct Swi * S = NAdr.Sw;
  Adr = NAdr;
  for(int x = 0;x<T->Sw_len;x++){
   if(T->Route[x]->adr.Sw == S && T->Route[x]->states > 0){
    char r = (rand() % T->Route[x]->states);
    printf("Random selected nr %i (state %i)\n",r,T->Route[x]->suc[r]);
    char state = T->Route[x]->suc[r];

    if(!set_switch(S,state))
     return 0;
    if(state == 0){
     printf("Straight\t");
     NAdr = S->str;
    }else if(state == 1){
     printf("Diverging\t");
     NAdr = S->div;
    }
   }
  }
  goto R;
 }
 else if(NAdr.type == 's'){
  struct Rail_link Div = NAdr.Sw->div;
  struct Rail_link Str = NAdr.Sw->str;
  uint8_t SwState = NAdr.Sw->state & 0x3F;
  if(Link_cmp(Div,Adr)){
   if(SwState == 0){
    return_Value = throw_switch(NAdr.Sw);
   }
  }else if(Link_cmp(Str,Adr)){
   if(SwState == 1){
    return_Value = throw_switch(NAdr.Sw);
   }
  }


  Adr = NAdr;
  NAdr = NAdr.Sw->app;
  goto R;

 }
 else if(NAdr.type == 'M'){
  struct Mod * M = NAdr.M;
  Adr = NAdr;
  for(int x = 0;x<T->Sw_len;x++){
   if(T->Route[x]->adr.M == M && T->Route[x]->states > 0){
    char state = T->Route[x]->suc[0];



    M->state = state;
    NAdr = M->m_Adr[state];
   }
  }
  goto R;
 }
 else if(NAdr.type == 'm'){
  struct Mod * M = NAdr.M;
  Adr = NAdr;
  for(int x = 0;x<T->Sw_len;x++){
   if(T->Route[x]->adr.M == M && T->Route[x]->states > 0){
    char state = T->Route[x]->suc[0];



    M->state = state;
    NAdr = M->M_Adr[state];
   }
  }
  goto R;
 }
 return 1;
}
# 62 "baan.c" 2
# 1 "./src/COM.h" 1
# 63 "baan.c" 2

int delayA = 5000000;
int delayB = 5000000;
int initialise = 1;
char setup_data[100];
char setup_data_l = 0;
int status_st[20] = {0};

_Bool digital_track = 0;

pthread_mutex_t mutex_lockA;
pthread_mutex_t mutex_lockB;
pthread_t timer_thread[5];
int timers[5] = {0};

struct adr Adresses[16*16*8] = {};

char List_of_Modules[16] = {0};

struct adr StartAdr;




# 1 "./src/modules.c" 1






void Create_Unit(int Module){
 struct Unit *Z = (struct Unit*)malloc(sizeof(struct Unit));

 Units[Module] = Z;
}

void Create_Unit2(int Module,int OUT,int IN){
 struct Unit *Z = (struct Unit*)malloc(sizeof(struct Unit));

 Units[Module] = Z;

 struct Rail_link ** A = (struct Rail_link**)calloc( IN,sizeof(struct Rail_link));
 struct Rail_link ** B = (struct Rail_link**)calloc(OUT,sizeof(struct Rail_link));

 Z->B_L = 8;
 Z->B = (struct Seg **)calloc(Z->B_L,sizeof(struct Seg *));

 Z->S_L = 8;
 Z->S = (struct Swi **)calloc(Z->S_L,sizeof(struct Swi *));

 for(int i = 0;i<16*8;i++){
  Z->M[i] = 0;
  Z->Signals[i] = 0;
 }

 Z->In_length = IN;
 Z->In = A;
 Z->Out_length = OUT;
 Z->Out = B;
 IN--;OUT--;
 Z->InRegs = (uint8_t *)malloc(( IN/8)+1);
 Z->OutRegs = (uint8_t *)malloc((OUT/8)+1);
 Z->BlinkMask = (uint8_t *)malloc((OUT/8)+1);
}

void join(struct SegC Adr, struct SegC link){
 printf("LINK %c%i:%i => %c%i:%i\t",Adr.type,Adr.Module,Adr.Adr,link.type,link.Module,link.Adr);
 if(Adr.type == 'R' && Units[Adr.Module]->B[Adr.Adr]){
  Units[Adr.Module]->B[Adr.Adr]->PrevC = link;
  printf("D\n");
 }else if(Adr.type == 'S'){
  Switch2[Adr.Module][Adr.Adr]->AppC = link;
 }else if(Adr.type == 's'){
  if(Adr_Comp2(Switch2[Adr.Module][Adr.Adr]->DivC, EMPTY_BL())){
   Switch2[Adr.Module][Adr.Adr]->DivC = link;
  }else{
   Switch2[Adr.Module][Adr.Adr]->StrC = link;
  }
 }
}

void clear_Modules(){

 for(int i = 0;i<16;i++){
   if(Units[i]){
    printf("Clearing module %i\n",i);

     printf("- Rail link out\n");
     free(Units[i]->Out);
     Units[i]->Out = ((void *)0);
     printf("- Rail link in\n");
     free(Units[i]->In);
     Units[i]->In = ((void *)0);


     for(int j = 0;j<=Units[i]->B_nr;j++){
       printf("- Block %i\n",j);
       free(Units[i]->B[j]);
       Units[i]->B[j] = ((void *)0);
     }

     for(int j = 0;j<=Units[i]->Swi_nr;j++){
      printf("- Switch %i\n",j);
       free(Units[i]->S[j]);
       Units[i]->S[j] = ((void *)0);
     }

     for(int j = 0;j<=Units[i]->Mod_nr;j++){
      printf("- Mod %i\n",j);
       free(Units[i]->M[j]);
       Units[i]->M[j] = ((void *)0);
     }

     for(int j = 0;j<=Units[i]->Signal_nr;j++){
      printf("- Signal %i\n",j);
       free(Units[i]->Signals[j]);
       Units[i]->Signals[j] = ((void *)0);
     }

     for(int j = 0;j<=Units[i]->Station_nr;j++){
      printf("- Station %i\n",j);
       free(Units[i]->St[j]);
       Units[i]->St[j] = ((void *)0);
     }

     printf("- Unit %i\n",i);
     free(Units[i]);
     Units[i] = 0;
     printf("\t Cleared!\n");
   }
 }
}

void LoadModules(int M){
 printf("Load module %i\n",M);

 return;


 FILE * fp;
 char * line = ((void *)0);
 size_t len = 0;
 ssize_t read;

 char folder[] = "./modules/";
 char filename[] = "/prop.txt";
 char file[30] = "";

 char nr[3] = "";
 strtol(M,nr,10);

 strcat(file,folder);
 strcat(file,itoa(M));
 strcat(file,filename);

 fp = fopen(file, "r");
 if (fp == ((void *)0)){
        printf("Failed to open File: %s\n",file);
  return;
 }



 while ((read = getline(&line, &len, fp)) != -1) {
  if(line[0] == '\'')
   continue;

         printf("\nRetrieved line of length %02zu : ", read);

  char * p = strtok(line,"\t\r\n");
  char * parts[20];
  char i = 0;

  while(p != ((void *)0)){
   printf("%s  ",p);
   parts[i++] = p;
   p = strtok(((void *)0), "\t\r\n");
  }
  printf("\n");

  struct link IN;

  struct link link;
  link.Adr3 = EMPTY_BL();
  link.Adr4 = EMPTY_BL();

  if(parts[0][0] == 'C'){
   if(strcmp(parts[0],"CU") == 0){

    ModuleID = atoi(parts[1]);
    Create_Unit2(ModuleID,atoi(parts[2]),atoi(parts[3]));

   }else if(strcmp(parts[0],"CB") == 0){


    struct SegC Adr,NAdr,PAdr;
    Adr = CAdr(ModuleID,atoi(parts[2]),parts[3][0]);


    if(parts[4][0] == 'I' && parts[4][1] != 0){
     if(parts[4][1] == '1'){
      NAdr = IN.Adr1;
     }else if(parts[4][1] == '2'){
      NAdr = IN.Adr2;
     }
    }
    else if(parts[4][0] == 'E'){
     if(parts[4][1] == '1'){
      link.Adr1.Module = ModuleID;link.Adr1.Adr = atoi(parts[2]);link.Adr1.type = parts[3][0];
     }else if(parts[4][1] == '2'){
      link.Adr2.Module = ModuleID;link.Adr2.Adr = atoi(parts[2]);link.Adr2.type = parts[3][0];
     }else if(parts[4][1] == '3'){
      link.Adr3.Module = ModuleID;link.Adr3.Adr = atoi(parts[2]);link.Adr3.type = parts[3][0];
     }else if(parts[4][1] == '4'){
      link.Adr4.Module = ModuleID;link.Adr4.Adr = atoi(parts[2]);link.Adr4.type = parts[3][0];
     }
     NAdr = EMPTY_BL();
    }
    else{
     if(parts[4][0] == 'X'){
      NAdr = CAdr(ModuleID,atoi(parts[5]),parts[6][0]);
     }else{
      NAdr = CAdr(atoi(parts[4]),atoi(parts[5]),parts[6][0]);
     }
    }


    if(parts[7][0] == 'I' && parts[7][1] != 0){
     if(parts[7][1] == '1'){
      PAdr = IN.Adr1;
     }else if(parts[7][1] == '2'){
      PAdr = IN.Adr2;
     }
    }
    else if(parts[7][0] == 'E'){
     if(parts[7][1] == '1'){
      link.Adr1.Module = ModuleID;link.Adr1.Adr = atoi(parts[2]);link.Adr1.type = parts[3][0];
     }else if(parts[7][1] == '2'){
      link.Adr2.Module = ModuleID;link.Adr2.Adr = atoi(parts[2]);link.Adr2.type = parts[3][0];
     }else if(parts[7][1] == '3'){
      link.Adr3.Module = ModuleID;link.Adr3.Adr = atoi(parts[2]);link.Adr3.type = parts[3][0];
     }else if(parts[7][1] == '4'){
      link.Adr4.Module = ModuleID;link.Adr4.Adr = atoi(parts[2]);link.Adr4.type = parts[3][0];
     }
     PAdr = EMPTY_BL();
    }
    else{
     if(parts[7][0] == 'X'){
      PAdr = CAdr(ModuleID,atoi(parts[8]),parts[9][0]);
     }else{
      PAdr = CAdr(atoi(parts[7]),atoi(parts[8]),parts[9][0]);
     }
    }

    Create_Segment(atoi(parts[1]),Adr,NAdr,PAdr,atoi(parts[10]),0,atoi(parts[11]),atoi(parts[12]));
   }else if(strcmp(parts[0],"CSw") == 0){


    struct SegC Adr,AAdr,SAdr,DAdr;
    Adr = CAdr(ModuleID,atoi(parts[1]),atoi(parts[11]));


    if(parts[2][0] == 'I' && parts[2][1] != 0){
     if(parts[2][1] == '1'){
      AAdr = IN.Adr1;
     }else if(parts[2][1] == '2'){
      AAdr = IN.Adr2;
     }
    }
    else if(parts[2][0] == 'E'){
     if(parts[2][1] == '1'){
      link.Adr1.Module = ModuleID;link.Adr1.Adr = atoi(parts[2]);link.Adr1.type = 'S';
     }else if(parts[2][1] == '2'){
      link.Adr2.Module = ModuleID;link.Adr2.Adr = atoi(parts[2]);link.Adr2.type = 'S';
     }else if(parts[2][1] == '3'){
      link.Adr3.Module = ModuleID;link.Adr3.Adr = atoi(parts[2]);link.Adr3.type = 'S';
     }else if(parts[2][1] == '4'){
      link.Adr4.Module = ModuleID;link.Adr4.Adr = atoi(parts[2]);link.Adr4.type = 'S';
     }
     AAdr = EMPTY_BL();
    }
    else{
     if(parts[2][0] == 'X'){
      AAdr = CAdr(ModuleID,atoi(parts[3]),parts[4][0]);
     }else{
      AAdr = CAdr(atoi(parts[2]),atoi(parts[3]),parts[4][0]);
     }
    }


    if(parts[5][0] == 'I' && parts[6][1] != 0){
     if(parts[5][1] == '1'){
      DAdr = IN.Adr1;
     }else if(parts[5][1] == '2'){
      DAdr = IN.Adr2;
     }
    }
    else if(parts[5][0] == 'E'){
     if(parts[5][1] == '1'){
      link.Adr1.Module = ModuleID;link.Adr1.Adr = atoi(parts[2]);link.Adr1.type = 's';
     }else if(parts[5][1] == '2'){
      link.Adr2.Module = ModuleID;link.Adr2.Adr = atoi(parts[2]);link.Adr2.type = 's';
     }else if(parts[5][1] == '3'){
      link.Adr3.Module = ModuleID;link.Adr3.Adr = atoi(parts[2]);link.Adr3.type = 's';
     }else if(parts[5][1] == '4'){
      link.Adr4.Module = ModuleID;link.Adr4.Adr = atoi(parts[2]);link.Adr4.type = 's';
     }
     DAdr = EMPTY_BL();
    }
    else{
     if(parts[5][0] == 'X'){
      DAdr = CAdr(ModuleID,atoi(parts[6]),parts[7][0]);
     }else{
      DAdr = CAdr(atoi(parts[5]),atoi(parts[6]),parts[7][0]);
     }
    }


    if(parts[8][0] == 'I' && parts[9][1] != 0){
     if(parts[8][1] == '1'){
      SAdr = IN.Adr1;
     }else if(parts[8][1] == '2'){
      SAdr = IN.Adr2;
     }
    }
    else if(parts[8][0] == 'E'){
     if(parts[8][1] == '1'){
      link.Adr1.Module = ModuleID;link.Adr1.Adr = atoi(parts[2]);link.Adr1.type = 's';
     }else if(parts[8][1] == '2'){
      link.Adr2.Module = ModuleID;link.Adr2.Adr = atoi(parts[2]);link.Adr2.type = 's';
     }else if(parts[8][1] == '3'){
      link.Adr3.Module = ModuleID;link.Adr3.Adr = atoi(parts[2]);link.Adr3.type = 's';
     }else if(parts[8][1] == '4'){
      link.Adr4.Module = ModuleID;link.Adr4.Adr = atoi(parts[2]);link.Adr4.type = 's';
     }
     SAdr = EMPTY_BL();
    }
    else{
     if(parts[8][0] == 'X'){
      SAdr = CAdr(ModuleID,atoi(parts[9]),parts[10][0]);
     }else{
      SAdr = CAdr(atoi(parts[8]),atoi(parts[9]),parts[10][0]);
     }
    }

    int IOAddress[20];
    char * q;
    i = 0;
    q = strtok(parts[12], " ");

    while(q != ((void *)0)){
     IOAddress[i++] = atoi(q);
     q = strtok(((void *)0), " ");
    }

    Create_Switch(Adr,AAdr,DAdr,SAdr,IOAddress,0);

   }else if(strcmp(parts[0],"CSi") == 0){
    printf("Create Signals");
   }else if(strcmp(parts[0],"CSt") == 0){
    printf("Create Station/Stop");
   }
  }else if(parts[0][0] == 'S'){
   if(strcmp(parts[0],"Sdet") == 0){

    Units[ModuleID]->S[atoi(parts[1])]->Detection_Block = Units[ModuleID]->B[atoi(parts[2])];
   }
  }else if(strcmp(parts[0],"J") == 0){

   if(atoi(parts[1]) == 1){
    join(IN.Adr1,CAdr(ModuleID,atoi(parts[2]),parts[3][0]));
   }else if(atoi(parts[1]) == 2){
    join(IN.Adr2,CAdr(ModuleID,atoi(parts[2]),parts[3][0]));
   }
  }
  }



 fclose(fp);
 if (line)
        free(line);
}

struct link Modules(int m, struct link IN){

 struct link link;
 link.Adr3 = EMPTY_BL();
 link.Adr4 = EMPTY_BL();

 int Seg_i = 0;
 int Swi_i = 0;
 int Sig_i = 0;

 if(m == 1){
  Create_Unit2(m,8,8);
# 383 "./src/modules.c"
  link.Adr1.Module = m;link.Adr1.Adr = 0;link.Adr1.type = 'R';
  link.Adr2.Module = m;link.Adr2.Adr = 3;link.Adr2.type = 'R';


  join(IN.Adr1,CAdr(m,1,'s'));
  join(IN.Adr2,CAdr(m,0,'s'));

  Create_Segment(0,CAdr(m,0,'R'),CAdr(m,1,'R'),EMPTY_BL(), 250,0,0,100);
  Create_Segment(1,CAdr(m,1,'R'),CAdr(m,1,'S'),CAdr(m,0,'R'),250,0,2,100);
   Create_Segment(2,CAdr(m,2,'R'),CAdr(m,0,'S'),CAdr(m,3,'R'),250,0,1,100);
   Create_Segment(3,CAdr(m,3,'R'),CAdr(m,2,'R'),EMPTY_BL(), 250,0,1,100);


  Create_Switch(CAdr(m,1,2),CAdr(m,1,'R'),CAdr(m,0,'s'),IN.Adr1,(int [2]){2,3},1);
  Create_Switch(CAdr(m,0,2),CAdr(m,2,'R'),CAdr(m,1,'s'),IN.Adr2,(int [2]){0,1},0);

  Units[m]->S[0]->Detection_Block = Units[m]->B[2];
  Units[m]->S[1]->Detection_Block = Units[m]->B[1];
 }
 else if(m == 2){
  Create_Unit2(m,8,8);






  link.Adr1.Module = m;link.Adr1.Adr = 1;link.Adr1.type = 's';
  link.Adr2.Module = m;link.Adr2.Adr = 0;link.Adr2.type = 's';



  join(IN.Adr1,CAdr(m,0,'R'));
  join(IN.Adr2,CAdr(m,3,'R'));

  Create_Segment(0,CAdr(m,0,'R'),IN.Adr1,CAdr(m,1,'R'),250,0,0,100);
  Create_Segment(1,CAdr(m,1,'R'),CAdr(m,0,'R'),CAdr(m,1,'S'),250,0,2,100);
   Create_Segment(2,CAdr(m,2,'R'),CAdr(m,3,'R'),CAdr(m,0,'S'),250,0,1,100);
   Create_Segment(3,CAdr(m,3,'R'),IN.Adr2,CAdr(m,2,'R'),250,0,1,100);

  Create_Switch(CAdr(m,0,2),CAdr(m,2,'R'),CAdr(m,1,'s'),EMPTY_BL(),(int [2]){0,1},1);
  Create_Switch(CAdr(m,1,2),CAdr(m,1,'R'),CAdr(m,0,'s'),EMPTY_BL(),(int [2]){2,3},1);

  Units[m]->S[0]->Detection_Block = Units[m]->B[2];
  Units[m]->S[1]->Detection_Block = Units[m]->B[1];
 }
 else if(m == 3){
  Create_Unit2(m,8,8);
# 457 "./src/modules.c"
  link.Adr1.Module = m;link.Adr1.Adr = 7;link.Adr1.type = 'R';
  link.Adr2.Module = m;link.Adr2.Adr = 17;link.Adr2.type = 'R';



  join(IN.Adr1,CAdr(m,0,'R'));
  join(IN.Adr2,CAdr(m,8,'R'));

  Create_Switch(CAdr(m,0,2),CAdr(m,0,'R'),CAdr(m,2,'s') ,CAdr(m,1,'S') ,(int [2]){000,001},0);
  Create_Switch(CAdr(m,1,2),CAdr(m,0,'s'),CAdr(m,2,'R') ,CAdr(m,4,'R') ,(int [2]){002,003},1);
  Create_Switch(CAdr(m,2,2),CAdr(m,3,'S'),CAdr(m,0,'s') ,CAdr(m,8,'R') ,(int [2]){004,005},0);
  Create_Switch(CAdr(m,3,2),CAdr(m,2,'S'),CAdr(m,4,'S') ,CAdr(m,10,'R'),(int [2]){006,007},1);
  Create_Switch(CAdr(m,4,2),CAdr(m,3,'s'),CAdr(m,12,'R'),CAdr(m,14,'R'),(int [2]){010,011},1);
  Create_Switch(CAdr(m,5,2),CAdr(m,6,'s'),CAdr(m,3,'R') ,CAdr(m,5,'R') ,(int [2]){020,021},1);
  Create_Switch(CAdr(m,6,2),CAdr(m,7,'R'),CAdr(m,8,'s') ,CAdr(m,5,'S') ,(int [2]){022,023},0);
  Create_Switch(CAdr(m,7,2),CAdr(m,8,'S'),CAdr(m,9,'S') ,CAdr(m,11,'R'),(int [2]){024,025},1);
  Create_Switch(CAdr(m,8,2),CAdr(m,7,'S'),CAdr(m,6,'s') ,CAdr(m,17,'R'),(int [2]){026,027},0);
  Create_Switch(CAdr(m,9,2),CAdr(m,7,'s'),CAdr(m,13,'R'),CAdr(m,15,'R'),(int [2]){030,031},1);

  Create_Segment(0,CAdr(m,0,'R'),IN.Adr1,CAdr(m,0,'S'),140,0,0,100);
  Create_Segment(1,CAdr(m,1,'T'),EMPTY_BL(),EMPTY_BL(),140,0,0,100);

  Create_Segment(010,CAdr(m,2,'R'),CAdr(m,1,'s'),CAdr(m,3,'R') ,90,0,0,50);
  Create_Segment(011,CAdr(m,3,'R'),CAdr(m,2,'R'),CAdr(m,5,'s'),90,0,0,50);
  Create_Segment(012,CAdr(m,4,'R'),CAdr(m,1,'s'),CAdr(m,5,'R'), 90,0,0,50);
  Create_Segment(013,CAdr(m,5,'R'),CAdr(m,4,'R'),CAdr(m,5,'s'),90,0,0,50);

  Create_Segment(030,CAdr(m,6,'T'),EMPTY_BL(),EMPTY_BL(),140,0,0,50);
  Create_Segment(031,CAdr(m,7,'R'),CAdr(m,6,'S'),EMPTY_BL(),140,0,0,100);


  Create_Segment(2,CAdr(m,8,'R'),EMPTY_BL(),CAdr(m,2,'s'),140,0,1,50);
  Create_Segment(3,CAdr(m,9,'T'),EMPTY_BL(),EMPTY_BL(),140,0,1,50);

  Create_Segment(014,CAdr(m,10,'R'),CAdr(m,3,'s') ,CAdr(m,11,'R'),90,0,0,50);
  Create_Segment(015,CAdr(m,11,'R'),CAdr(m,10,'R'),CAdr(m,7,'s') ,90,0,0,50);
  Create_Segment(016,CAdr(m,12,'R'),CAdr(m,4,'s') ,CAdr(m,13,'R'),90,0,0,50);
  Create_Segment(017,CAdr(m,13,'R'),CAdr(m,12,'R'),CAdr(m,9,'s') ,90,0,0,50);
  Create_Segment(020,CAdr(m,14,'R'),CAdr(m,4,'s') ,CAdr(m,15,'R'),90,0,0,50);
  Create_Segment(021,CAdr(m,15,'R'),CAdr(m,14,'R'),CAdr(m,9,'s') ,90,0,0,50);

  Create_Segment(032,CAdr(m,16,'T'),EMPTY_BL(),EMPTY_BL(),140,0,0,50);
  Create_Segment(033,CAdr(m,17,'R'),CAdr(m,8,'s'),EMPTY_BL(),140,0,1,50);
 }
 else if(m == 4){
  Create_Unit2(m,8,32);
# 530 "./src/modules.c"
  link.Adr1.Module = m;link.Adr1.Adr = 11;link.Adr1.type = 'R';
  link.Adr2.Module = m;link.Adr2.Adr = 27;link.Adr2.type = 'R';



  join(IN.Adr1,CAdr(m,0,'R'));
  join(IN.Adr2,CAdr(m,12,'R'));

  Create_Switch(CAdr(m,0,2),CAdr(m,0,'R'),CAdr(m,2,'s') ,CAdr(m,1,'S') ,(int [2]){000,001},0);
  Create_Switch(CAdr(m,1,2),CAdr(m,0,'s'),CAdr(m,2,'R') ,CAdr(m,6,'R') ,(int [2]){002,003},1);
  Create_Switch(CAdr(m,2,2),CAdr(m,3,'S'),CAdr(m,0,'s') ,CAdr(m,12,'R'),(int [2]){004,005},0);
  Create_Switch(CAdr(m,3,2),CAdr(m,2,'S'),CAdr(m,4,'S') ,CAdr(m,14,'R'),(int [2]){006,007},1);
  Create_Switch(CAdr(m,4,2),CAdr(m,3,'s'),CAdr(m,18,'R'),CAdr(m,22,'R'),(int [2]){010,011},1);
  Create_Switch(CAdr(m,5,2),CAdr(m,6,'s'),CAdr(m,5,'R') ,CAdr(m,9,'R') ,(int [2]){020,021},1);
  Create_Switch(CAdr(m,6,2),CAdr(m,11,'R'),CAdr(m,8,'s'),CAdr(m,5,'S') ,(int [2]){022,023},0);
  Create_Switch(CAdr(m,7,2),CAdr(m,8,'S'),CAdr(m,9,'S') ,CAdr(m,17,'R'),(int [2]){024,025},1);
  Create_Switch(CAdr(m,8,2),CAdr(m,7,'S'),CAdr(m,6,'s') ,CAdr(m,27,'R'),(int [2]){026,027},0);
  Create_Switch(CAdr(m,9,2),CAdr(m,7,'s'),CAdr(m,21,'R'),CAdr(m,25,'R'),(int [2]){030,031},1);

  Create_Segment(0,CAdr(m,0,'R'),IN.Adr1,CAdr(m,0,'S'),140,0,0,100);
  Create_Segment(1,CAdr(m,1,'T'),EMPTY_BL(),EMPTY_BL(),140,0,0,100);

  Create_Segment(010,CAdr(m,2,'S'),CAdr(m,1,'s'),CAdr(m,3,'R'),90,0,0,50);
  Create_Segment(011,CAdr(m,3,'S'),CAdr(m,2,'R'),CAdr(m,4,'R'),90,0,0,50);
  Create_Segment(030,CAdr(m,4,'S'),CAdr(m,3,'R'),CAdr(m,5,'R'),90,0,0,50);
  Create_Segment(031,CAdr(m,5,'S'),CAdr(m,4,'R'),CAdr(m,5,'s'),90,0,0,50);

  Create_Segment(012,CAdr(m,6,'S'),CAdr(m,1,'s'),CAdr(m,7,'R'),90,0,0,50);
  Create_Segment(013,CAdr(m,7,'S'),CAdr(m,6,'R'),CAdr(m,8,'R'),90,0,0,50);
  Create_Segment(032,CAdr(m,8,'S'),CAdr(m,7,'R'),CAdr(m,9,'R'),90,0,0,50);
  Create_Segment(033,CAdr(m,9,'S'),CAdr(m,8,'R'),CAdr(m,5,'s'),90,0,0,50);

  Create_Segment(050,CAdr(m,10,'T'),EMPTY_BL(),EMPTY_BL(),140,0,0,50);
  Create_Segment(051,CAdr(m,11,'R'),CAdr(m,6,'S'),EMPTY_BL(),140,0,0,100);


  Create_Segment(2,CAdr(m,12,'R'),IN.Adr2,CAdr(m,2,'s'),140,0,1,50);
  Create_Segment(3,CAdr(m,13,'T'),EMPTY_BL(),EMPTY_BL(),140,0,1,50);

  Create_Segment(014,CAdr(m,14,'S'),CAdr(m,3,'s') ,CAdr(m,15,'R'),90,0,1,50);
  Create_Segment(015,CAdr(m,15,'S'),CAdr(m,14,'R'),CAdr(m,16,'R'),90,0,1,50);
  Create_Segment(034,CAdr(m,16,'S'),CAdr(m,15,'R'),CAdr(m,17,'R'),90,0,1,50);
  Create_Segment(035,CAdr(m,17,'S'),CAdr(m,16,'R'),CAdr(m,7 ,'s'),90,0,1,50);

  Create_Segment(016,CAdr(m,18,'S'),CAdr(m,4,'s') ,CAdr(m,19,'R'),90,0,1,50);
  Create_Segment(017,CAdr(m,19,'S'),CAdr(m,18,'R'),CAdr(m,20,'R'),90,0,1,50);
  Create_Segment(036,CAdr(m,20,'S'),CAdr(m,19,'R'),CAdr(m,21,'R'),90,0,1,50);
  Create_Segment(037,CAdr(m,21,'S'),CAdr(m,20,'R'),CAdr(m,9,'s') ,90,0,1,50);

  Create_Segment(020,CAdr(m,22,'S'),CAdr(m,4,'s'),CAdr(m,23,'R'),90,0,1,50);
  Create_Segment(021,CAdr(m,23,'S'),CAdr(m,22,'R'),CAdr(m,24,'R'),90,0,1,50);
  Create_Segment(040,CAdr(m,24,'S'),CAdr(m,23,'R'),CAdr(m,25,'R'),90,0,1,50);
  Create_Segment(041,CAdr(m,25,'S'),CAdr(m,24,'R'),CAdr(m,9,'s'),90,0,1,50);

  Create_Segment(052,CAdr(m,26,'T'),EMPTY_BL(),EMPTY_BL(),140,0,1,50);
  Create_Segment(053,CAdr(m,27,'R'),CAdr(m,8,'s'),EMPTY_BL(),140,0,1,50);

  Units[m]->S[0]->Detection_Block = Units[m]->B[1];
  Units[m]->S[1]->Detection_Block = Units[m]->B[1];
  Units[m]->S[2]->Detection_Block = Units[m]->B[13];
  Units[m]->S[3]->Detection_Block = Units[m]->B[13];
  Units[m]->S[4]->Detection_Block = Units[m]->B[13];

  Units[m]->S[5]->Detection_Block = Units[m]->B[10];
  Units[m]->S[6]->Detection_Block = Units[m]->B[10];
  Units[m]->S[7]->Detection_Block = Units[m]->B[26];
  Units[m]->S[8]->Detection_Block = Units[m]->B[26];
  Units[m]->S[9]->Detection_Block = Units[m]->B[26];


   struct L_Swi_t * B_Swi = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));
   struct SegC ADR = CAdr(m,0,'S');
   B_Swi->Adr = ADR;
   B_Swi->states[0] = 0;
   B_Swi->states[1] = 1;
   Switch2[m][2]->L_Swi[0] = B_Swi;
   Switch2[m][6]->L_Swi[0] = B_Swi;
   Switch2[m][8]->L_Swi[0] = B_Swi;

   B_Swi = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));

   ADR.Adr = 2;
   B_Swi->Adr = ADR;
   B_Swi->states[0] = 0;
   B_Swi->states[1] = 1;
   Switch2[m][0]->L_Swi[0] = B_Swi;
   Switch2[m][6]->L_Swi[1] = B_Swi;
   Switch2[m][8]->L_Swi[1] = B_Swi;

   B_Swi = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));

    ADR.Adr = 6;
    B_Swi->Adr = ADR;
   B_Swi->states[0] = 0;
   B_Swi->states[1] = 1;
   Switch2[m][0]->L_Swi[1] = B_Swi;
   Switch2[m][2]->L_Swi[1] = B_Swi;
   Switch2[m][8]->L_Swi[2] = B_Swi;

   B_Swi = (struct L_Swi_t*)malloc(sizeof(struct L_Swi_t));

    ADR.Adr = 8;
    B_Swi->Adr = ADR;
   B_Swi->states[0] = 0;
   B_Swi->states[1] = 1;
   Switch2[m][0]->L_Swi[2] = B_Swi;
   Switch2[m][2]->L_Swi[2] = B_Swi;
   Switch2[m][6]->L_Swi[2] = B_Swi;



   struct P_Swi_t * P = (struct P_Swi_t *)malloc(sizeof(struct P_Swi_t));
   P->type = 0;
   P->state = 0;
   Switch2[m][8]->pref[0] = P;
   P = (struct P_Swi_t *)malloc(sizeof(struct P_Swi_t));
   P->type = 0;
   P->state = 1;
   Switch2[m][2]->pref[0] = P;


   Create_Station(m,"Spoor 1",1,4,(int [4]){2,3,4,5});
   Create_Station(m,"Spoor 2",1,4,(int [4]){6,7,8,9});
   Create_Station(m,"Spoor 3",1,4,(int [4]){14,15,16,17});
   Create_Station(m,"Spoor 4",1,4,(int [4]){18,19,20,21});
   Create_Station(m,"Spoor 5",1,4,(int [4]){22,23,24,25});





   uint8_t adr[3] = {0,1,2};
   struct Seg ** block_id = Units[m]->B;
   char b[4] = {1,2,4};
   char c[4] = {1,0,0};

   create_signal2(block_id[2],3,adr,b,c,0);

   memset(adr,0,3);memset(b,0,4);memset(c,0,4);
   adr[0] = 3;adr[1] = 4;adr[2] = 5;
   b[0] = 1;b[1] = 2;b[2] = 4;
   c[0] = 1;c[1] = 0;c[2] = 0;

   create_signal2(block_id[6],3,adr,b,c,0);


   memset(adr,0,3);memset(b,0,4);memset(c,0,4);
   adr[0] = 16;adr[1] = 17;adr[2] = 18;
   b[0] = 1;b[1] = 2;b[2] = 4;
   c[0] = 1;c[1] = 0;c[2] = 0;

   create_signal2(block_id[17],3,adr,b,c,0);

   memset(adr,0,3);memset(b,0,4);memset(c,0,4);
   adr[0] = 19;adr[1] = 20;adr[2] = 21;
   b[0] = 1;b[1] = 2;b[2] = 4;
   c[0] = 1;c[1] = 0;c[2] = 0;

   create_signal2(block_id[21],3,adr,b,c,0);

   memset(adr,0,3);memset(b,0,4);memset(c,0,4);
   adr[0] = 22;adr[1] = 23;adr[2] = 24;
   b[0] = 1;b[1] = 2;b[2] = 4;
   c[0] = 1;c[1] = 0;c[2] = 0;

   create_signal2(block_id[25],3,adr,b,c,0);



   memset(adr,0,3);memset(b,0,4);memset(c,0,4);
   adr[0] = 7;adr[1] = 8;adr[2] = 9;
   b[0] = 1;b[1] = 2;b[2] = 4;
   c[0] = 0;c[1] = 0;c[2] = 0;

   create_signal2(block_id[14],3,adr,b,c,1);

   memset(adr,0,3);memset(b,0,4);memset(c,0,4);
   adr[0] = 10;adr[1] = 11;adr[2] = 12;
   b[0] = 1;b[1] = 2;b[2] = 4;
   c[0] = 0;c[1] = 0;c[2] = 0;

   create_signal2(block_id[18],3,adr,b,c,1);

   memset(adr,0,3);memset(b,0,4);memset(c,0,4);
   adr[0] = 13;adr[1] = 14;adr[2] = 15;
   b[0] = 1;b[1] = 2;b[2] = 4;
   c[0] = 0;c[1] = 0;c[2] = 0;

   create_signal2(block_id[22],3,adr,b,c,1);


   Units[m]->B[0]->oneWay = (1==1);
   Units[m]->B[11]->oneWay = (1==1);
   Units[m]->B[12]->oneWay = (1==1);
   Units[m]->B[27]->oneWay = (1==1);


  Units[m]->B[1]->dir = 0;
  Units[m]->B[10]->dir = 0;
  Units[m]->B[13]->dir = 1;
  Units[m]->B[26]->dir = 1;

 }
# 846 "./src/modules.c"
 else if(m == 8 || m == 9 || m == 10 || m == 12 || m == 13 || m == 14){
  Create_Unit2(m,8,8);
# 857 "./src/modules.c"
  link.Adr1.Module = m;link.Adr1.Adr = 3;link.Adr1.type = 'R';
  link.Adr2.Module = m;link.Adr2.Adr = 7;link.Adr2.type = 'R';



  join(IN.Adr1,CAdr(m,0,'R'));
  join(IN.Adr2,CAdr(m,4,'R'));

  Create_Segment(0 ,CAdr(m,0,'R'),IN.Adr1 ,CAdr(m,1,'R'),250,0,0,100);
  Create_Segment(02 ,CAdr(m,1,'R'),CAdr(m,0,'R'),CAdr(m,2,'R'),250,0,0,100);
  Create_Segment(010,CAdr(m,2,'R'),CAdr(m,1,'R'),CAdr(m,3,'R'),250,0,0,100);
  Create_Segment(012,CAdr(m,3,'R'),CAdr(m,2,'R'),EMPTY_BL() ,250,0,0,100);

  Create_Segment(1 ,CAdr(m,4,'R'),IN.Adr2 ,CAdr(m,5,'R'),250,0,1,100);
  Create_Segment(03 ,CAdr(m,5,'R'),CAdr(m,4,'R'),CAdr(m,6,'R'),250,0,1,100);
  Create_Segment(011,CAdr(m,6,'R'),CAdr(m,5,'R'),CAdr(m,7,'R'),250,0,1,100);
  Create_Segment(013,CAdr(m,7,'R'),CAdr(m,6,'R'),EMPTY_BL() ,250,0,1,100);
 }
 else if(m == 11){
  Create_Unit2(m,8,8);

  link.Adr1.Module = m;link.Adr1.Adr = 0;link.Adr1.type = 'R';
  link.Adr2.Module = m;link.Adr2.Adr = 1;link.Adr2.type = 'R';

  join(IN.Adr1,CAdr(m,0,'R'));
  join(IN.Adr2,CAdr(m,1,'R'));

  Create_Segment(0,CAdr(m,0,'R'),IN.Adr1,EMPTY_BL(),250,0,0,100);
  Create_Segment(1,CAdr(m,1,'R'),IN.Adr2,EMPTY_BL(),250,0,1,100);
 }
 return link;
}

void LoadModules(int M){
 printf("Loading Module %i\n",M);




 FILE * fp;
 char * line = ((void *)0);
 size_t len = 0;
 ssize_t read;

 char folder[] = "./modules/";
 char filename[] = "/prop.txt";
 char file[30] = "";

 strcat(file,folder);
 strcat(file,itoa(M));
 strcat(file,filename);

 fp = fopen(file, "r");
 if (fp == ((void *)0)){
        printf("Failed to open File: %s\n",file);
  return;
 }

 return;

 int ModuleID;

 while ((read = getline(&line, &len, fp)) != -1) {
  if(line[0] == '\'')
   continue;

         printf("\nRetrieved line of length %02zu : ", read);

  char * p = strtok(line,"\t\r\n");
  char * parts[20];
  char i = 0;

  while(p != ((void *)0)){
   printf("%s  ",p);
   parts[i++] = p;
   p = strtok(((void *)0), "\t\r\n");
  }
  printf("\n");

  if(parts[0][0] == 'C'){
   if(strcmp(parts[0],"CU") == 0){

    ModuleID = atoi(parts[1]);
    Create_Unit2(ModuleID,atoi(parts[2]),atoi(parts[3]));

   }else if(strcmp(parts[0],"CB") == 0){


    struct SegC Adr,NAdr,PAdr;
    Adr = C_Adr(ModuleID,atoi(parts[2]),parts[3][0]);


    if(parts[4][0] == 'C'){
     NAdr = C_Adr(ModuleID,0,'C');
    }
    else if(parts[4][0] == 'E'){
     NAdr = EMPTY_BL();
    }
    else{
     if(parts[4][0] == 'X'){
      NAdr = CAdr(ModuleID,atoi(parts[5]),parts[6][0]);
     }else{
      NAdr = CAdr(atoi(parts[4]),atoi(parts[5]),parts[6][0]);
     }
    }


    if(parts[7][0] == 'C'){
     NAdr = C_Adr(ModuleID,0,'C');
    }
    else if(parts[7][0] == 'E'){
     PAdr = EMPTY_BL();
    }
    else{
     if(parts[7][0] == 'X'){
      PAdr = CAdr(ModuleID,atoi(parts[8]),parts[9][0]);
     }else{
      PAdr = CAdr(atoi(parts[7]),atoi(parts[8]),parts[9][0]);
     }
    }

    Create_Segment(atoi(parts[1]),Adr,NAdr,PAdr,atoi(parts[10]),0,atoi(parts[11]),atoi(parts[12]));

    if(parts[13][0] == "Y"){
     Units[ModuleID]->B[Adr.Adr]->oneWay = (1==1);
    }
   }else if(strcmp(parts[0],"CSw") == 0){


    struct SegC Adr,AAdr,SAdr,DAdr;
    Adr = CAdr(ModuleID,atoi(parts[1]),atoi(parts[12]));


    if(parts[3][0] == 'C'){
     AAdr = C_Adr(ModuelID,0,'C');
    }
    else if(parts[3][0] == 'E'){
     AAdr = EMPTY_BL();
    }
    else{
     if(parts[3][0] == 'X'){
      AAdr = CAdr(ModuleID,atoi(parts[4]),parts[5][0]);
     }else{
      AAdr = CAdr(atoi(parts[3]),atoi(parts[4]),parts[5][0]);
     }
    }


    if(parts[9][0] == 'C'){
     NAdr = C_Adr(ModuleID,0,'C');
    }
    else if(parts[9][0] == 'E'){
     DAdr = EMPTY_BL();
    }
    else{
     if(parts[9][0] == 'X'){
      DAdr = CAdr(ModuleID,atoi(parts[10]),parts[11][0]);
     }else{
      DAdr = CAdr(atoi(parts[9]),atoi(parts[10]),parts[11][0]);
     }
    }


    if(parts[6][0] == 'C'){
     NAdr = C_Adr(ModuleID,0,'C');
    }
    else if(parts[6][0] == 'E'){
     SAdr = EMPTY_BL();
    }
    else{
     if(parts[6][0] == 'X'){
      SAdr = CAdr(ModuleID,atoi(parts[7]),parts[8][0]);
     }else{
      SAdr = CAdr(atoi(parts[6]),atoi(parts[7]),parts[8][0]);
     }
    }

    int IOAddress[20];
    char * q;
    i = 0;
    q = strtok(parts[12], " ");

    while(q != ((void *)0)){
     IOAddress[i++] = atoi(q);
     q = strtok(((void *)0), " ");
    }

    int StateSpeed[20];
    i = 0;
    q = strtok(parts[13], " ");

    while(q != ((void *)0)){
     StateSpeed[i++] = atoi(q);
     q = strtok(((void *)0), " ");
    }

    Create_Switch(Adr,AAdr,DAdr,SAdr,IOAddress,0);
   }else if(strcmp(parts[0],"CSi") == 0){
    printf("Create Signals - Not Supported");
   }else if(strcmp(parts[0],"CSt") == 0){
    printf("Create Station/Stop");

    char name[30];
    strcpy(name,parts[1]);

    char type = atoi(parts[2]);
    char NrBlocks = atoi(parts[3]);

    int Blocks[10];
    char * q;
    i = 0;
    q = strtok(parts[4], " ");

    while(q != ((void *)0)){
     Blocks[i++] = atoi(q);
     q = strtok(((void *)0), " ");
    }

    Create_Station(ModuleID,name,type,NrBlocks,Blocks);
   }
  }
  }

 fclose(fp);
 if (line)
         free(line);
}
# 88 "baan.c" 2

# 1 "./src/Z21.h" 1
# 10 "./src/Z21.h"
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 30 "/usr/include/arpa/inet.h" 3 4




extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));






extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 11 "./src/Z21.h" 2
# 28 "./src/Z21.h"
void die(char *s);

void Z21_recv(char message[100]);

struct sockaddr_in si_other;
int fd_Z21_server, slen=sizeof(si_other);

void Z21_client();

char Z21_prio_list[05][30] = {{""}};
char Z21_send_list[10][30] = {{""}};

void Z21_recv(char message[100]);

void Z21_send(int Header,char data[30]);

void Z21_GET_LOCO_INFO(int DCC_Adr);

void Z21_SET_LOCO_DRIVE(int DCC_Adr,char steps,_Bool dir,char drive);

void Z21_SET_LOCO_FUNCTION(int DCC_Adr,char function_nr,char switch_type);
# 90 "baan.c" 2

int Adr_Comp2(struct SegC A,struct SegC B){
 if(A.Module == B.Module && A.Adr == B.Adr && A.type == B.type){
  return 1;
 }else{
  return 0;
 }
}

int dir_Comp(struct Seg *A,struct Seg *B){
 if((A->dir == 2 && (B->dir == 1 || B->dir == 0)) || ((A->dir == 1 || A->dir == 0) && B->dir == 2)){
  return 1;
 }else if(A->dir == B->dir){
  return 1;
 }else if(((A->dir == 0 || A->dir == 2) && B->dir == 0b101) || (A->dir == 1 && B->dir == 0b100)){
  return 1;
 }else if(((B->dir == 0 || B->dir == 2) && A->dir == 0b101) || (B->dir == 1 && A->dir == 0b100)){
  return 1;
 }{
  return 0;
 }
# 119 "baan.c"
}

void setup_JSON(int arr[], int arr2[], int size, int size2){
 char buf[100];

 setup_data[0] = 2;
 setup_data_l = 2 + size + size2;

 int i = 2;

 for(i;(i-2)<size;i++){
  setup_data[i] = arr[i-2];
 }

 if(size2 != 0){
  setup_data[1] = size;

  for(i;(i-2-size)<size2;i++){
   setup_data[i] = arr2[i-2-size];
  }
 }
}

void change_block_state(struct Seg * Block,int State){
 if(Block->state != State){
  Block->change = 1;
  Block->state = State;
 }
}

void JSON_new_client(int Client_fd);

struct timer_thread_data{
   int thread_id;
  int t;
};

struct timer_thread_data a[5];

# 1 "./src/status.c" 1

# 1 "./src/Web.h" 1
# 3 "./src/status.c" 2
# 22 "./src/status.c"
struct WS_Message {
  uint16_t type;
  char data[16];
  char data_length;
};

struct WS_Message MessageList[0x1FFF];
char MessageCounter = 0;

void WS_init_Message_List(){
  memset(MessageList,0,64);
  MessageCounter = 0;
}

char WS_init_Message(char type){
  if(MessageCounter >= 0x1FFF){
    MessageCounter = 0;
  }
  while((MessageList[MessageCounter].type & 0x8000) != 0){
    MessageCounter++;
    printf("Busy Message %i, Skip index %02X\n",MessageCounter,MessageList[MessageCounter].type);
    if(MessageCounter >= 0x1FFF){
      MessageCounter = 0;
    }
  }
  MessageList[MessageCounter].type = type + 0x8000;
  return MessageCounter++;
}

void WS_add_Message(uint16_t ID, char length,char data[16]){
  memcpy(MessageList[ID].data,data,length);
  MessageList[ID].data_length = length;
}

void WS_send_open_Messages(int Client_fd){
  for(int i = 0;i<=0x1FFF;i++){
    if(MessageList[i].type & 0x8000){
      send_packet(Client_fd,MessageList[i].data,MessageList[i].data_length,0xFF);
    }
  }
}

void WS_clear_message(uint16_t ID){
  MessageList[ID].type = 0;

  printf("Send clear message (ID: %i)\n",ID);

  send_all((char [3]){0x15,(ID >> 8),ID&0xFF},3,0xFF);
}







void WS_EmergencyStop(){
  send_all((char []){0x10},1,0xFF);
}

void WS_ShortCircuit(){
  send_all((char []){0x11},1,0xFF);
}

void WS_ClearEmergency(){
  send_all((char []){0x12},1,0xFF);
}





void WS_trackUpdate(int Client_fd){
  pthread_mutex_lock(&mutex_lockB);
  char data[4096];

  data[0] = 0x26;

  int data_len;
  _Bool content = 0;

  int q = 1;

  for(int i = 0;i<16;i++){
    if(Units[i]){
      for(int j = 0;j<=Units[i]->B_L;j++){
        struct Seg * B = Units[i]->B[j];
        if(B && B->change){
          content = 1;

          data[(q-1)*4+1] = B->Module;
          data[(q-1)*4+2] = B->id;
          data[(q-1)*4+3] = (B->dir << 7) + (B->blocked << 4) + B->state;
          data[(q-1)*4+4] = B->train;
          q++;

          B->change = 0;
        }
      }
    }
  }

  data_len = (q-1)*4+1;

  if(content == 1){
    if(Client_fd){
      send_packet(Client_fd,data,data_len,0x02);
    }else{
      send_all(data,data_len,0x02);
    }
  }
  pthread_mutex_unlock(&mutex_lockB);
}

void WS_SwitchesUpdate(int Client_fd){
  pthread_mutex_lock(&mutex_lockB);
  char buf[4096];


    buf[0] = 0x27;
    int buf_l = 0;
    _Bool content = 0;

    int q = 1;


    for(int i = 0;i<16;i++){
      if(Units[i]){
        for(int j = 0;j<=Units[i]->S_L;j++){
          struct Swi * S = Units[i]->S[j];
          if(S){
            if(Client_fd == 0 && (S->state & 0x80) != 0x80){
              continue;
            }
            content = 1;
            buf[(q-1)*3+1] = S->Module;
            buf[(q-1)*3+2] = S->id & 0x7F;
            buf[(q-1)*3+3] = S->state & 0x7F;

            q++;
          }
        }
      }
    }

    buf_l = (q-1)*3+1;






    q = 1;

    for(int i = 0;i<16;i++){
      if(Units[i]){
        content = 1;
        for(int j = 0;j<=Units[i]->Mod_nr;j++){
          struct Mod * M = Units[i]->M[j];
          if(M){
            buf[(q-1)*4+1+buf_l] = M->Module;
            buf[(q-1)*4+2+buf_l] = (M->id & 0x7F) + 0x80;
            buf[(q-1)*4+3+buf_l] = M->state;
            buf[(q-1)*4+4+buf_l] = M->length;
            q++;
          }
        }
      }
    }

  buf_l += (q-1)*4+1;

  if(content == 1){
    if(Client_fd){
      printf("WS_SwitchesUpdate Custom Client");
      send_packet(Client_fd,buf,buf_l,0x04);
    }else{
      printf("WS_SwitchesUpdate ALL");
      send_all(buf,buf_l,0x04);
    }
  }

  pthread_mutex_unlock(&mutex_lockB);
}
# 257 "./src/status.c"
void WS_NewTrain(char nr,char M,char B){


  uint16_t msg_ID = WS_init_Message(0);

  char data[6];
  data[0] = 0x13;
  data[1] = ((msg_ID >> 8) & 0x1F) + 0;
  data[2] = (msg_ID & 0xFF);
  data[3] = nr;
  data[4] = M;
  data[5] = B;
  send_all(data,6,0x08);
  WS_add_Message(msg_ID,6,data);
}

void WS_TrainSplit(char nr,char M1,char B1,char M2,char B2){


  uint16_t msg_ID = WS_init_Message(1);

  char data[8];
  data[0] = 0x13;
  data[1] = ((msg_ID >> 8) & 0x1F) + 0x20;
  data[2] = (msg_ID & 0xFF);
  data[3] = nr;
  data[4] = M1;
  data[5] = B1;
  data[6] = M2;
  data[7] = B2;
  send_all(data,8,0x08);
  WS_add_Message(msg_ID,8,data);
}
# 317 "./src/status.c"
void WS_reset_switches(int client_fd){

  char admin = 1;
  if(admin){

    for(int i = 0;i<16;i++){
      for(int j = 0;j<Units[i]->S_L;j++){
        if(Units[i]->S[j]){
          Units[i]->S[j]->state = Units[i]->S[j]->default_state + 0x80;
        }
      }
    }


    WS_SwitchesUpdate(0);
  }
}

void WS_LinkTrain(uint8_t fID, uint8_t tID){
  send_all((char []){0x41,fID,tID},3,0xFF);
}

void WS_TrainData(char data[14]){
  printf("\n\nWeb_Train_Data\n\n");
  char s_data[20];
  s_data[0] = 0x45;

  for(int i = 0;i<7;i++){
    s_data[i+2] = data[i];
  }

  s_data[1] = DCC_train[((s_data[2] << 8) + s_data[3])]->ID;

  send_all(s_data,9,0x01);
}
# 159 "baan.c" 2
# 1 "./src/trains.c" 1




int add_train(int DCC,int speed,char name[],char type){
 struct train *Z = (struct train*)malloc(sizeof(struct train));

 struct adr Route[20] = {{0,0,0,0}};

 Z->DCC_ID = DCC;
 Z->ID = iTrain;
 Z->type = type;
 strcpy(Z->name,name);
 Z->max_speed = speed;
 Z->accelerate_speed = 60;
 Z->break_speed = 50;
 Z->cur_speed = 100;
 Z->control = 0;
 Z->use = 0;
 Z->dir = 0;
 Z->halt = (!(1==1));


 trains[iTrain++] = Z;
 if(DCC < 9999){
  DCC_train[DCC] = Z;
 }
 return (iTrain - 1);
}

int create_train(int DCC,int speed,char name[],char type){
 printf("Create train, %i trains in library\n",iTrain);
 for(int i = 0;i<iTrain;i++){
  printf("Train[%i]\n",i);
  if(trains[i]->DCC_ID == DCC){
   printf("Address already in use");
   return -1;
  }
 }
 printf("Add train\n");

 int value = add_train(DCC,speed,name,type);

 printf("Open file\n");
 FILE * f;
 f = fopen("./trains/trainlist_raw.txt","a");
 printf("write to file\n");
 fprintf(f,"%d\t%s\t%i\t%c\t%i\t000000000000000000000000000\r\n",value,name,DCC,type,speed);
 fclose(f);


 return value;
}

void init_trains(){
 FILE *f;
 f = fopen("./trains/trainlist_raw.txt","r");
 char line[256] = "";
 int line_nr = 0;
 int nr_trains = 0;

 while (fgets(line, sizeof(line), f)) {


  char *D1 = strchr(line, '\t');
  char *D2 = strchr(&line[(D1-line)+1], '\t');
  char *D3 = strchr(&line[(D2-line)+1], '\t');
  char *D4 = strchr(&line[(D3-line)+1], '\t');
  char *D5 = strchr(&line[(D4-line)+1], '\t');
  char *D6 = strchr(&line[(D5-line)+1], '\r');
  if (D1 && D2 && D3 && D4 && D5 && D6){ ;
   int start = 0;
   int tab1 = D1-line;
   int tab2 = D2-line;
   int tab3 = D3-line;
   int tab4 = D4-line;
   int tab5 = D5-line;
   int end = D6-line;

   char L1[21],L2[7],L3[5],L4[5],L5[30];

   memset(L1,0,21);
   memset(L2,0,7);
   memset(L3,0,5);
   memset(L4,0,5);
   memset(L5,0,30);

   for(int i = tab1;i<=end;i++){
    if(i < tab2){
     L1[(i-tab1)] = line[i];
    }else if(i > tab2 && i < tab3){
     L2[(i-tab2-1)] = line[i];
    }else if(i > tab3 && i < tab4){
     L3[(i-tab3-1)] = line[i];
    }else if(i > tab4 && i < tab5){
     L4[(i-tab4-1)] = line[i];
    }else if(i > tab5 && i < end){
     L5[(i-tab5-1)] = line[i];
    }
    if(i == tab2){
     L1[(i-tab1)] = 0;
    }else if(i == tab3){
     L2[(i-tab2-1)] = 0;
    }else if(i == tab4){
     L3[(i-tab3-1)] = 0;
    }else if(i == tab5){
     L4[(i-tab4-1)] = 0;
    }else if(i == end){
     L5[(i-tab5-1)] = 0;
    }
   }


   if(line_nr != 0){
    if(atoi(L2) < 10000){
     add_train(atoi(L2),atoi(L4),L1,L3[0]);
     nr_trains++;
    }
   }
  }else{
   printf("Corrupt trainlist file!!!!!!!\n");
  }
  line_nr++;
 }
 fclose(f);

 printf("|                           %i\ttrains found                               |\n",nr_trains);
 printf("|                                                                          |\n");

 for(int i = 0;i<nr_trains;i++){
  char buf[40] = "|                    ";
  sprintf(buf,"%s(%02i) #%04i  %s",buf,i,trains[i]->DCC_ID,trains[i]->name);
  printf("%s",buf);
  for(int j = strlen(buf);j<69;j++)
   printf(" ");
  printf("|\n");
 }

 printf("|                                                                          |\n");
}

int link_train(char link,int train){


 if(train_link[link] == ((void *)0) && trains[train]->use == 0){
  printf("link is empty %i\n",train_link[link]);
  train_link[link] = trains[train];
  if(train != 0 || train != 1){
   train_link[link]->use = 1;
  }else{
   printf("Duplicates allowed");
  }
  printf("Set to %i\n",train_link[link]);
  return 1;
 }else{
  return 0;
 }
}

void unlink_train(char link){
 train_link[link]->use = 0;
 train_link[link] = ((void *)0);
}

void *train_timer(void *threadArg){
 struct train_timer_th_data *my_data;
 my_data = (struct train_timer_th_data *) threadArg;
 int id = my_data->thread_id;
 struct train * T = my_data->T;
 struct Seg * B = my_data->B;
 int des_s = my_data->speed;

 free(threadArg);



 float d = (float)B->length/100 * 160;

 int cur_s = T->cur_speed;
 int max_s = T->max_speed;

 float speed_step = (float)max_s/128;

 if(des_s/speed_step > 128){
  des_s = max_s;
 }

 if((int)((float)cur_s/speed_step+0.5) == (int)((float)des_s/speed_step+0.5)){
  return 0;
 }

 float total_time = (((float)d)/(cur_s))*3.6;


 printf("Train name: %s\t",T->name);
 int step_dif = (int)((float)des_s/speed_step+0.5) - (int)((float)cur_s/speed_step+0.5);
 printf("Length: %f\tstep: %i->%i, d%i\t",d,(int)((float)cur_s/speed_step+0.5),(int)((float)des_s/speed_step+0.5),step_dif);
 int time_step = (int)(((float)total_time/step_dif)*1000000);
 if(time_step < 0){
  time_step = -1*time_step;
 }
 printf("Time %f\tTime step: %i\n",total_time,time_step);

 printf("Max_speed: %i\tCur_speed: %i\tDes_speed: %i\n",max_s,cur_s,des_s);

 if(step_dif>0){
  for(int i = 0;i<=step_dif;i++){
   T->cur_speed++;
   T->cur_speed++;
   printf("++");
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
  }
 }else{
  for(int i = 0;i<=(-step_dif);i++){
   T->cur_speed--;
   T->cur_speed--;
   printf("--");
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
   usleep(time_step);
   if(timers[id] > 2){
    goto END;
   }
  }
 }
 T->cur_speed = des_s;
 timers[id] = 2;
 T->timer = 0;
 T->timer_id = 0;
 printf("%i done\tCurrent speed %i\n",id,T->cur_speed);

 END:{}
}

void train_speed(struct Seg * B,struct train * T,char speed){
 if(T == ((void *)0)){
  return;
 }
 printf("\t#%i\t%s\n",T->DCC_ID,T->name);

 if(T->timer == 2){
  printf("TIMER ALLREADY STARTED\n");
 }else{

  int des_s = speed;

  struct train_timer_th_data * thread_data = (struct train_timer_th_data*)malloc(sizeof(struct train_timer_th_data));

  int i = 0;
  while(1){
   if(timers[i] == 0){
    timers[i] = 1;
    T->timer_id = i;
    T->timer = 2;

    thread_data->thread_id = i;
    thread_data->T = T;
    thread_data->B = B;
    thread_data->Flag = 1;
    thread_data->speed = des_s;

    pthread_create(&timer_thread[i], ((void *)0), train_timer, (void *) thread_data);
    break;
   }
   i++;
   if(i==5){
    COM_set_train_speed(T,des_s);
   }
  }
 }
}

void train_set_speed(struct train *T,char speed){
 if(!T){ return;printf("Empty T\n");}
 T->cur_speed = speed;
 Z21_GET_LOCO_INFO(T->DCC_ID);
}

void train_set_dir(struct train *T,char dir){
 if(!T){ return;printf("Empty T\n");}
 if(dir == 0){
  printf("Set dir to forward\n");
  T->dir = dir;
 }else{
  printf("Set dir to reverse\n");
  T->dir = dir;
 }
 Z21_GET_LOCO_INFO(T->DCC_ID);
}

void train_set_route(struct train *T,struct Station * S){
 if(pathFinding(T->Cur_Block,S->Blocks[0],T->Route,&T->Sw_len)){
  T->halt = 0;
  T->Destination = S->Blocks[0];
 }
}

void train_stop(struct train * T){
 printf("KILL TRAIN:\t#%i\t%s\n",T->DCC_ID,T->name);
}

void train_signal(struct Seg * B,struct train * T,int type){
 if(T == ((void *)0)){
  return;
 }
 printf("\t#%i\t%s\n",T->DCC_ID,T->name);

 if(T->timer == 1){
  printf("TIMER ALLREADY STARTED\n");
 }else{

  int des_s;
  if(type == 1){
   des_s = 40;
  }else{
   des_s = 0;
  }

  struct train_timer_th_data * thread_data = (struct train_timer_th_data*)malloc(sizeof(struct train_timer_th_data));

  int i = 0;
  while(1){
   if(timers[i] == 0){
    timers[i] = 1;
    T->timer = 1;
    T->timer_id = i;
    thread_data->thread_id = i;
    thread_data->T = T;
    thread_data->B = B;
    thread_data->Flag = 2;
    thread_data->speed = des_s;

    pthread_create(&timer_thread[i], ((void *)0), train_timer, (void *) thread_data);
    break;
   }
   i++;
   if(i==5){
    COM_set_train_speed(T,des_s);
   }
  }
 }
}

void train_block_timer();
# 160 "baan.c" 2
# 1 "./src/train_sim.c" 1

void *TRAIN_SIMA(){
 struct Seg *B = Units[8]->B[5];
 struct Seg *N = Units[8]->B[5];
 struct Seg *A = 0;
 int i = 0;

 B->blocked = 1;
 B->change = 1;




 while(!stop){
  printf("Train Sim Step (id:%i)\n",pthread_self());

  pthread_mutex_lock(&mutex_lockA);

  N = Next2(B,1+i);
  if(i > 0){
   A = Next2(B,i);
  }
  if(!N){
   while(1){
    usleep(100000);
   }
  }
  printf(" %i:%i\n",N->Module,N->id);
  N->change = 1;
  N->blocked = 1;
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayA/2);
  pthread_mutex_lock(&mutex_lockA);
  if(i>0){
   A->change = 1;
   A->blocked = 0;
  }else{
   B->change = 1;
   B->blocked = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayA/2);
  pthread_mutex_lock(&mutex_lockA);
  if(N->type == 'T'){
   i++;
  }else{
   B = N;
   i = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
 }
}

void *TRAIN_SIMB(){
 struct Seg *B = Units[4]->B[23];
 struct Seg *N = Units[4]->B[23];
 struct Seg *A = 0;
 int i = 0;

 B->blocked = 1;
 B->change = 1;

 while(B->train == 0){}

 while(!train_link[B->train]){}

 train_link[B->train]->halt = 1;

 while(train_link[B->train]->halt == 1){}

 while(!stop){

  while(1){
   if(train_link[2] && train_link[2]->halt == 0){
    break;
   }
   usleep(1000);
  }

  pthread_mutex_lock(&mutex_lockA);

  N = Next2(B,1+i);
  if(i > 0){
   A = Next2(B,i);
  }
  if(!N){
   while(1){
    usleep(100000);
   }
  }

  N->change = 1;
  N->blocked = 1;
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayA/2);
  pthread_mutex_lock(&mutex_lockA);
  if(i>0){
   A->change = 1;
   A->blocked = 0;
  }else{
   B->change = 1;
   B->blocked = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
  usleep(delayA/2);
  pthread_mutex_lock(&mutex_lockA);
  if(N->type == 'T'){
   i++;
  }else{
   B = N;
   i = 0;
  }
  pthread_mutex_unlock(&mutex_lockA);
 }
}
# 161 "baan.c" 2
# 1 "./src/Web.c" 1




char websocket_magic_string[] = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

pthread_t client_threads[5];
pthread_mutex_t mutex_lock_web;

char * WS_password = 0;

struct client_thread_args clients_data[5];
struct web_client_t * clients[5];
int fd_client_list[5] = {0};
int connected_clients = 0;

char strcmp2(char arr1[],char arr2[], int length){
  for(int i = 0;i<length;i++){
    if(arr1[i] != arr2[i]){
      return 0;
    }
  }
  return 1;
}

void append_Array(char arr1[],int length1, char arr2[],int length2,char arrout[]){
  int index = 0;
  for(index;index<length1;index++){
    arrout[index] = arr1[index];
  }

  int pos = index;

  for(index;(index-pos)<length2;index++){
    arrout[index] = arr2[index-pos];
  }
}

void copy_Array(char arr1[],char arr2[],int length){
 for(int index = 0;index<length;index++){
  arr1[index] = arr2[index];
 }
}

int websocket_connect(struct web_client_t * C){
  int fd_client = C->fd_client;

  char buf[1024];

  memset(buf, 0, 1024);
  read(fd_client, buf, 1023);



  char Connection[20] = "Connection: Upgrade";
  char Connection2[35] = "Connection: keep-alive, Upgrade";
  char UpgradeType[20] = "Upgrade: websocket";
  char Key[25] = "Sec-WebSocket-Key: ";
  char Protocol[20] = "Protocol: ";

  char *start, *end, *S_prot, *E_prot, target[60], protocol[5];
  memset(target,0,60);
  memset(protocol,0,5);
  int prot;

  if((strstr(buf, Connection) || strstr(buf,Connection2)) &&
        strstr(buf, UpgradeType) && strstr(buf, Key)) {
    printf("\nIt is a HTML5 WebSocket!!\n");

    start = strstr(buf, Key);
    start += strlen(Key);
    end = strstr(start,"\r\n");

    S_prot = strstr(buf, Protocol);
    if(S_prot){
      S_prot += strlen(Protocol);
      E_prot = strstr(S_prot,"\r\n");
    }

    if (end){
        strncat(target,start,end-start);
    }

    printf("Socket-key: '%s'\n",target);
    strcat(target,websocket_magic_string);

    printf("Searching protocol form 0x%x\n",buf);

    printf("S_prot: 0x%x\n",S_prot);
    if((S_prot-buf) != 0){
      printf("Drotocol: %s\n",S_prot);
      if (E_prot){
          strncat(protocol,S_prot,E_prot-S_prot);
      }
      prot = (int)strtol(protocol,((void *)0),10) & ~(0x10);
    }else{
      printf("Default Protocol\n");
      prot = 0xEF;
      protocol[0] = '2';
      protocol[1] = '3';
      protocol[2] = '9';
      protocol[3] = 0;
    }
    printf("Protocol: %i\n",prot);


    unsigned char hash[20];
    SHA1(target, sizeof(target), hash);
    char b64[40] = "";
    base64_encode(hash,sizeof(hash),b64,40);


    char response[500] = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: ";
    strcat(response,b64);
    if(prot != 0){
      strcat(response,"\r\nSec-WebSocket-Protocol: ");
      strcat(response,protocol);
    }
    strcat(response,"\r\n\r\n");
    printf("Sending Response\n\n%s\n\n\n",response);
    write(fd_client, response, strlen(response));

    printf("Done\n");
    C->client_type = prot;


    return 1;
  }
  else{
    printf("It's not a HTML5-websocket\n");
    printf(strstr(buf,Connection));
    printf("\n");
    printf(strstr(buf,Connection2));
    printf("\n");
    printf(strstr(buf,UpgradeType));
    printf("\n");
    printf(strstr(buf,Key));
    printf("\n");

    return 0;
  }
}

int recv_packet(int fd_client, char outbuf[], int * L){
  pthread_mutex_lock(&mutex_lock_web);
  char buf[1024];
  memset(buf,0,1024);
  memset(outbuf,0,sizeof(outbuf));
  usleep(10000);
  recv(fd_client,buf,1024,0);

  int byte = 0;
# 164 "./src/Web.c"
  int opcode = buf[byte++] & 0b00001111;


  unsigned int mes_length = buf[byte++] & 0b01111111;
  if(mes_length == 126){
    mes_length = (buf[byte++] << 8) + buf[byte++];

  }else if(mes_length == 127){

  }

  int masking_index = byte;
  unsigned int masking_key = (buf[byte++] << 24) + (buf[byte++] << 16) + (buf[byte++] << 8) + (buf[byte++]);


  char output[mes_length+2];
  memset(output,0,mes_length+2);

  for(int i = 0;i<mes_length;0){
    unsigned int test;
    unsigned int text;
    test = (buf[byte++] << 24) + (buf[byte++] << 16) + (buf[byte++] << 8) + (buf[byte++]);
    text = test ^ masking_key;

      output[i++] = (text & 0xFF000000) >> 24;
      if(i<mes_length){

        output[i++] = (text & 0xFF0000) >> 16;
      }
      if(i<mes_length){

        output[i++] = (text & 0xFF00) >> 8;
      }
      if(i<mes_length){

        output[i++] = text & 0xFF;
      }

  }
  *L = mes_length;

  copy_Array(outbuf,output,mes_length);
  printf("WS recieved data: ");
  for(int q = 0;q<mes_length;q++){
    printf("%02x ",output[q]);
  }
  printf("\n",output);

  pthread_mutex_unlock(&mutex_lock_web);
  if(opcode == 8){
    printf("Connection closed by client\n\n");
    return -8;
  }
  return 1;
}

int send_packet(int fd_client, char data[],int length,int flag){


  char m_length = 0;
  char outbuf[4096];
  char buf[10];
  memset(outbuf,0,4096);
  buf[0] = 0b10000000 + 0b00000010;
  if(length < 126){
    buf[1] = length;
    m_length = 2;
  }else if(length < 65535){
    buf[1] = 126;
    buf[2] = 0xFF;
    buf[3] = 0xFF;

    buf[2] = (length & 0xFF00) >> 8;
    buf[3] = length & 0xFF;
    m_length = 4;
  }else{
    printf("Too large message\n\n");
  }

  append_Array(buf,m_length,data,length,outbuf);



  write(fd_client,outbuf,m_length+length);
}

void send_all(char data[],int length,int flag){


  pthread_mutex_lock(&mutex_lock_web);
  int m_length = 0;
  char outbuf[4096];
  char buf[10];
  memset(outbuf,0,4096);
  buf[0] = 0b10000000 + 0b00000010;
  if(length < 126){
    buf[1] = length;
    m_length = 2;
  }else if(length < 65535){
    buf[1] = 126;
    buf[2] = 0xFF;
    buf[3] = 0xFF;

    buf[2] = (length & 0xFF00) >> 8;
    buf[3] = length & 0xFF;
    m_length = 4;
  }

  append_Array(buf,m_length,data,length,outbuf);

  for(int i = 0;i<5;i++){
    if(fd_client_list[i] != 0 && (clients[i]->client_type & flag) != 0){
      printf("WS send (%i)\t",i);
      for(int zi = 0;zi<(length);zi++){printf("%02X ",data[zi]);};
      printf("\n");
      if(write(fd_client_list[i],outbuf,m_length+length) == -1){
        if((*__errno_location ()) == 32){
          printf("Broken Pipe!!!!!\n\n");
          close(fd_client_list[i]);
          connected_clients--;
          fd_client_list[i] = 0;
          clients[i]->state = 2;
        }
      }
    }
  }
  pthread_mutex_unlock(&mutex_lock_web);
}

int recv_packet_procces(char data[1024],struct client_thread_args * client_data){




  printf("recv_packet_procces\n");

  if(data[0] & 0x80){
    printf("Admin settings: %02X\n",data[0]);
    if(data[0] == 0xFF){
      printf("\nAdmin Login\n\n");
      if(strcmp2(&data[1],WS_password,32) == 1){
        printf("\n\n\n\n\nSUCCESSFULL LOGIN\n\n");

        clients[client_data->thread_id]->client_type |= 0x10;

        send_packet(client_data->fd_client,(char [2]){0x16,clients[client_data->thread_id]->client_type},2,255);
      }else{
        printf("\n\n\n\n\nFAILED LOGIN!!\n\n");
      }
    }
    if((clients[client_data->thread_id]->client_type & 0x10) != 0x10){

      printf("Not an Admin client");
      return;
    }
    if(data[0] == 0x80){

    }
    else if(data[0] == 0x81){

    }
    else if(data[0] == 0x82){

    }
    else if(data[0] == 0x83){

    }
    else if(data[0] == 0x84){

    }
    else if(data[0] == 0x88){

    }

    else if(data[0] == 0xA0){

    }

    else if(data[0] == 0x90){

    }
    else if(data[0] == 0x91){

    }
  }
  else if(data[0] & 0x40){
    if(data[0] == 0x40){

    }
    else if(data[0] == 0x41){
      uint8_t fID = data[1];
      uint8_t tID = data[2];

      printf("Linking train %i with dcc address #%i\n",fID,trains[tID]->DCC_ID);
      if(link_train(fID,tID)){
        WS_clear_message(((data[3] & 0x1F) >> 8)+data[4]);
        WS_LinkTrain(fID,tID);


        Z21_GET_LOCO_INFO(trains[tID]->DCC_ID);
      }
    }
    else if(data[0] == 0x42){
      char tID = data[1];
      char speed = data[2];
      trains[tID]->cur_speed = speed & 0x7F;
      trains[tID]->dir = speed >> 7;

      Z21_GET_LOCO_INFO(trains[tID]->DCC_ID);
    }
    else if(data[0] == 0x43){

    }
    else if(data[0] == 0x44){

    }
    else if(data[0] == 0x46){

    }
    else if(data[0] == 0x47){

    }
  }
  else if(data[0] & 0x20){
    if(data[0] == 0x20){
      if(Switch2[data[1]][data[2]]){
        printf("throw switch %i:%i\t",data[1],data[2]);
        printf("%i->%i",Switch2[data[1]][data[2]]->state, !Switch2[data[1]][data[2]]->state);
        throw_switch(Switch2[data[1]][data[2]]);
      }
    }
    else if(data[0] == 0x21){

    }
    else if(data[0] == 0x22){

    }
    else if(data[0] == 0x23){

    }
    else if(data[0] == 0x24){

    }
    else if(data[0] == 0x25){

    }
  }
  else if(data[0] & 0x10){
    if(data[0] == 0x10){
      WS_EmergencyStop();
    }
    else if(data[0] == 0x12){
      WS_ClearEmergency();
    }
    else if(data[0] == 0x15){

    }
    else if(data[0] == 0x16){
      clients[client_data->thread_id]->client_type;
      data[1];
      if(data[1] & 0x10){
        return 0;
        printf("Changing admin flag: NOT ALLOWED\n");
      }else if(data[1] != 0){
        clients[client_data->thread_id]->client_type = data[1];
        printf("Changing flags\n");
      }
      printf("Sending (new) flags\n");
      send_packet(client_data->fd_client,(char [2]){0x16,clients[client_data->thread_id]->client_type},2,255);
    }
  }
# 550 "./src/Web.c"
                                                                      ;
# 626 "./src/Web.c"
                                                         ;
# 709 "./src/Web.c"
                                                                           ;
# 777 "./src/Web.c"
}

void * websocket_client(void * thread_data){
  struct client_thread_args *thread_args;
 thread_args = (struct client_thread_args *) thread_data;
 int i = thread_args->thread_id;
 int fd_client = thread_args->fd_client;

  printf("New websocket_client");
  if(websocket_connect(clients[i])){
      char buf[1024];
      memset(buf,0,1024);

      fd_client_list[i] = fd_client;

      connected_clients++;

      while(initialise == 1){

      }
      printf("Send track style\n");
      char data[2];
      int length = 0;
      data[0] = 0;
      data[1] = digital_track;
      send_packet(fd_client,data,2,1);
      printf("Send Setupdata\n");

      send_packet(fd_client,setup_data,setup_data_l,8);
      printf("Recv 1\n");
      recv_packet(fd_client,buf,&length);
      memset(buf,0,1024);

      printf("Send new client JSON\n");

      JSON_new_client(fd_client);

      printf("Send open messages\n");
      WS_send_open_Messages(fd_client);


      printf("Send broadcast flags\n");

      send_packet(fd_client,(char [2]){0x16,clients[i]->client_type},2,0xFF);

      printf("Done\n");

      while(1){

        if(recv(fd_client,buf,1024,MSG_PEEK) > 0){
          printf("Data received\n");
          usleep(10000);
          length = 0;
        memset(buf,0,1024);
          int status = recv_packet(fd_client,buf,&length);



          printf("Status: %i\n",status);
          if(status == 1){
            recv_packet_procces(buf,thread_args);
          }
          printf("\nData: %s\n",buf);
          if(status == -8){
            close(fd_client);
            connected_clients--;
            fd_client_list[i] = 0;
            clients[i]->state = 2;
            return 0;
          }

        }

        if(clients[i]->state == 2){
          return 0;
        }

        if(stop){
          close(fd_client);
        }
      }
  }else{
    printf("Wrong HTTP request!!!!\n");
    close(fd_client);
    clients[i]->state = 2;
    return 0;
  }
}

void *clear_clients(){
 while(!stop){
  for(int i = 0;i<5;i++){
   if(clients[i]->state == 2){
    pthread_join(client_threads[i], ((void *)0));
    clients[i]->state = 0;
    printf("Reset client %i\n",i);
   }
  }
    usleep(100000);
 }
}

void * web_server(){
  struct sockaddr_in server_addr, client_addr;
  socklen_t sin_len = sizeof(client_addr);
  int fd_server, fd_client;
  int fdimg;
  int on = 1;


  long WS_pass_length;
  FILE * f = fopen ("./password.txt", "rb");

  if (f)
  {
    fseek (f, 0, 2);
    WS_pass_length = ftell (f);
    fseek (f, 0, 0);
    WS_password = malloc (WS_pass_length);
    if (WS_password && WS_pass_length == 32)
    {
      fread (WS_password, 1, WS_pass_length, f);
    }
    else{
      printf("PASSWORD: wrong length or unable to allocate memory\n\n");
    }
    fclose (f);
  }


  fd_server = socket(2, SOCK_STREAM, 0);
  if(fd_server < 0){
    printf("ERROR, SOCKET\n");
    exit(1);
  }


  setsockopt(fd_server, 1, 2, &on, sizeof(int));

  server_addr.sin_family = 2;
  server_addr.sin_addr.s_addr = ((in_addr_t) 0x00000000);
  server_addr.sin_port = htons(9000);

  if(bind(fd_server, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1){
    printf("ERROR, BIND\n");
    close(fd_server);
    exit(1);
  }

  if(listen(fd_server, 5) == -1){
    printf("ERROR, LISTEN\n");
    close(fd_server);
    exit(1);
  }

  int q = 0;

  while(startup == 0){
    usleep(10000);
  }


  for(int i = 0;i<5;i++){
    struct web_client_t * Z = (struct web_client_t *)malloc(sizeof(struct web_client_t));
    Z->state = 0;
    Z->fd_client = 0;
    Z->client_type = 0;
    clients[i] = Z;
  }


  pthread_t clear;
  pthread_create(&clear, ((void *)0), clear_clients, ((void *)0));

  while(1){
    fd_client = accept(fd_server, (struct sockaddr *) &client_addr, &sin_len);

    if(fd_client == -1){
      if(q == 0){
        printf("ERROR, Client Connect\n");
      }
      q = 1;
      continue;
    }
    q = 0;

    int i = 0;
   while(1){
    if(clients[i]->state == 0){
     clients_data[i].thread_id = i;
     clients_data[i].fd_client = fd_client;

        clients[i]->fd_client = fd_client;
        clients[i]->state = 1;

     printf("Create client thread %i\n",i);
     pthread_create(&client_threads[i], ((void *)0), websocket_client, (void *) &clients_data[i]);
     break;
    }
    i++;
    if(i==5){
     i = 0;
     printf("Too many clients!!!!!\n\n");
     usleep(100000);
    }
   }

    if(stop){
      close(fd_server);
      break;
    }
  }
}
# 162 "baan.c" 2
# 1 "./src/COM.c" 1



pthread_mutex_t mutex_UART;




int uart0_filestream = -1;

char COM_ACK = 0;

void * UART(){


 uart0_filestream = open("/dev/ttyAMA0", 02 | 0400);
 if (uart0_filestream == -1)
 {

  printf("COM - Error - Unable to open UART.  Ensure it is not in use by another application\n");
 }


 struct termios options;
 tcgetattr(uart0_filestream, &options);
 options.c_cflag = 0000017 | 0000060 | 0004000 | 0000200;
 options.c_iflag = 0000004;
 options.c_oflag = 0;
 options.c_lflag = 0;
 tcflush(uart0_filestream, 0);
 tcsetattr(uart0_filestream, 0, &options);

 char data[50];
 memset(data,0,50);

 while(!stop){
  if(COM_Recv(data)){
   COM_Parse(data);
   memset(data,0,50);
  }
  usleep(1000);
 }


 close(uart0_filestream);
}

char * COM_Send(struct COM_t DATA){
 if (uart0_filestream == -1){
  return "No UART";
 }

 tcflush(uart0_filestream, 0);

 digitalWrite(0,1);
 int count = write(uart0_filestream, &DATA.data[0], DATA.length);
 if (count < 0)
 {
  printf("UART TX error\n");
 }else{

 }
 tcdrain(uart0_filestream);
 digitalWrite(0,0);
}

int COM_Recv(char * OUT_Data){

 if(uart0_filestream == -1){
  return 0;
 }
 int index = 0;


 unsigned char data_buffer[256] = {0};
 memset(data_buffer,0,256);
 while(1){

     unsigned char rx_buffer[255];


  int rx_length = read(uart0_filestream, (void*)rx_buffer, 255);
  if (rx_length < 0)
  {

  }
  else if (rx_length == 0)
  {

  }
  else if (rx_length == 8)
  {
   rx_buffer[rx_length] = '\0';

   for(int i = 0;i<8;i++){
    data_buffer[index++] = rx_buffer[i];
   }
  }
  else
  {

   rx_buffer[rx_length] = '\0';

   for(int i = 0;i<rx_length;i++){
    data_buffer[index++] = rx_buffer[i];
   }
   break;
  }
  return index;
  }

 for(int i = 0;i<index;i++){
  OUT_Data[i] = data_buffer[i];
 }
}

char COM_Packet_Length(char * Data){
 uint8_t Opcode = Data[0];
 if(Opcode == RN_OPC_EMERGENCY_SET ||
   Opcode == RN_OPC_EMERGENCY_REL ||
   Opcode == RN_OPC_POWER_ON ||
   Opcode == RN_OPC_POWER_OFF ){
  return 2;
 }else if(Opcode == RN_OPC_ACK ||
   Opcode == RN_OPC_REPORT_ID ||
   Opcode == RN_OPC_REQUEST_OUT ||
   Opcode == RN_OPC_REQUEST_IN ||
   Opcode == RN_OPC_REQUEST_EEPROM ){
  return 3;
 }else if(Opcode == RN_OPC_DEVID ){
  return 4;
 }else if(Opcode == RN_OPC_IN_OUT_REGS ||
   Opcode == RN_OPC_T_S_OUT ||
   Opcode == RN_OPC_P_S_OUT ||
   Opcode == RN_OPC_TBS_OUT ||
   Opcode == RN_OPC_S_IN
   ){
  return 5;
 }else{
  return Data[1];
 }
}

void COM_Parse(char * Data){
 char length = COM_Packet_Length(Data);


 uint8_t Check = 0xFF;
 for(uint8_t i = 0;i<(length-1);i++){
  Check ^= Data[i];
 }

 if(Checksum != Data[length]){
  printf("COM - Checksum doesn't match\n");
  return;
 }


 switch (Data[0]){
  case 0x00:

   for(uint8_t i = 0;i<MAX_Devices;i++){
    if(DeviceList[i] != 0){
     DeviceList[i] = Data[1];
    }
   }
   break;
  case 0x01:
  case 0x02:
  case 0x03:
  case 0x04:
   break;
  case 0x05:
   COM_ACK = 1;
   break;

  case 0x16:
  case 0x17:
   COM_ACK = 1;
   break;


  case 0x05:
  case 0x06:
  case 0x07:
   break;

  case 0x55:
   COM_ACK = 1;
   break;
 }
}

char * COM_SaR(char * buf[60]){

}

void COM_change_A_signal(int M){
 COM_change_Output(M);
}

void COM_DevReset(){
 struct COM_t Tx;
 Tx.data[0] = 0x05;
 Tx.length = 2;
 Tx.data[1] = 0xFF ^ 0x05;
 COM_Send(Tx);
}

void COM_set_Output(int M){
 uint8_t * OutRegs = (uint8_t *)malloc(((Units[M]->Out_length-1)/8)+1);
 uint8_t * BlinkMask = (uint8_t *)malloc(((Units[M]->Out_length-1)/8)+1);
 uint8_t * PulseMask = (uint8_t *)malloc(((Units[M]->Out_length-1)/8)+1);
 char Out = 0,Blink = 0,Pulse = 0;
 uint8_t byte,offset;

 for(int i = 0;i<Units[M]->S_L;i++){
  for(int j = 0;j<Units[M]->Signals[i]->length;j++){
   byte = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state&0x3F] / 8;
   offset = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state&0x3F] % 8;
   if(Units[M]->Signals[i]->states[Units[M]->Signals[i]->state&0x3F] == (1 << j)){
    OutRegs[byte] |= (1 << offset);
    Out++;
   }
   if(Units[M]->Signals[i]->flash[Units[M]->Signals[i]->state&0x3F] == (1 << j)){
    BlinkMask[byte] |= (1 << offset);
    Blink++;
   }
   Units[M]->Signals[i]->state &= 0x3F;
  }
 }

 for(int i = 0;i<Units[M]->Swi_nr;i++){

  if(Units[M]->S[i]->len & 0xC0 == 0){
   Units[M]->S[i]->state &= 0x3F;
   byte = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] / 8;
   offset = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] % 8;
   PulseMask[byte] |= (1 << offset);
   Pulse++;
  }else if(Units[M]->S[i]->len & 0xC0 == 0x40){
   Units[M]->S[i]->state &= 0x3F;
   byte = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] / 8;
   offset = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] % 8;
   OutRegs[byte] |= (1 << offset);
   Out++;
  }
 }

 if(Out > 0){
  printf("Set All Out Addresses:\n");
  struct COM_t TxPacket;
  TxPacket.data[0] = 0x14;
  TxPacket.data[1] = (Units[M]->Out_length/8)+4;
  TxPacket.length = TxPacket.data[1];
  TxPacket.data[2] = M;
  for(int i = 0;i<(Units[M]->Out_length/8)+1;i++){
   TxPacket.data[3+i] = OutRegs[i];
  }
  for(int i = 0;i<(Units[M]->Out_length/8)+4;i++){
   printf("%02X ",TxPacket.data[i]);
  }
  printf("\n");
  memcpy(Units[M]->OutRegs,OutRegs,((Units[M]->Out_length-1)/8)+1);
 }
 if(Blink > 0){
  printf("Set Blink Mask:\n");
  struct COM_t TxPacket;
  TxPacket.data[0] = 0x15;
  TxPacket.data[1] = (Units[M]->Out_length/8)+4;
  TxPacket.length = TxPacket.data[1];
  TxPacket.data[2] = M;
  for(int i = 0;i<(Units[M]->Out_length/8)+1;i++){
   TxPacket.data[3+i] = BlinkMask[i];
  }
  for(int i = 0;i<(Units[M]->Out_length/8)+4;i++){
   printf("%02X ",TxPacket.data[i]);
  }
  printf("\n");
  memcpy(Units[M]->BlinkMask,BlinkMask,((Units[M]->Out_length-1)/8)+1);
 }
 if(Pulse > 0){
  printf("Set Pulse Mask: \n");

 }
}

void COM_change_Output(int M){
 uint8_t * OutRegs = (uint8_t *)malloc(((Units[M]->Out_length-1)/8)+1);
 uint8_t * BlinkMask = (uint8_t *)malloc(((Units[M]->Out_length-1)/8)+1);
 uint8_t * PulseMask = (uint8_t *)malloc(((Units[M]->Out_length-1)/8)+1);

 memcpy(OutRegs ,Units[M]->OutRegs ,((Units[M]->Out_length-1)/8)+1);
 memcpy(BlinkMask,Units[M]->BlinkMask,((Units[M]->Out_length-1)/8)+1);

 char Out = 0,Blink = 0,Pulse = 0, Toggle = 0;

 uint8_t * PulseAdr = (uint8_t *)malloc(1);
 uint8_t * BlinkAdr = (uint8_t *)malloc(1);
 uint8_t * ToggleAdr = (uint8_t *)malloc(1);

 uint8_t byte,offset;

 for(int i = 0;i<Units[M]->S_L;i++){
  for(int j = 0;j<Units[M]->Signals[i]->length;j++){
   if(Units[M]->Signals[i]->state & 0x80){
    Units[M]->Signals[i]->state &= 0x3F;

    byte = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state] / 8;
    offset = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state] % 8;

    if(Units[M]->Signals[i]->states[Units[M]->Signals[i]->state] == (1 << j)){

     if(!(OutRegs[byte] & (1<<offset))){

      ToggleAdr[Toggle] = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state];
      Toggle++;
      ToggleAdr = realloc(ToggleAdr,Toggle+1);
     }

     OutRegs[byte] |= (1 << offset);
    }else{

     if((OutRegs[byte] & (1<<offset))){

      ToggleAdr[Toggle] = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state];
      Toggle++;
      ToggleAdr = realloc(ToggleAdr,Toggle+1);
     }

     OutRegs[byte] |= (1 << offset);
    }
    if(Units[M]->Signals[i]->flash[Units[M]->Signals[i]->state] == (1 << j)){

     if(!(OutRegs[byte] & (1<<offset))){

      BlinkAdr[Blink] = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state];
      Blink++;
      BlinkAdr = realloc(BlinkAdr,Blink+1);
     }

     OutRegs[byte] |= (1 << offset);
    }else{

     if((OutRegs[byte] & (1<<offset))){

      BlinkAdr[Blink] = Units[M]->Signals[i]->adr[Units[M]->Signals[i]->state];
      Blink++;
      BlinkAdr = realloc(BlinkAdr,Blink+1);
     }

     OutRegs[byte] |= (1 << offset);
    }

   }
  }
 }

 for(int i = 0;i<Units[M]->Swi_nr;i++){

  if(Units[M]->S[i]->len & 0xC0 == 0){
   if(Units[M]->S[i]->state & 0x80){
    Units[M]->S[i]->state &= 0x3F;
    byte = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] / 8;
    offset = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] % 8;
    PulseMask[byte] |= (1 << offset);
    Pulse++;
   }
  }else if(Units[M]->S[i]->len & 0xC0 == 0x40){
   if(Units[M]->S[i]->state & 0x80){
    Units[M]->S[i]->state &= 0x3F;
    byte = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] / 8;
    offset = Units[M]->S[i]->Out[Units[M]->S[i]->state & 0x3F] % 8;
    OutRegs[byte] |= (1 << offset);
    Out++;
   }
  }
 }

 if(Out > 0){
  printf("Set All Out Addresses:\n");
  struct COM_t TxPacket;
  TxPacket.data[0] = 0x14;
  TxPacket.data[1] = (Units[M]->Out_length/8)+4;
  for(int i = 0;i<(Units[M]->Out_length/8)+1;i++){
   TxPacket.data[2+i] = OutRegs[i];
  }
  for(int i = 0;i<(Units[M]->Out_length/8)+4;i++){
   printf("%02X ",TxPacket.data[i]);
  }
  printf("\n");
  memcpy(Units[M]->OutRegs,OutRegs,((Units[M]->Out_length-1)/8)+1);
 }
 if(Blink > 0){
  printf("Set Blink Mask:\n");
  struct COM_t TxPacket;
  TxPacket.data[0] = 0x15;
  TxPacket.data[1] = (Units[M]->Out_length/8)+4;
  for(int i = 0;i<(Units[M]->Out_length/8)+1;i++){
   TxPacket.data[2+i] = BlinkMask[i];
  }
  for(int i = 0;i<(Units[M]->Out_length/8)+4;i++){
   printf("%02X ",TxPacket.data[i]);
  }
  printf("\n");
  memcpy(Units[M]->BlinkMask,BlinkMask,((Units[M]->Out_length-1)/8)+1);
 }
 if(Pulse > 0){
  printf("Set Pulse Mask: \n");

 }
}

void COM_change_signal(struct signal * Si){
 if (uart0_filestream != -1){
  COM_change_A_signal(Si->MAdr);
# 488 "./src/COM.c"
 }
}

void COM_change_switch(int M){
 printf("COM_change_swit");
 if (uart0_filestream != -1){
  printf("ch\n");
  uint8_t * PulseAdr = (uint8_t *)malloc(1);
  uint8_t * ToggleAdr = (uint8_t *)malloc(1);
  char Pulse = 0, Toggle = 0;
  uint8_t byte,offset;

  for(int i = 0;i<Units[M]->Swi_nr;i++){

   printf("Switch: %i\t",Units[M]->S[i]->id);
   if((Units[M]->S[i]->len & 0xC0) == 0){
    printf("P%x\t",Units[M]->S[i]->state);
    if((Units[M]->S[i]->state & 0x80) > 0){
     Units[M]->S[i]->state &= 0x3F;
     PulseAdr[Pulse] = Units[M]->S[i]->Out[Units[M]->S[i]->state];
     Pulse++;
     PulseAdr = realloc(PulseAdr,Pulse+1);
    }
   }else{
    printf("Weird Length bit\n") ;
   }
   printf("\n");
  }

  printf("%i addresses\n",Pulse);

  struct COM_t TxPacket;
  if(Pulse == 1){
   TxPacket.data[0] = 0x11;
  }else if(Pulse > 1){
   TxPacket.data[0] = 0x14;
  }else{
   return;
  }
  TxPacket.data[1] = Pulse+3;
  for(int i = 0;i<Pulse;i++){
   TxPacket.data[i+2] = PulseAdr[i];
  }

  printf("COM Sending: ");
  for(int i = 0;i<(TxPacket.data[1]-1);i++){
   printf("%02X ",TxPacket.data[i]);
  }
  printf("\n\n");

  int count = write(uart0_filestream, TxPacket.data, TxPacket.data[1]-1);

 }
}

void COM_set_train_speed(struct train * T,char speed){

}
# 163 "baan.c" 2

# 1 "./src/Z21.c" 1
# 13 "./src/Z21.c"
void die(char *s)
{
    perror(s);
    exit(1);
}

void Z21_recv(char message[100]);

void Z21_client(){
    int i;
    char buf[512];
    char message[512];

    if ( (fd_Z21_server=socket(2, SOCK_DGRAM, IPPROTO_UDP)) == -1)
    {
        die("socket");
    }

    memset((char *) &si_other, 0, sizeof(si_other));
    si_other.sin_family = 2;
    si_other.sin_port = htons(4129);

    if (inet_aton("127.0.0.1" , &si_other.sin_addr) == 0)
    {
        fprintf(stderr, "inet_aton() failed\n");
        exit(1);
    }

    while(1)
    {
        printf("Enter message : ");
        gets(message);


        if (sendto(fd_Z21_server, message, strlen(message) , 0 , (struct sockaddr *) &si_other, slen)==-1)
        {
            die("sendto()");
        }



        memset(buf,'\0', 512);

        if (recvfrom(fd_Z21_server, buf, 512, 0, (struct sockaddr *) &si_other, &slen) == -1)
        {
            die("recvfrom()");
        }

        Z21_recv(buf);
    }

    close(fd_Z21_server);
    return;
}

void Z21_recv(char message[100]){
 int dataLen = message[0] + message[1] << 8;
 int Header = message[2] + message[3] << 8;

 printf("A message is recieved :)\n\n");

 printf("DataLen:\t%i\n",dataLen);
 printf("Header:\t%i\n\n",Header);

  for(int i = 0;i<96;){
    printf("%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\n",message[i++],message[i++],message[i++],message[i++],message[i++],message[i++],message[i++],message[i++]);
  }
  printf("%i\t%i\t%i\t%i\n",message[96],message[97],message[98],message[99]);






 if(Header == 0x10 && dataLen >= 8){

  int Serial_number = message[4] + message[5] << 8 + message[6] << 16 + message[7] << 24;
  printf("The Serial number of the Z21-base station is:\n%x\n",Serial_number);
 }
 else if(Header == 0x1A && dataLen >= 12){

    int HW_number = message[4] + message[5] << 8 + message[6] << 16 + message[7] << 24;
    printf("The Hardware number of the Z21-base station is:\n%x\n",HW_number);

    int SW_number = message[8] + message[9] << 8 + message[10] << 16 + message[11] << 24;
  printf("The Software number of the Z21-base station is:\n%x\n",SW_number);
 }
 else if(Header == 0x40 && dataLen >= 5){
    int X_header = message[4];
  if(X_header == 0x43 && dataLen >= 8){

      int FAdr = message[5] + message[6] << 8;
      printf("TURNOUT INFO\n");
      printf("Function Address:\t%x\n",FAdr);
      printf("Turnout position:\t%x\n\n",message[7] & 3);
  }
    else if(X_header == 0x61){
      if(message[5] == 0x00){

        printf("BC TRACK POWER OFF\n");
    }
      else if(message[5] == 0x01){

        printf("BC TRACK POWER ON\n");
    }
      else if(message[5] == 0x02){

        printf("BC PROGRAMMING MODE\n");
    }
      else if(message[5] == 0x08){

        printf("BC TRACK SHORT CIRCUIT\n");
    }
      else if(message[5] == 0x12){

        printf("CV Programming Failed (CV NACK SC)\n");
    }
      else if(message[5] == 0x13){

        printf("CV No ACKnolegment\n");
      }
      else if(message[5] == 0x82){

        printf("UNKOWN COMMAND\n");
    }
      else if(message[5] == 0x22){

        printf("LAN STATUS CHANGED\n");
        printf("Centrale status: 0x%x\n",message[6]);
# 150 "./src/Z21.c"
    }
      else if(message[5] == 0x21){

        printf("X-Bus Version\n");
        printf("\t%x.%x\n",message[6] >> 4,message[6] & 0xF);
    }
      else if(message[5] == 0x14){

        printf("CV Read\n");
        printf("CV Adr:\t%i\n",(message[6] << 8 + message[7]));
        printf("Value:\t%i\n",message[8]);
      }
  }
    else if(X_header == 0x81 && dataLen >= 7){

      printf("EMERGENCY STOP // BC_STOPPED\n");
  }
    else if(X_header == 0xEF && dataLen >= 7){

      printf("LOCO INFO\n");
      char data[15];
      memset(data,0,14);
      for(int i = 5;i < (dataLen - 1);i++){
        printf("DB%02i:\t%x\n",message[i]);
        data[i-5] = message[i];
      }

      printf("\nLoc Address:     \t%04i",((data[0] & 0x3F) << 8) + data[1]);
      printf("\nX-Bus Hand block:\t%i",data[2] & 0x8);
      printf("\nSpeed step:      \t%03i",data[2] & 0x7);
      printf("\nDirection:       \t%i",data[3] & 0x80);
      printf("\nMM speed:        \t%03i",data[3] & 0x7F);
      printf("\n'Doppeltraktion':\t%i",data[4] & 0x40);
      printf("\n'Smartsearch':   \t%i",data[4] & 0x20);
      printf("\n\nF00:\t%i\tLight",data[4] & 0x10);
      printf("\nF01:\t%i",data[4] & 0x1);
      printf("\nF02:\t%i",data[4] & 0x2);
      printf("\nF03:\t%i",data[4] & 0x4);
      printf("\nF04:\t%i",data[4] & 0x8);
      printf("\nF05:\t%i",data[5] & 0x1);
      printf("\nF06:\t%i",data[5] & 0x2);
      printf("\nF07:\t%i",data[5] & 0x4);
      printf("\nF08:\t%i",data[5] & 0x8);
      printf("\nF09:\t%i",data[5] & 0x10);
      printf("\nF10:\t%i",data[5] & 0x20);
      printf("\nF11:\t%i",data[5] & 0x40);
      printf("\nF12:\t%i",data[5] & 0x80);
      printf("\nF13:\t%i",data[6] & 0x1);
      printf("\nF14:\t%i",data[6] & 0x2);
      printf("\nF15:\t%i",data[6] & 0x4);
      printf("\nF16:\t%i",data[6] & 0x8);
      printf("\nF17:\t%i",data[6] & 0x10);
      printf("\nF18:\t%i",data[6] & 0x20);
      printf("\nF19:\t%i",data[6] & 0x40);
      printf("\nF20:\t%i",data[6] & 0x80);
      printf("\nF21:\t%i",data[7] & 0x1);
      printf("\nF22:\t%i",data[7] & 0x2);
      printf("\nF23:\t%i",data[7] & 0x4);
      printf("\nF24:\t%i",data[7] & 0x8);
      printf("\nF25:\t%i",data[7] & 0x10);
      printf("\nF26:\t%i",data[7] & 0x20);
      printf("\nF27:\t%i",data[7] & 0x40);
      printf("\nF28:\t%i",data[7] & 0x80);
      printf("\n\nExtra Data\n08:\t");
      for(int j = 8;j<14;j){
        printf("%c%c%c%c%c%c%c%c",(data[j++] & 0x80 ? '1' : '0'), (data[j++] & 0x40 ? '1' : '0'), (data[j++] & 0x20 ? '1' : '0'), (data[j++] & 0x10 ? '1' : '0'), (data[j++] & 0x08 ? '1' : '0'), (data[j++] & 0x04 ? '1' : '0'), (data[j++] & 0x02 ? '1' : '0'), (data[j++] & 0x01 ? '1' : '0'));
        printf("\n%02i\t",j);
      }
      WS_TrainData(data);

      printf("\n");
  }
    else if(X_header == 0xF3 && message[5] == 0x0A){

      printf("FIRMWARE VERSION\n");
      printf("v%x.%x\n",message[6],message[7]);
  }
 }
 else if(Header == 0x51 && dataLen >= 8){

    int Flags = message[4] + message[5] << 8 + message[6] << 16 + message[7] << 24;
    printf("BROADCASTFLAGS\t%x\n",Flags);
 }
 else if(Header == 0x60 && dataLen >= 7){

    printf("LOCO MODE\n");
    printf("Address:\t%x\n",(message[4] << 8 + message[5]));
    printf("Modues: \t%i\n",message[6]);
 }
 else if(Header == 0x70 && dataLen >= 7){

    printf("TURNOUT MODE\n");
    printf("Address:\t%x\n",(message[4] << 8 + message[5]));
    printf("Modues: \t%i\n",message[6]);
 }
 else if(Header == 0x80 && dataLen >= 15){

    printf("Block detection\n");
    if(message[4] == 0){
      printf("Address 1 to 10\n");
    }

    for(int i = 5;i<(dataLen-1);i++){
      printf("Status detector %02i\t%x\n",(i-5),message[i]);
    }
 }
 else if(Header == 0x84 && dataLen >= 20){


    int i = 4;
    short MainCurrent = message[i++] + message[i++] << 8;
    short ProgCurrent = message[i++] + message[i++] << 8;
    short FilteredMainCurrent = message[i++] + message[i++] << 8;
    short Temperature = message[i++] + message[i++] << 8;
    unsigned short SupplyVoltage = message[i++] + message[i++] << 8;
    unsigned short VCCVoltage = message[i++] + message[i++] <<8;
    unsigned char CentralState = message[i++];
    unsigned char CentralStateEx = message[i++];
# 281 "./src/Z21.c"
    printf("MainCurrent\t%imA\n",MainCurrent);
    printf("ProgCurrent\t%imA\n",ProgCurrent);
    printf("FilteredMainCurrent\t%imA\n",FilteredMainCurrent);
    printf("Temperature\t%i C\n",Temperature);
    printf("SupplyVoltage\t%imV\n",SupplyVoltage);
    printf("VCCVoltage\t%imV\n",VCCVoltage);
    printf("CentralState\t%x\n",CentralState);
    printf("CentralStateEx\t%x\n",CentralStateEx);
 }
 else if(Header == 0x88){

    printf("RAILCOM DATACHANGED\nNot supported\n");
 }
 else if(Header == 0xA0){

    printf("LOCONET RX\nNot supported\n");
 }
 else if(Header == 0xA1){

    printf("LOCONET TX\nNot supported\n");
 }
 else if(Header == 0xA2){

    printf("LOCONET FROM LAN\nNot supported\n");
 }
 else if(Header == 0xA3){

    printf("LOCONET DISPATCH ADDR\nNot supported\n");
 }
 else if(Header == 0xA4){

    printf("LOCONET DETECTOR\nNot supported\n");
 }
}

void Z21_send(int Header,char data[30]){

}

void Z21_GET_LOCO_INFO(int DCC_Adr){



  if(fd_Z21_server != 0){
    char data[10];
    data[0] = 9;
    data[2] = 0x40;
    data[4] = 0xE3;
    data[5] = 0xF0;
    data[6] = (DCC_Adr & 0x3F00) >> 8;
    data[7] = DCC_Adr & 0xFF;
    data[8] = data[4] ^ data[5] ^ data[6] ^ data[7];


    if (sendto(fd_Z21_server, data, data[0], 0 , (struct sockaddr *) &si_other, slen)==-1){
        printf("failed sendto()\n");
    }
  }else{
    printf("No Z21 server connected\n");
    char data[10];
 memset(data,0,15);

    data[0] = (DCC_Adr & 0x3F00) >> 8;
    data[1] = DCC_Adr & 0xFF;

    data[2] = 0b00000100;

    data[3] = (DCC_train[DCC_Adr]->dir << 7) + (DCC_train[DCC_Adr]->cur_speed & 0x7F);

    data[4] = 0b00000000;

    data[5] = 0b00000000;

    data[6] = 0b00000000;

    data[7] = 0b00000000;
    printf("DCC_Adr:0x%x\t=>\t%x %x",DCC_Adr,data[0],data[1]);
    WS_TrainData(data);
  }
}

void Z21_SET_LOCO_DRIVE(int DCC_Adr,char steps,_Bool dir,char drive){



  if(fd_Z21_server != 0){
    char data[10];
    data[0] = 0x0A;
    data[2] = 0x40;
    data[4] = 0xE4;
    data[5] = 0x10;
    if(steps == 28){
      data[5] += 0x2;
    }else if(steps == 128){
      data[5] += 0x3;
    }
    data[6] = (DCC_Adr & 0x3F00) >> 8;
    data[7] = DCC_Adr & 0xFF;
    data[8] = (dir << 7) + (drive & 0x7F);
    data[9] = data[4] ^ data[5] ^ data[6] ^ data[7] ^ data[8];


    if (sendto(fd_Z21_server, data, data[0], 0 , (struct sockaddr *) &si_other, slen)==-1)
    {
        printf("Failed sendto()\n");
    }
  }else{
    printf("No Z21 server connected\n");
  }
}

void Z21_SET_LOCO_FUNCTION(int DCC_Adr,char function_nr,char switch_type){



  if(fd_Z21_server != 0){
    char data[10];
    data[0] = 0x0A;
    data[2] = 0x40;
    data[4] = 0xE4;
    data[5] = 0xF8;
    data[6] = (DCC_Adr & 0x3F00) >> 8;
    data[7] = DCC_Adr & 0xFF;
    data[8] = (switch_type << 6) + (function_nr & 0x3F);
    data[9] = data[4] ^ data[5] ^ data[6] ^ data[7] ^ data[8];


    if (sendto(fd_Z21_server, data, data[0], 0 , (struct sockaddr *) &si_other, slen)==-1)
    {
        printf("Failed sendto()\n");
    }
  }else{
    printf("No Z21 server connected\n");
  }
}
# 165 "baan.c" 2
# 173 "baan.c"
void JSON_new_client(int Client_fd){
 WS_trackUpdate(Client_fd);
 WS_SwitchesUpdate(Client_fd);

 pthread_mutex_lock(&mutex_lockB);

 char buf[4096];
 char buf_l;




 buf[0] = 6;
 buf_l = 1;
 _Bool data = 0;

 if(St_list_i>0){
  data = 1;
 }
 for(int i = 1;(i-1)<St_list_i;i++){
  printf("entry %i\tStation %i:%i\t%s\tbuf_l: %i\n",i,stations[i-1]->Module,stations[i-1]->id,stations[i-1]->Name,buf_l);

  buf[buf_l] = stations[i-1]->Module;
  buf[buf_l+1] = stations[i-1]->id;
  buf[buf_l+2] = strlen(stations[i-1]->Name);
  strcpy(&buf[buf_l+3],stations[i-1]->Name);

  buf_l+=3+strlen(stations[i-1]->Name);
 }

 if(data == 1){
  send_packet(Client_fd,buf,buf_l,8);
 }

 memset(buf,0,4096);

 for(int i = 1;i<30;i++){
  if(train_link[i]){
   printf("Recall #%i\n",train_link[i]->DCC_ID);
   Z21_GET_LOCO_INFO(train_link[i]->DCC_ID);
  }
 }

 pthread_mutex_unlock(&mutex_lockB);
}

void *Test(void *threadArg){
 struct timer_thread_data *my_data;
 my_data = (struct timer_thread_data *) threadArg;
 int i = my_data->thread_id;
 int t = my_data->t;
 printf("\t%i Sleep %i\n",i,t);
 usleep(t);
 timers[i] = 2;
 printf("%i done\n",i);
}

void STOP_train(char train){
 usleep(500000);

}

void create_timer(){
 int i = 0;
 while(1){
  if(timers[i] == 0){
   timers[i] = 1;
   a[i].thread_id = i;
   a[i].t = (rand() % 50) * 100000 + 400000;
   printf("Create time %i, sleep %i\n",i,a[i].t);
   pthread_create(&timer_thread[i], ((void *)0), Test, (void *) &a[i]);
   break;
  }
  i++;
  if(i==5){
   i = 0;
   printf("Not enought timers!!!!!\n\n");
   usleep(100000);
  }
 }
}

# 1 "./src/algorithm.c" 1
struct procces_block {
 _Bool blocked;
 char length;
 struct Seg * B[5];
};

void change_block_state2(struct procces_block * A,int State){
 if(!A->blocked){
  for(int i = 0;i<A->length;i++){
   if(A->B[i]->state != State){
    A->B[i]->change = 1;
    A->B[i]->state = State;
   }
  }
 }else{
  for(int i = 0;i<A->length;i++){
   if(A->B[i]->blocked){
    break;
   }
   if(A->B[i]->state != State){
    A->B[i]->change = 1;
    A->B[i]->state = State;
   }
  }
 }
}

void procces(struct Seg * B,int debug){
 if(B->type == 'T'){
  if(!B->blocked){
   B->train = 0;
  }
  if(debug){
   struct Seg *BA = B;
   if(BA->train != 0){
    printf("ID: %i\t%c%i:%i\n",BA->train,BA->Module,BA->id);
   }





  }
 }
 else{


  struct procces_block BPPP,BPP,BP,BA,BN,BNN,BNNN;
  BA.B[0] = B;
  BA.blocked = B->blocked;
  BA.length = 1;

  struct Seg * bl[8] = {0};
  struct Seg * bpl[6] = {0};
  struct Seg * bp,*bpp,*bppp;
  struct Seg * Bl;
  bl[0] = B;
  bpl[0] = B;
  Bl = B;
  int i = 0;
  int p = 0;
  struct Seg * tB;

  int q = 4;


  for(i = 0;(i+1)<q;i){
   if(bl[i]->type != 'T'){
    Bl = bl[i];
   }
   i++;

   struct Rail_link A;
   if(dir_Comp(B,Bl)){
    A = NADR2(Bl);
   }else{
    A = PADR2(Bl);
   }
   if(A.type == 0){

    q = i;
    break;
   }else if(A.type == 's' || A.type == 'S' || A.type == 'm' || A.type == 'M'){

    if(!check_Switch(Bl,0,(!(1==1)))){

     q = i;
     break;
    }
   }
   bl[i] = Next2(B,i);


   if(i > 1 && bl[i-1]->type == 'T' && bl[i]->type == 'T' && !Block_cmp(bl[i-1],bl[i])){

    q++;
   }else if(!bl[i]){
    q = i;
    break;
   }
  }
  i--;

  char r = 4;

  for(p = 0;p<=r;){
   if(bpl[p]->type != 'T'){
    Bl = bpl[p];
   }
   p++;

   struct Rail_link A;
   if(dir_Comp(B,Bl)){
    A = PADR2(Bl);
   }else{
    A = NADR2(Bl);
   }
   if(A.type == 0){

    r = p;
    break;
   }else if(A.type == 's' || A.type == 'S' || A.type == 'm' || A.type == 'M'){

    if(!check_Switch(Bl,1,(!(1==1)))){

     r = p;
     break;
    }
   }
   bpl[p] = Prev2(B,p);


   if(p > 1 && bpl[p-1]->type == 'T' && bpl[p]->type == 'T' && !Block_cmp(bpl[p-1],bpl[p])){

    r++;
   }
   if(p == r && bpl[p]->type == 'T'){
    r++;
   }
  }
  p--;

  i = 1;
  p = 1;
  int j = 0;
  int k = -1;
  int l = -1;


  BPPP.B[0] = ((void *)0);BPPP.B[1] = ((void *)0);BPPP.B[2] = ((void *)0);BPPP.B[3] = ((void *)0);BPPP.B[4] = ((void *)0);
  BPP.B[0] = ((void *)0);BPP.B[1] = ((void *)0);BPP.B[2] = ((void *)0);BPP.B[3] = ((void *)0);BPP.B[4] = ((void *)0);
  BP.B[0] = ((void *)0);BP.B[1] = ((void *)0);BP.B[2] = ((void *)0);BP.B[3] = ((void *)0);BP.B[4] = ((void *)0);
  BN.B[0] = ((void *)0);BN.B[1] = ((void *)0);BN.B[2] = ((void *)0);BN.B[3] = ((void *)0);BN.B[4] = ((void *)0);
  BNN.B[0] = ((void *)0);BNN.B[1] = ((void *)0);BNN.B[2] = ((void *)0);BNN.B[3] = ((void *)0);BNN.B[4] = ((void *)0);
  BNNN.B[0] = ((void *)0);BNNN.B[1] = ((void *)0);BNNN.B[2] = ((void *)0);BNNN.B[3] = ((void *)0);BNNN.B[4] = ((void *)0);

  BPPP.blocked = 0;BPP.blocked = 0;BP.blocked = 0;BN.blocked = 0;BNN.blocked = 0;BNNN.blocked = 0;
  BPPP.length = 0;BPP.length = 0;BP.length = 0;BN.length = 0;BNN.length = 0;BNNN.length = 0;



  for(i;i<q;i++){
   if(i > 1 && bl[i-1]->type == 'T' && bl[i]->type == 'T'){
    j++;
   }else{
    k++;
    j = 0;
   }

   if(k == 0 && bl[i]){
    BN.B[j] = bl[i];
    BN.blocked |= BN.B[j]->blocked;
    BN.length = j+1;
   }else if(k == 1 && bl[i]){
    BNN.B[j] = bl[i];
    BNN.blocked |= BNN.B[j]->blocked;
    BNN.length = j+1;
   }else if(k == 2 && bl[i]){
    BNNN.B[j] = bl[i];
    BNNN.blocked |= BNNN.B[j]->blocked;
    BNNN.length = j+1;
   }
  }
  k++;
  i = k;




  for(p;p<=r;p++){
   if(p > 1 && bpl[p-1]->type == 'T' && bpl[p]->type == 'T'){

    j++;
   }else{
    l++;
    j = 0;
   }

   if(l == 0 && bpl[p]){
    BP.B[j] = bpl[p];
    BP.blocked |= BP.B[j]->blocked;
    BP.length++;
   }else if(l == 1 && bpl[p]){
    BPP.B[j] = bpl[p];
    BPP.blocked |= BPP.B[j]->blocked;
    BPP.length++;
   }else if(l == 2 && bpl[p]){
    BPPP.B[j] = bpl[p];
    BPPP.blocked |= BPPP.B[j]->blocked;
    BPPP.length++;
   }
  }
  l++;
  p = l;
# 228 "./src/algorithm.c"
   if(!BA.blocked && BA.B[0]->train != 0){

    BA.B[0]->train = 0;
   }else if(BA.blocked && BA.B[0]->train != 0 && train_link[BA.B[0]->train] && !train_link[BA.B[0]->train]->Cur_Block){
     train_link[BA.B[0]->train]->Cur_Block = BA.B[0];
   }
   if(k > 0 && BA.blocked && !BP.blocked && BN.blocked && BN.B[0]->train && !BA.B[0]->train){

    BA.B[0]->dir ^= 0b100;
    BN.B[0]->dir ^= 0b100;
   }
   else if(p > 0 && k > 0 && BA.blocked && BA.B[0]->train == 0 && BN.B[0]->train == 0 && BP.B[0]->train == 0){

    BA.B[0]->train = ++bTrain;

    WS_NewTrain(bTrain,BA.B[0]->Module,BA.B[0]->id);
   }
   else if(p > 0 && k > 0 && BN.blocked && BP.blocked && BN.B[0]->train == BP.B[0]->train){

    WS_TrainSplit(BN.B[0]->train,BP.B[0]->Module,BP.B[0]->id,BN.B[0]->Module,BN.B[0]->id);
   }
   if(p > 0 && BP.blocked && BA.blocked && BA.B[0]->train == 0 && BP.B[0]->train != 0){
    BA.B[0]->train = BP.B[0]->train;
    if(train_link[BA.B[0]->train])
     train_link[BA.B[0]->train]->Cur_Block = BA.B[0];
   }
   if(k > 0 && BN.B[0]->type == 'T' && BN.blocked){
    if(BN.B[0]->train == 0 && BN.B[0]->blocked && BA.blocked && BA.B[0]->train != 0){
     BN.B[0]->train = BA.B[0]->train;
     if(train_link[BN.B[0]->train])
      train_link[BN.B[0]->train]->Cur_Block = BN.B[0];
    }else if(BN.length > 1){
     for(int a = 1;a<BN.length;a++){
      if(BN.B[a-1]->blocked && BN.B[a]->blocked && BN.B[a]->train == 0 && BN.B[a-1]->train != 0){
       BN.B[a]->train = BN.B[a-1]->train;
       if(train_link[BN.B[a]->train])
        train_link[BN.B[a]->train]->Cur_Block = BN.B[a];
       break;
      }
     }
    }
   }




   int New_Switch = 0;
   struct Rail_link NAdr,NNAdr;

   NAdr = NADR2(BA.B[BA.length - 1]);
   if(k > 0){
    NNAdr = NADR2(BN.B[BN.length - 1]);
   }

   if((NNAdr.type == 's' || NNAdr.type == 'S' || NNAdr.type == 'm' || NNAdr.type == 'M') && BA.blocked){

    if(BA.B[0]->train != 0 && train_link[BA.B[0]->train] && train_link[BA.B[0]->train]->Destination){

     if(check_Switch_state(NNAdr)){

      New_Switch = 2;
      printf("Free switch ahead (OnRoute %i:%i)\n",BA.B[0]->Module,BA.B[0]->id);
      if(!free_Route_Switch(BN.B[BN.length - 1],0,train_link[BA.B[0]->train])){
       printf("FAILED to set switch according Route\n");
       New_Switch = 0;
      }
     }
    }else{

     if(check_Switch_state(NNAdr)){

      New_Switch = 2;
      printf("Free switch ahead %i:%i\n",BA.B[0]->Module,BA.B[0]->id);
      if(!check_Switch(BN.B[BN.length - 1],0,(1==1))){

       printf("Check Switch\n");
       if(!free_Switch(BN.B[BN.length - 1],0)){
        New_Switch = 0;
    }}}}
   }else if((NAdr.type == 's' || NAdr.type == 'S' || NAdr.type == 'm' || NAdr.type == 'M') && BA.blocked){

    if(BA.B[0]->train != 0 && train_link[BA.B[0]->train] && train_link[BA.B[0]->train]->Destination){

     if(check_Switch_state(NAdr)){

      New_Switch = 1;
      printf("Free switch ahead (OnRoute %i:%i)\n",BA.B[0]->Module,BA.B[0]->id);
      if(!free_Route_Switch(BA.B[BA.length - 1],0,train_link[BA.B[0]->train])){
       New_Switch = 0;
      }
     }
    }else{

     if(check_Switch_state(NNAdr)){
      New_Switch = 1;

      printf("Free switch ahead %i:%i\n",BA.B[0]->Module,BA.B[0]->id);
      if(!check_Switch(BN.B[BN.length - 1],0,(1==1))){

       printf("Check Switch\n");
       if(!free_Switch(BN.B[BN.length - 1],0)){
        printf("FAILED to set switch according Route\tSTOPPING TRAIN\n");
        New_Switch = 0;
    }}}}
   }


   if(New_Switch > 0){
    printf("Switch thrown");
    if(k < 1){
     printf("BN  NEEDED\t");
     BN.B[0] = Next2(BA.B[0],1+BN.length);
     if(BN.B[0]){
      BN.length++;
      BN.blocked |= BN.B[0]->blocked;
      if(BN.B[0]->type == 'T'){
       BN.B[1] = Next2(BA.B[0],1+BN.length);
       if(BN.B[1]->type == 'T'){
        BN.length++;
        BN.blocked |= BN.B[1]->blocked;
       }else{
        BN.B[1] = ((void *)0);
       }
      }
      k++;
     }
    }
    if(k < 2){
     printf("BNN  NEEDED\t");
     BNN.B[0] = Next2(BA.B[0],1+BN.length+BNN.length);
     if(BNN.B[0]){
      BNN.length++;
      BNN.blocked |= BNN.B[0]->blocked;
      if(BNN.B[0]->type == 'T'){
       BNN.B[1] = Next2(BA.B[0],1+BN.length+BNN.length);
       if(BNN.B[1]->type == 'T'){
        BNN.length++;
        BNN.blocked |= BNN.B[1]->blocked;
       }else{
        BNN.B[1] = ((void *)0);
       }
      }
      k++;
     }
    }
    if(k < 3){
     BNNN.B[0] = Next2(BA.B[0],1+BN.length+BNN.length+BNNN.length);
     if(BNNN.B[0]){
      BNNN.length++;
      BNNN.blocked |= BNNN.B[0]->blocked;
      if(BNNN.B[0]->type == 'T'){
       BNNN.B[1] = Next2(BA.B[0],1+BN.length+BNN.length+BNNN.length);
       if(BNNN.B[1]->type == 'T'){
        BNNN.length++;
        BNNN.blocked |= BNNN.B[1]->blocked;
       }else{
        BNNN.B[1] = ((void *)0);
       }
      }
      k++;
     }
    }
   }

   if(New_Switch == 1){
    change_block_state2(&BN,5);
   }else if(New_Switch == 2){
    change_block_state2(&BNN,5);
   }
# 424 "./src/algorithm.c"
   if(i > 0 && BA.blocked && BN.B[0] && BN.B[0]->type != 'T' && !BN.blocked && !dir_Comp(BA.B[0],BN.B[0])){
    BN.B[0]->dir ^= 0b100;
   }


   if(i > 1 && BA.blocked && BNN.B[0] && BNN.B[0]->type != 'T' && !dir_Comp(BA.B[0],BNN.B[0]) &&
       (BN.B[0]->type == 'T' || !(dir_Comp(BA.B[0],BN.B[0]) == dir_Comp(BN.B[0],BNN.B[0])))){

    printf("Reverse in advance 1\n");
    if(BNN.B[0]->type == 'S'){
     printf("Whole platform\n");
     for(int a = 0;a<8;a++){
      if(BNN.B[0]->Station->Blocks[a]){
       if(BNN.B[0]->Station->Blocks[a]->blocked){
        break;
       }
       BNN.B[0]->Station->Blocks[a]->dir ^= 0b100;
      }
     }
    }else{
     BNN.B[0]->dir ^= 0b100;
    }
   }
# 457 "./src/algorithm.c"
   if(p > 0 && BA.blocked && !BP.blocked){
    change_block_state2(&BP,2);
    if(p > 2)
     change_block_state2(&BPPP,0);
    if(p > 1)
     change_block_state2(&BPP,1);
   }
   else if(i > 0 && !BA.blocked && BN.blocked && BN.B[0]->type == 'T'){
    change_block_state2(&BA,2);
    if(p > 0)
     change_block_state2(&BP,1);
    if(p > 1)
     change_block_state2(&BPP,0);
   }
   else if(p > 1 && k > 1 && !BA.blocked && !BN.blocked && !BP.blocked && !BNN.blocked && !BPP.blocked){
    change_block_state2(&BA,0);
    if(p > 2 && !BPPP.blocked){
     change_block_state2(&BP,0);
    }
    if(k > 2 && !BNNN.blocked){
     change_block_state2(&BN,0);
    }
   }




   if(BA.B[0]->NSi && k > 0){



    if(((BA.B[0]->dir == 0 || BA.B[0]->dir == 1 || BA.B[0]->dir == 2) && !check_Switch(BA.B[0],0,(1==1))) || (BA.B[0]->dir == 4 || BA.B[0]->dir == 5 || BA.B[0]->dir == 6)){
     set_signal(BA.B[0]->NSi,2);
    }

    if(!(BA.B[0]->dir == 4 || BA.B[0]->dir == 5 || BA.B[0]->dir == 6) && check_Switch(BA.B[0],0,(1==1)) && i > 0){

     if(BN.blocked || BN.B[0]->state == 2){
      set_signal(BA.B[0]->NSi,2);
     }else if(BN.B[0]->state == 4){
      set_signal(BA.B[0]->NSi,3);
     }else if(BN.B[0]->state == 1){
      set_signal(BA.B[0]->NSi,1);
     }else{
      set_signal(BA.B[0]->NSi,0);
     }
    }
   }
   else if(BA.B[0]->NSi && k == 0){
    set_signal(BA.B[0]->NSi,2);
   }


   if(BA.B[0]->PSi && p > 0){





    if(((BA.B[0]->dir == 4 || BA.B[0]->dir == 5 || BA.B[0]->dir == 6) && !check_Switch(BA.B[0],0,(1==1))) || (BA.B[0]->dir == 0 || BA.B[0]->dir == 1 || BA.B[0]->dir == 2)){
     set_signal(BA.B[0]->PSi,2);

    }

    if(!(BA.B[0]->dir == 0 || BA.B[0]->dir == 1 || BA.B[0]->dir == 2) && check_Switch(BA.B[0],0,(1==1)) && i > 0){

     if(BN.blocked || BN.B[0]->state == 2){
      set_signal(BA.B[0]->PSi,2);
     }else if(BN.B[0]->state == 4){
      set_signal(BA.B[0]->PSi,3);
     }else if(BN.B[0]->state == 1){
      set_signal(BA.B[0]->PSi,1);
     }else{
      set_signal(BA.B[0]->PSi,0);
     }
    }
   }
   else if(BA.B[0]->PSi && p == 0){
    set_signal(BA.B[0]->NSi,2);
   }




   if(BA.blocked && train_link[BA.B[0]->train]){
    if(k == 0){
     train_link[BA.B[0]->train]->halt = 1;
    }else if(k > 0 && train_link[BA.B[0]->train]->halt == 1){
     train_link[BA.B[0]->train]->halt = 0;
    }
   }
   if(digital_track == 1){



    if(BA.blocked && BN.B[0]->blocked && BA.B[0]->train != BN.B[0]->train){
     if(train_link[BA.B[0]->train]){

      printf("COLLISION PREVENTION\n\t");
      train_stop(train_link[BA.B[0]->train]);
     }else{

      printf("COLLISION PREVENTION\tEM_STOP\n\t");
      WS_EmergencyStop();
     }
    }

    if(((BA.blocked && !BN.blocked && BN.B[0]->state == 2) || (k == 0 && BA.blocked))){
     if(train_link[BA.B[0]->train]){
      if(train_link[BA.B[0]->train]->timer != 1){

       printf("NEXT SIGNAL: RED\n\tSTOP TRAIN:");
       train_signal(BA.B[0],train_link[BA.B[0]->train],2);
      }
     }else{

      printf("STOP TRAIN\tEM_STOP\n\t");
      WS_EmergencyStop();
     }
    }
    else if(k > 1 && BN.blocked && !BNN.blocked && BNN.B[0]->state == 2){
     if(train_link[BN.B[0]->train]){
      if(train_link[BN.B[0]->train]->timer != 1){

       printf("NEXT SIGNAL: RED\n\tSTOP TRAIN:");
       train_signal(BN.B[0],train_link[BN.B[0]->train],2);
      }
     }else{

      printf("STOP TRAIN\tEM_STOP\n\t");
      WS_EmergencyStop();
     }
    }

    if(((BA.blocked && !BN.blocked && BN.B[0]->state == 1) || (k == 1 && BA.blocked && !BN.blocked))){
     printf("Next AMBER\n");
     if(train_link[BA.B[0]->train]){
      if(train_link[BA.B[0]->train]->timer != 1){

       printf("NEXT SIGNAL: AMBER\n\tSLOWDOWN TRAIN:\t");
       train_signal(BA.B[0],train_link[BA.B[0]->train],2);
      }
     }
    }



    if(k > 0 && !BN.blocked && BA.B[0]->train != 0 && train_link[BA.B[0]->train] && train_link[BA.B[0]->train]->timer != 2 && train_link[BA.B[0]->train]->timer != 1){
     if((BN.B[0]->state == 0 || BN.B[0]->state == 5) && train_link[BA.B[0]->train]->cur_speed < BA.B[0]->max_speed && BN.B[0]->max_speed >= BA.B[0]->max_speed){
      printf("Next block has a higher speed limit (%i > %i)",BN.B[0]->max_speed,BA.B[0]->max_speed);
      train_speed(BA.B[0],train_link[BA.B[0]->train],BA.B[0]->max_speed);
     }
    }


    if(BA.B[0]->train != 0 && train_link[BA.B[0]->train] && train_link[BA.B[0]->train]->timer != 2){
     if(k > 0 && (BN.B[0]->state == 0 || BN.B[0]->state == 5) && train_link[BA.B[0]->train]->cur_speed > BN.B[0]->max_speed && BN.B[0]->type != 'T'){
      printf("Next block has a lower speed limit");
      train_speed(BN.B[0],train_link[BA.B[0]->train],BN.B[0]->max_speed);
     }else if(k > 1 && BN.B[0]->type == 'T' && BNN.B[0]->type != 'T' && (BNN.B[0]->state == 0 || BNN.B[0]->state == 5) && train_link[BA.B[0]->train]->cur_speed > BNN.B[0]->max_speed){
      printf("Block after Switches has a lower speed limit");
      train_speed(BNN.B[0],train_link[BA.B[0]->train],BNN.B[0]->max_speed);
     }else if(train_link[BA.B[0]->train]->cur_speed != BN.B[0]->max_speed && BN.B[0]->type != 'T'){
      printf("%i <= %i\n",train_link[BA.B[0]->train]->cur_speed,BN.B[0]->max_speed && BN.B[0]->type != 'T');
     }
    }



    if(BA.B[0]->train != 0 && train_link[BA.B[0]->train] && !Block_cmp(0,train_link[BA.B[0]->train]->Destination)){
     if(k > 0 && Block_cmp(train_link[BA.B[0]->train]->Destination,BN.B[0])){
      printf("Destination almost reached\n");
      train_signal(BA.B[0],train_link[BA.B[0]->train],1);
     }else if(Block_cmp(train_link[BA.B[0]->train]->Destination,BA.B[0])){
      printf("Destination Reached\n");
      train_signal(BA.B[0],train_link[BA.B[0]->train],2);
      train_link[BA.B[0]->train]->Destination = 0;
      train_link[BA.B[0]->train]->halt = (1==1);
     }
    }

   }



   if(BA.B[0]->train != 0){

   }
   if(debug){
    if(p > 2){
     printf("PPP ");
     for(int i = 1;i>=0;i--){
      if(BPPP.B[i]){
       printf("%02i:%02i",BPPP.B[i]->Module,BPPP.B[i]->id);
       if(BPPP.B[i]->blocked){
        printf("B  ");
       }else{
        printf("   ");
       }
      }else{
       printf("        ");
      }
     }
    }else{
     printf("                    ");
    }
    if(p > 1){
     printf("PP ");
     for(int i = 1;i>=0;i--){
      if(BPP.B[i]){
       printf("%02i:%02i",BPP.B[i]->Module,BPP.B[i]->id);
       if(BPP.B[i]->blocked){
        printf("B  ");
       }else{
        printf("   ");
       }
      }else{
       printf("        ");
      }
     }
    }else{
     printf("                   ");
    }
    if(p > 0){
     printf("P ");
     for(int i = 1;i>=0;i--){
      if(BP.B[i]){
       printf("%02i:%02i",BP.B[i]->Module,BP.B[i]->id);
       if(BP.B[i]->blocked){
        printf("B  ");
       }else{
        printf("   ");
       }
      }else{
       printf("        ");
      }
     }
    }else{
     printf("                  ");
    }
    printf("A%i %c%02i:%02i;T%iD%iS%i",BA.length,BA.B[0]->type,BA.B[0]->Module,BA.B[0]->id,BA.B[0]->train,BA.B[0]->dir,BA.B[0]->state);
    if(BA.B[0]->blocked){
     printf("B");
    }
    printf("\t");
    if(i > 0){
     printf("N ");
     for(int i = 0;i<2;i++){
      if(BN.B[i]){
       printf("%02i:%02i",BN.B[i]->Module,BN.B[i]->id);
       if(BN.B[i]->blocked){
        printf("B  ");
       }else{
        printf("   ");
       }
      }else{
       printf("        ");
      }
     }
    }if(i > 1){
     printf("NN ");
     for(int i = 0;i<2;i++){
      if(BNN.B[i]){
       printf("%02i:%02i",BNN.B[i]->Module,BNN.B[i]->id);
       if(BNN.B[i]->blocked){
        printf("B  ");
       }else{
        printf("   ");
       }
      }else{
       printf("        ");
      }
     }
    }
    if(i > 2){
     printf("NNN ");
     for(int i = 0;i<2;i++){
      if(BNNN.B[i]){
       printf("%02i:%02i",BNNN.B[i]->Module,BNNN.B[i]->id);
       if(BNNN.B[i]->blocked){
        printf("B  ");
       }else{
        printf("   ");
       }
      }else{
       printf("        ");
      }
     }
    }

    printf("\n");

    if(BA.B[0]->PSi || BA.B[0]->NSi){
     if(BA.B[0]->PSi){
      printf("\t\t\t\t\t\t%i  ",BA.B[0]->PSi->id);
      uint8_t state = BA.B[0]->PSi->state & 0x7F;
      if(state == 2 )printf("RED");
      if(state == 1)printf("AMBER");
      if(state == 0)printf("GREEN");
      if(state == 3)printf("RESTR");
      printf("\t\t");
     }else{
      printf("\t\t\t\t\t\t\t\t\t");
     }
     if(BA.B[0]->NSi){
      printf("\t%i  ",BA.B[0]->NSi->id);
      uint8_t state = BA.B[0]->NSi->state & 0x7F;
      if(state == 2 )printf("RED");
      if(state == 1)printf("AMBER");
      if(state == 0)printf("GREEN");
      if(state == 3)printf("RESTR");
     }
     printf("\n\n");
    }
   }

 }
}

void procces_accessoire(){
 for(int i = 0;i<16;i++){
  if(Units[i] && Units[i]->Sig_change){
   printf("Signals of module %i changed\n",i);
   for(int j = 0;j<(16*8);j++){
    if(Units[i]->Signals[j]){
     printf("Signal id: %i\n",Units[i]->Signals[j]->id);
    }
   }
   Units[i]->Sig_change = (!(1==1));
  }
 }
}
# 256 "baan.c" 2
# 1 "./src/pathfinding.c" 1
int pathFinding(struct Seg * Begin, struct Seg * End, struct Sw_train_PATH *(OUT_Sw_Nodes)[200], int * len){
 struct Rail_link NAdr,SNAdr;
 struct Seg * B = Begin;
 struct Sw_A_PATH * Sw_Nodes[200] = {((void *)0)};
 int nr_switches = 0;
 struct Sw_A_PATH * Prev_PATH_Node = ((void *)0);
 struct Sw_A_PATH * Curr_PATH_Node = ((void *)0);

 char list_of_M[16] = {0};

 _Bool init = (1==1);
 _Bool found = (!(1==1));

 int a = 0;

 *len = 0;

 printf("Pathfinding form %c%i:%i to %c%i:%i\n",B->type,B->Module,B->id,End->type,End->Module,End->id);

 int direct = B->dir;
 char prev_dir = direct;

 Next_Adr:{};

 if(!B){
  goto Next_Switch;
 }

 char dir = B->dir;


 if((prev_dir == 0 && dir == 1) || (prev_dir == 129 && dir == 0)){
  prev_dir ^= 0x80;
  NAdr = B->Next;
 }
 else if((prev_dir == 1 && dir == 0) || (prev_dir == 128 && dir == 1)){
  prev_dir ^= 0x80;
  NAdr = B->Prev;
 }
 else if((prev_dir >> 7) == 1){
  if(dir == 0 || dir == 2 || dir == 5){
   NAdr = B->Prev;
  }else{
   NAdr = B->Next;
  }
 }
 else if(dir == 0 || dir == 2 || dir == 5){
  NAdr = B->Next;
 }
 else{
  NAdr = B->Prev;
 }

 prev_dir = (prev_dir & 0xC0) + (dir & 0xF);

 Next_Switch:{};
# 70 "./src/pathfinding.c"
 if(NAdr.type == 'R' && End == NAdr.B){
  printf("\nFOUND\n\n");
  FOUND:{}



  for(int i = 0;i<200;i++){
   if(Sw_Nodes[i]){
    for(int j = 0;j<10;j++){
     if(Sw_Nodes[i]->suc[j] == 1){
      Sw_Nodes[i]->suc[j] = 2;
     }
    }


    _Bool A = (!(1==1));
    for(int k = 0;k<16;k++){
     if(Sw_Nodes[i]->adr.Sw && (list_of_M[k] == Sw_Nodes[i]->adr.Sw->Module || list_of_M[k] == 0)){
      list_of_M[k] = Sw_Nodes[i]->adr.Sw->Module;
      break;
     }else if(Sw_Nodes[i]->adr.M && (list_of_M[k] == Sw_Nodes[i]->adr.M->Module || list_of_M[k] == 0)){
      list_of_M[k] = Sw_Nodes[i]->adr.M->Module;
      break;
     }
    }
   }else{
    break;
   }
  }
  found = (1==1);

  for(int i = 0;i<200;i++){

   if(Sw_Nodes[i] != ((void *)0)){

    if(Sw_Nodes[i]->adr.type == 'S' && (Sw_Nodes[i]->suc[0] == 0 || Sw_Nodes[i]->suc[1] == 0)){
     Curr_PATH_Node = Sw_Nodes[i];
          NAdr = Curr_PATH_Node->adr;
          dir = prev_dir = Curr_PATH_Node->dir;

     usleep(1000);
     goto Next_Switch;
    }else if((Sw_Nodes[i]->adr.type == 'm' || Sw_Nodes[i]->adr.type == 'M')){
# 126 "./src/pathfinding.c"
    }
   }else{
    break;
   }
  }

  goto DONE;
  return 1;
 }

 usleep(2000);

 if(NAdr.type == 0 || (NAdr.type == 'R' && NAdr.B->oneWay == 1 && (char)(dir + (prev_dir & 0x80)) != NAdr.B->dir)){
    if(NAdr.type == 0){

    }else{

    }
  goto FAIL;
 }
 else if(NAdr.type == 'R' && NAdr.B == Begin){

  goto FAIL;
 }
 else if(NAdr.type == 'R'){
  B = NAdr.B;
  goto Next_Adr;
 }
 else if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'm' || NAdr.type == 'M'){

  if((NAdr.type == 'S' || NAdr.type == 's') && NAdr.Sw->Detection_Block && !Block_cmp(NAdr.Sw->Detection_Block,B)){
   a++;
  }
  if(NAdr.type == 'S'){

   goto New_S_Node;
   Ret_S_Node:{}


   if(Curr_PATH_Node){
    if(Curr_PATH_Node->suc[0] == 1){
     SNAdr = NAdr.Sw->str;
    }
    else if(Curr_PATH_Node->suc[1] == 1){
     SNAdr = NAdr.Sw->div;
    }
   }
  }
  else if(NAdr.type == 's'){
   SNAdr = NAdr.Sw->app;


  }
  else if(NAdr.type == 'M'){
   goto New_M_Node;
   Ret_M_Node:{}


   if(Curr_PATH_Node){
    for(int i = 0;i<NAdr.M->length;i++){
     if(Curr_PATH_Node->suc[i] == 1){
      SNAdr = NAdr.M->m_Adr[i];
      break;
  }}}}
  else if(NAdr.type == 'm'){
   goto New_M_Node;
   Ret_m_Node:{}


   if(Curr_PATH_Node != ((void *)0)){
    for(int i = 0;i<NAdr.M->length;i++){
     if(Curr_PATH_Node->suc[i] == 1){
      SNAdr = NAdr.M->M_Adr[i];
  }}}}

  if(SNAdr.type == 'S' || SNAdr.type == 's' || SNAdr.type == 'M' || SNAdr.type == 'm'){
   NAdr = SNAdr;
   goto Next_Switch;
  }
  else if(SNAdr.type == 'R'){
   B = SNAdr.B;
   NAdr.B = B;
   NAdr.type = 'R';

   goto Next_Switch;
  }else if(SNAdr.type == 0){
   goto FAIL;
  }
 }
 else{
  printf("\n\n!!!!!!!!!UNKOWN RAIL_LINK TYPE!!!!!\n\n");
 }
  printf("Return 0\n");
 return 0;

 FAIL:{



  if(Curr_PATH_Node){

      if(Curr_PATH_Node->adr.type == 'S'){
        if(Curr_PATH_Node->suc[0] == 1){
          Curr_PATH_Node->suc[0] = -1;
         Curr_PATH_Node->suc[1] = 1;


     NAdr = Curr_PATH_Node->adr;
     dir = prev_dir = Curr_PATH_Node->dir;


     if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
      goto Next_Switch;
     }else{
      goto Next_Adr;
     }
        }
    else if(Curr_PATH_Node->suc[1] == 1){
          Curr_PATH_Node->suc[1] = -1;
        }
    if(Curr_PATH_Node->suc[0] == 2 || Curr_PATH_Node->suc[1] == 2){

     if(found == (1==1)){
      goto FOUND;
     }else if(!Curr_PATH_Node->Prev){
      goto NOT_FOUND;
     }
    }
      }
   else{
     for(int i = 0;i<10;i++){
      if(Curr_PATH_Node->suc[i] == 1){
       Curr_PATH_Node->suc[i] = -1;

      if((i+1) < Curr_PATH_Node->adr.M->length){
        Curr_PATH_Node->suc[i+1] = 1;
      }


       NAdr = Curr_PATH_Node->adr;
       dir = prev_dir = Curr_PATH_Node->dir;


       if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
        goto Next_Switch;
       }else{
        goto Next_Adr;
       }
      }
     }
      }


   Curr_PATH_Node = Curr_PATH_Node->Prev;
   goto FAIL;
  }else{
   printf("No Curr_PATH_Node\n");
  }
 }

 printf("Return FAIL\n");
 return 0;

 New_S_Node:{


  if((Curr_PATH_Node && !Link_cmp(Curr_PATH_Node->adr,NAdr)) || !Curr_PATH_Node){
   if(Sw_Nodes[0] && Link_cmp(Sw_Nodes[0]->adr,NAdr)){


    if(Curr_PATH_Node){
     for(int i = 0;i<10;i++){
      if(Curr_PATH_Node->suc[i] == 1){
       Curr_PATH_Node->suc[i] = -1;
       NAdr = Curr_PATH_Node->adr;
       dir = Curr_PATH_Node->dir;
       prev_dir = dir;
       if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
        goto Next_Switch;
       }else{
        goto Next_Adr;
       }
      }
     }
    }
   }
   else if(found == (1==1)){

    for(int i = 0;i<16;i++){
     if(list_of_M[i] == NAdr.Sw->Module){
      break;
     }

     if((i+1) == 16){
      if(Curr_PATH_Node){
       for(int i = 0;i<10;i++){
        if(Curr_PATH_Node->suc[i] == 1){
         Curr_PATH_Node->suc[i] = -1;
         NAdr = Curr_PATH_Node->adr;
         dir = Curr_PATH_Node->dir;
         prev_dir = dir;
         if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
          goto Next_Switch;
         }else{
          goto Next_Adr;
         }
        }
       }
       if(found == (1==1)){
        goto FOUND;
       }
       Curr_PATH_Node = Curr_PATH_Node->Prev;
      }
     }
    }

    for(int i = 0;i<200;i++){
     if(Sw_Nodes[i] != ((void *)0) && Link_cmp(Sw_Nodes[i]->adr,NAdr)){

      if(Sw_Nodes[i]->adr.type == 'S'){

       if(Sw_Nodes[i]->suc[0] == -1 && Sw_Nodes[i]->suc[1] == -1){

        goto FAIL;
       }
      }
      goto FOUND;
      break;
     }
    }
   }



   struct Sw_A_PATH * Z = (struct Sw_A_PATH *)malloc(sizeof(struct Sw_A_PATH ));

   Z->adr = NAdr;
   Z->length = 2;
   memset(Z->suc,0,10);
   Z->suc[0] = 1;
   Z->dir = dir + (prev_dir & 0x80);
   Z->Prev = Curr_PATH_Node;

   for(int i = 0;i<200;i++){
    if(Sw_Nodes[i] == ((void *)0)){

     Sw_Nodes[i] = Z;

     break;
    }else{

    }
   }

   Curr_PATH_Node = Z;
  }
  else if(Curr_PATH_Node && Link_cmp(Curr_PATH_Node->adr,NAdr)){

   if(Curr_PATH_Node->suc[0] != 0 && Curr_PATH_Node->suc[0] != 1){
    if(Curr_PATH_Node->suc[1] == 0){

     Curr_PATH_Node->suc[1] = 1;
    }else if(Curr_PATH_Node->suc[1] == -1){
     goto FAIL;
    }
   }
  }
  goto Ret_S_Node;
 }

 printf("Return New_S_Node\n");
 return 0;

 New_M_Node:{

  if((Curr_PATH_Node && !Link_cmp(Curr_PATH_Node->adr,NAdr)) || !Curr_PATH_Node){
   if(Sw_Nodes[0] && Link_cmp(Sw_Nodes[0]->adr,NAdr)){


    if(Curr_PATH_Node != ((void *)0)){
     for(int i = 0;i<10;i++){
      if(Curr_PATH_Node->suc[i] == 1){
       Curr_PATH_Node->suc[i] = -1;
       NAdr = Curr_PATH_Node->adr;
       dir = Curr_PATH_Node->dir;
       prev_dir = dir;
       if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
        goto Next_Switch;
       }else{
        goto Next_Adr;
       }
      }
     }
    }
   }
   else if(found == (1==1)){

    for(int i = 0;i<16;i++){
     if(list_of_M[i] == NAdr.M->Module){
      break;
     }

     if((i+1) == 16){
      if(Curr_PATH_Node != ((void *)0)){
       for(int i = 0;i<10;i++){
        if(Curr_PATH_Node->suc[i] == 1){
         Curr_PATH_Node->suc[i] = -1;
         NAdr = Curr_PATH_Node->adr;
         dir = Curr_PATH_Node->dir;
         prev_dir = dir;
         if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
          printf("Next_Switch\n");
          goto Next_Switch;
         }else{
          goto Next_Adr;
         }
        }
       }
       if(found == (1==1)){
        goto FOUND;
       }
       Curr_PATH_Node = Curr_PATH_Node->Prev;
      }
     }
    }
   }

   for(int i = 0;i<200;i++){
    if(Sw_Nodes[i] && Link_cmp(Sw_Nodes[i]->adr,NAdr)){
     printf("Allready known Node\n");
     if(Sw_Nodes[i]->adr.type == 'S'){
      printf("It a switch\t");
      if(Sw_Nodes[i]->suc[0] == -1 && Sw_Nodes[i]->suc[1] == -1){
       printf("Both have no route\t");
       goto FAIL;
      }
     }else if(Sw_Nodes[i]->adr.type == 'M' || Sw_Nodes[i]->adr.type == 'm'){
      printf("It a MS switch\t");
      _Bool NoSucc = (1==1);
      for(int i = 0;i<Sw_Nodes[i]->adr.M->length;i++){
       if(Sw_Nodes[i]->suc[i] == 2){
        NoSucc = (!(1==1));
        break;
       }
      }
      if(NoSucc == (1==1)){
       printf("No route\t");
       goto FAIL;
      }
     }
     goto FOUND;
     break;
    }
   }



   struct Sw_A_PATH * Z = (struct Sw_A_PATH *)malloc(sizeof(struct Sw_A_PATH ));

   Z->adr = NAdr;
   Z->length = 2;
   memset(Z->suc,0,10);
   Z->suc[0] = 1;
   Z->dir = prev_dir;
   Z->Prev = Curr_PATH_Node;

   for(int i = 0;i<200;i++){
    if(Sw_Nodes[i] == ((void *)0)){
     printf("%i",i);
     Sw_Nodes[i] = Z;
     break;
    }
   }

   Curr_PATH_Node = Z;
  }
  else if(Curr_PATH_Node && Link_cmp(Curr_PATH_Node->adr,NAdr)){

   for(int i = 0;i<NAdr.M->length;i++){
    if(Curr_PATH_Node->suc[i] == 0){

     Curr_PATH_Node->suc[i] = 1;
    }else if(Curr_PATH_Node->suc[i] == -1 && (i+1) == NAdr.M->length){

     Curr_PATH_Node = Curr_PATH_Node->Prev;
     NAdr = Curr_PATH_Node->adr;
     if(NAdr.type == 'S' || NAdr.type == 's' || NAdr.type == 'M' || NAdr.type == 'm'){
      goto Next_Switch;
     }else{
      goto Next_Adr;
     }
    }
   }
  }
  if(NAdr.type == 'M'){
   goto Ret_M_Node;
  }else{
   goto Ret_m_Node;
  }
 }

 printf("Return New_S_Node\n");
 return 0;

 NOT_FOUND:{}


 printf("Return NOT_FOUND\n");
 return 0;

 DONE:{}

 printf("All Switches:\n");

 int k = 0;

 for(int i = 0;i<200;i++){
  if(Sw_Nodes[i]){
   _Bool A = (!(1==1));
   for(int j = 0;j<10;j++){
    if(Sw_Nodes[i]->suc[j] == 2){
     A = (1==1);
    }
   }
   if(A){
    printf("\n%i\t%c",k,Sw_Nodes[i]->adr.type);
    (*len)++;
    if(Sw_Nodes[i]->adr.type == 'S' || Sw_Nodes[i]->adr.type == 's'){
     printf("%i:%i  \t",Sw_Nodes[i]->adr.Sw->Module,Sw_Nodes[i]->adr.Sw->id);
    }else if(Sw_Nodes[i]->adr.type == 'M' || Sw_Nodes[i]->adr.type == 'm'){
     printf("%i:%i  \t",Sw_Nodes[i]->adr.M->Module,Sw_Nodes[i]->adr.M->id);
    }
    for(int j = 0;j<10;j++){
     if(Sw_Nodes[i]->suc[j] == 0){
      break;
     }
     printf("%d\t",Sw_Nodes[i]->suc[j]);
    }

    struct Sw_train_PATH * Z = (struct Sw_train_PATH *)malloc(sizeof(struct Sw_train_PATH ));
    Z->adr = Sw_Nodes[i]->adr;
    Z->states == 0;
    for(int l = 0;l<10;l++){
     if(Sw_Nodes[i]->suc[l] == 2){
      Z->suc[Z->states++] = l;
     }
    }
    *OUT_Sw_Nodes++ = Z;
   }
  }else{
   break;
  }
 }
 printf("Len: %i\n",*len);
 return 1;
}
# 257 "baan.c" 2

void *do_Magic(){
 while(!stop){

  clock_t t;
  t = clock();
  pthread_mutex_lock(&mutex_lockA);
# 284 "baan.c"
  _Bool debug;
  for(int i = 0;i<16;i++){
   if(Units[i]){
    for(int j = 0;j<=Units[i]->B_nr;j++){
     if(Units[i]->B[j]){

      procces(Units[i]->B[j],0);
     }
    }
   }
  }
  WS_trackUpdate(0);

  pthread_mutex_unlock(&mutex_lockA);
  t = clock() - t;



  procces_accessoire();






  usleep(1000000);
 }
}

void do_once_Magic(){
 pthread_mutex_lock(&mutex_lockA);
 for(int i = 0;i<16;i++){
  if(Units[i]){
   for(int j = 0;j<=Units[i]->B_nr;j++){
    if(Units[i]->B[j]){

     procces(Units[i]->B[j],0);
    }
   }
  }
 }
 COM_change_A_signal(4);
 COM_change_switch(4);
 WS_trackUpdate(0);
 pthread_mutex_unlock(&mutex_lockA);
}

void *STOP_FUNC(){

 while(!stop){
  printf("Type q{Enter} to stop\n");

  int r;
  unsigned char c;
    if ((r = read(0, &c, sizeof(c))) < 0) {
        continue;
    } else {
        if(c == 'q'){
     stop = 1;
     break;
    }
    }
 }
 printf("STOPPING...\n");
}

void *clear_timers(){
 while(!stop){
  for(int i = 0;i<5;i++){
   if(timers[i] == 2){
    pthread_join(timer_thread[i], ((void *)0));
    timers[i] = 0;
    printf("Reset time %i\n",i);
   }
  }
  usleep(10000);
 }
}

void main(){
 setbuf(stdout,((void *)0));
 setbuf(stderr,((void *)0));
 signal(13, ((__sighandler_t) 1));
 srand(time(((void *)0)));

  wiringPiSetup();

  pinMode(0, 1);
  pinMode(1, 1);
  digitalWrite(0,0);
  digitalWrite(1,0);

  printf("\n\n                o  o   o\n");
  printf("            O  o  o\n");
  printf("        o oO  o\n");
  printf("      OoO\n");
  printf("     oOo ___             __________  ___________  ___________  __-----__\n");
  printf("    _\\/__|_|_  _,oo.,_  | |.\\/.| |  |         |  | EXPRESS |  ||_| |_||\n");
  printf("   [=      _|--|______|--|_|_/\\_|_|--|_________|--|_________|--|_______|\n");
  printf("   //o--=OOO-  o  o  o    o  o     o  o     o  o   o\n");

  printf("----------------------------------------------------------------------------\n");
  printf("|                                                                          |\n");
  printf("|                         RASPBERRY RAIL SOFTWARE                          |\n");
  printf("|                               is booting                                 |\n");
  printf("|                                                                          |\n");
  printf("----------------------------------------------------------------------------\n");
  printf("|                                                                          |\n");


  printf("----------------------------------------------------------------------------\n");
  printf("|                                                                          |\n");
  printf("|                               Web server                                 |\n");
  printf("|                                                                          |\n");
  pthread_t thread_web_server;
  pthread_create(&thread_web_server, ((void *)0), web_server, ((void *)0));
  WS_init_Message_List();
  printf("|                           MessageBox Cleared                             |\n");
  printf("|                                                                          |\n");
  usleep(100000);

  printf("|                                  UART                                    |\n");
  printf("|                                                                          |\n");

  pthread_t thread_UART;
  pthread_create(&thread_UART, ((void *)0), UART, ((void *)0));
  usleep(100000);

  printf("|                          Z21@%s:%i\t                   |\n","192.168.2.92",4129);
  printf("|                                                                          |\n");

  pthread_t thread_Z21_client;


  usleep(100000);

  printf("|                              BLOCK LINKING                               |\n");
  printf("|                                                                          |\n");





  if(DeviceList[0] != 0){

   memset(DeviceList,0,MAX_Devices);
  }


  COM_DevReset();

  usleep(200000);
  usleep(1000000);
  DeviceList[0] = 1;
  DeviceList[1] = 2;
  DeviceList[2] = 4;
  DeviceList[3] = 8;

  for(uint8_t i = 0;i<MAX_Devices;i++){
   LoadModules(DeviceList[i]);
   printf("|                       UART Module %i\t found                             |\n",Line_Data[2]);
  }

  clear_Modules();



  struct link LINK;
  struct link LINK2;
  LINK.Adr1 = EMPTY_BL();
  LINK.Adr2 = EMPTY_BL();
  LINK.Adr3 = EMPTY_BL();
  LINK.Adr4 = EMPTY_BL();
  LINK2.Adr1 = EMPTY_BL();
  LINK2.Adr2 = EMPTY_BL();
  int nr_Modules = 0;
  usleep(100000);
  digitalWrite(1,1);

  int setup[16] = {1,8,4,2,0};
  int setup2[5] = {11,6,7,0};

  for(int i = 0;i<4;i++){
# 492 "baan.c"
    printf("|                            Module %i\t found                             |\n",setup[i]);

    LINK = Modules(setup[i],LINK);
    if(!Adr_Comp2(LINK.Adr3,EMPTY_BL())){
     printf("Branch needed\n");
     printf("%i==%i\t%i==%i\t%c==%c\n",LINK.Adr3.Module,EMPTY_BL().Module,LINK.Adr3.Adr,EMPTY_BL().Adr,LINK.Adr3.type,EMPTY_BL().type);
     LINK2.Adr1 = LINK.Adr3;
     LINK2.Adr2 = LINK.Adr4;
    }

  }

  if(!Adr_Comp2(LINK2.Adr1,EMPTY_BL())){
   printf("|                                                                          |\n");
   printf("|                               Branch one                                 |\n");
  }

  for(int i = 0;i<0;i++){
   printf("|                            Module %i\t found                             |\n",setup2[i]);
   LINK2 = Modules(setup2[i],LINK2);
  }
  Connect_Segments();
  setup_JSON(setup,setup2,4,0);
  usleep(1000000);*/

  printf("|                                                                          |\n");
  printf("|                             Loading trains                               |\n");
  printf("|                                                                          |\n");

  init_trains();

 printf("|                                                                          |\n");
 printf("----------------------------------------------------------------------------\n\n");
 printf("                              Initialization Done\n");
 printf("          To complete the setup please load or connect the modules          \n");


 do_once_Magic();





 delay(5);
# 589 "baan.c"
 startup = 1;
# 601 "baan.c"
 if(connected_clients == 0){
  printf("                   Waiting until for a client connects\n");
 }
 while(connected_clients == 0){
  usleep(1000000);
 }
 initialise = 0;

 usleep(400000);

 pthread_t tid[10];
# 665 "baan.c"
 printf("Test octal: 023 = %i\n",023);




 printf("Creating Threads\n");
 pthread_create(&tid[0], ((void *)0), do_Magic, ((void *)0));
 pthread_create(&tid[1], ((void *)0), STOP_FUNC, ((void *)0));
 pthread_create(&tid[2], ((void *)0), clear_timers, ((void *)0));

 pthread_create(&tid[3], ((void *)0), TRAIN_SIMA, ((void *)0));
 usleep(500000);




 usleep(10000000);

 WS_ShortCircuit();
# 697 "baan.c"
 pthread_join(tid[0],((void *)0));
 printf("Magic JOINED\n");
 pthread_join(tid[1],((void *)0));
 printf("STOP JOINED\n");
 pthread_join(tid[2],((void *)0));
 printf("Timer JOINED\n");
 pthread_join(tid[3],((void *)0));
 printf("SimA JOINED\n");
 pthread_join(tid[4],((void *)0));
 printf("SimB JOINED\n");
 pthread_join(thread_UART,((void *)0));
 pthread_join(thread_web_server,((void *)0));



 close(uart0_filestream);

 printf("STOPPED");

}
